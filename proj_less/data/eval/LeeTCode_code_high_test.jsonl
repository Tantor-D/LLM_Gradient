{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_8", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 script for\n\nSpecial binary strings are binary strings with the following two properties:\n\nThe number of 0's is equal to the number of 1's.\nEvery prefix of the binary string has at least as many 1's as 0's.\n\nYou are given a special binary string s.\nA move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\nReturn the lexicographically largest resulting string possible after applying the mentioned operations on the string.\n\u00a0\nExample 1:\nInput: s = \"11011000\"\nOutput: \"11100100\"\nExplanation: The strings \"10\" [occuring at s[1]] and \"1100\" [at s[3]] are swapped.\nThis is the lexicographically largest string possible after some number of swaps.\n\nExample 2:\nInput: s = \"10\"\nOutput: \"10\"\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 50\ns[i] is either '0' or '1'.\ns is a special binary string.\n\n"}, {"role": "assistant", "content": "import collections\nclass Solution(object):\n    def makeLargestSpecial(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n    \n        S = list(S)\n        i = 0\n        while i < len(S):\n            if S[i] == \"0\":\n                # find a special substring ending in S\n                j = i-1\n                count = -1\n                while j >= 0:\n                    if S[j] == \"1\":\n                        count += 1\n                    else:\n                        count -= 1\n                    if count == 0:\n                        break\n                    j -= 1\n                if count == 0:\n                    start = j\n                    end = i+1\n                    ss = S[start:end]\n                    if end == len(S) or S[end] == \"0\":\n                        i += 1\n                        continue\n                    # Find a special string  starting here\n                    secs = end\n                    sece = secs+1\n                    count = 1\n                    while sece < len(S):\n                        count += 1 if S[sece] == \"1\" else -1\n                        if count == 0:\n                            break\n                        sece += 1\n                    if count == 0:\n                        sece += 1\n                        second = S[secs:sece]\n                        #print(ss,\" and \", second)\n                        if(ss+second < second+ss):\n                            # Swap these\n                            temp = ss\n                            #print(S)\n                            #print(S[start:end] , S[secs:sece])\n                            S = S[:start] + S[secs:sece] + S[start:end] + S[sece:]\n                            return \"\".join(self.makeLargestSpecial(S))\n            i += 1\n        return \"\".join(S)\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_24", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 2 that\n\nYou are given two integers n and maxValue, which are used to describe an ideal array.\nA 0-indexed integer array arr of length n is considered ideal if the following conditions hold:\n\nEvery arr[i] is a value from 1 to maxValue, for 0 <= i < n.\nEvery arr[i] is divisible by arr[i - 1], for 0 < i < n.\n\nReturn the number of distinct ideal arrays of length n. Since the answer may be very large, return it modulo 10^9 + 7.\n\u00a0\nExample 1:\nInput: n = 2, maxValue = 5\nOutput: 10\nExplanation: The following are the possible ideal arrays:\n- Arrays starting with the value 1 (5 arrays): [1,1], [1,2], [1,3], [1,4], [1,5]\n- Arrays starting with the value 2 (2 arrays): [2,2], [2,4]\n- Arrays starting with the value 3 (1 array): [3,3]\n- Arrays starting with the value 4 (1 array): [4,4]\n- Arrays starting with the value 5 (1 array): [5,5]\nThere are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays.\n\nExample 2:\nInput: n = 5, maxValue = 3\nOutput: 11\nExplanation: The following are the possible ideal arrays:\n- Arrays starting with the value 1 (9 arrays): \n   - With no other distinct values (1 array): [1,1,1,1,1] \n   - With 2nd distinct value 2 (4 arrays): [1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]\n   - With 2nd distinct value 3 (4 arrays): [1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]\n- Arrays starting with the value 2 (1 array): [2,2,2,2,2]\n- Arrays starting with the value 3 (1 array): [3,3,3,3,3]\nThere are a total of 9 + 1 + 1 = 11 distinct ideal arrays.\n\n\u00a0\nConstraints:\n\n2 <= n <= 10000\n1 <= maxValue <= 10000\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def idealArrays(self, n, maxValue):\n        \"\"\"\n        :type n: int\n        :type maxValue: int\n        :rtype: int\n        \"\"\"\n        mod = 1000000007\n        r = 1\n        b=1\n        d=1\n        ff = [1]*(n+1)\n        iff = [1]*(n+1)\n        def egcd(a, b):\n            if b==0:\n                return a, 1, 0\n            g, pa, pb = egcd(b, a%b)\n            return g, pb, pa-pb*(a/b)\n        for i in range(2, n+1):\n            ff[i]=ff[i-1]*i\n            ff[i]%=mod\n            _, x, y  = egcd(ff[i], mod)\n            x%=mod\n            if x<0: x+=mod\n            iff[i]=x\n        dp = {}\n        def count(c, v):\n            if c==0: return 1\n            if v<=1: return 0\n            k = (c, v)\n            if k in dp: return dp[k]\n            r = 0\n            for b in range(2, v+1):\n                r+=count(c-1, v/b)\n                r%=mod\n            dp[k]=r\n            return r\n            \n        while n>=d:\n            b<<=1\n            if b>maxValue: break\n            # C(n, d)*count(d)\n            c = ff[n]*iff[d]*iff[n-d]\n            c%=mod\n            c*=count(d, maxValue)\n            c%=mod\n            r+=c\n            r%=mod\n            d+=1\n        return r\n            "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_29", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 script for\n\nThere exists an undirected and initially unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nThe tree can be rooted at any node root of your choice. The incurred cost after choosing root is the difference between the maximum and minimum price sum amongst all paths starting at root.\nReturn the maximum possible cost amongst all possible root choices.\n\u00a0\nExample 1:\n\nInput: n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\nOutput: 24\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes [2,1,3,4]: the prices are [7,8,6,10], and the sum of the prices is 31.\n- The second path contains the node [2] with the price [7].\nThe difference between the maximum and minimum price sum is 24. It can be proved that 24 is the maximum cost.\n\nExample 2:\n\nInput: n = 3, edges = [[0,1],[1,2]], price = [1,1,1]\nOutput: 2\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes [0,1,2]: the prices are [1,1,1], and the sum of the prices is 3.\n- The second path contains node [0] with a price [1].\nThe difference between the maximum and minimum price sum is 2. It can be proved that 2 is the maximum cost.\n\n\u00a0\nConstraints:\n\n1 <= n <= 100000\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\n1 <= price[i] <= 100000\n\n"}, {"role": "assistant", "content": "from typing import List, Tuple, Optional\nfrom collections import defaultdict, Counter\nfrom sortedcontainers import SortedList\n\nMOD = int(1e9 + 7)\nINF = int(1e20)\n\n# \u7ed9\u4f60\u4e00\u4e2a n \u4e2a\u8282\u70b9\u7684\u65e0\u5411\u65e0\u6839\u56fe\uff0c\u8282\u70b9\u7f16\u53f7\u4e3a 0 \u5230 n - 1 \u3002\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570 n \u548c\u4e00\u4e2a\u957f\u5ea6\u4e3a n - 1 \u7684\u4e8c\u7ef4\u6574\u6570\u6570\u7ec4 edges \uff0c\u5176\u4e2d edges[i] = [ai, bi] \u8868\u793a\u6811\u4e2d\u8282\u70b9 ai \u548c bi \u4e4b\u95f4\u6709\u4e00\u6761\u8fb9\u3002\n\n# \u6bcf\u4e2a\u8282\u70b9\u90fd\u6709\u4e00\u4e2a\u4ef7\u503c\u3002\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 price \uff0c\u5176\u4e2d price[i] \u662f\u7b2c i \u4e2a\u8282\u70b9\u7684\u4ef7\u503c\u3002\n\n# \u4e00\u6761\u8def\u5f84\u7684 \u4ef7\u503c\u548c \u662f\u8fd9\u6761\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u4ef7\u503c\u4e4b\u548c\u3002\n\n# \u4f60\u53ef\u4ee5\u9009\u62e9\u6811\u4e2d\u4efb\u610f\u4e00\u4e2a\u8282\u70b9\u4f5c\u4e3a\u6839\u8282\u70b9 root \u3002\u9009\u62e9 root \u4e3a\u6839\u7684 \u5f00\u9500 \u662f\u4ee5 root \u4e3a\u8d77\u70b9\u7684\u6240\u6709\u8def\u5f84\u4e2d\uff0c\u4ef7\u503c\u548c \u6700\u5927\u7684\u4e00\u6761\u8def\u5f84\u4e0e\u6700\u5c0f\u7684\u4e00\u6761\u8def\u5f84\u7684\u5dee\u503c\u3002\n\n# \u8bf7\u4f60\u8fd4\u56de\u6240\u6709\u8282\u70b9\u4f5c\u4e3a\u6839\u8282\u70b9\u7684\u9009\u62e9\u4e2d\uff0c\u6700\u5927 \u7684 \u5f00\u9500 \u4e3a\u591a\u5c11\u3002\n\n\nfrom typing import Callable, Generic, List, TypeVar\n\nT = TypeVar(\"T\")\n\n\nE = Callable[[int], T]\n\"\"\"identify element of op, and answer of leaf\"\"\"\n\nOp = Callable[[T, T], T]\n\"\"\"merge value of child node\"\"\"\n\nComposition = Callable[[T, int, int, int], T]\n\"\"\"return value from child node to parent node\"\"\"\n\n\nclass Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        class Rerooting(Generic[T]):\n\n            __slots__ = (\"adjList\", \"_n\", \"_decrement\", \"_root\", \"_parent\", \"_order\")\n\n            def __init__(self, n: int, decrement: int = 0):\n                \"\"\"\n                n: \u9802\u70b9\u6570\n                decrement: \u9802\u70b9\u306e\u5024\u3092\u6e1b\u3089\u3059\u91cf (1-indexed\u306a\u30891, 0-indexed\u306a\u30890)\n                \"\"\"\n                self.adjList = [[] for _ in range(n)]\n                self._n = n\n                self._decrement = decrement\n                self._root = None  # \u4e00\u756a\u6700\u521d\u306b\u6839\u3068\u3059\u308b\u9802\u70b9\n\n            def addEdge(self, u: int, v: int):\n                \"\"\"\n                u,v \u9593\u306b\u7121\u5411\u8fba\u3092\u5f35\u308b (u->v, v->u)\n                \"\"\"\n                u -= self._decrement\n                v -= self._decrement\n                self.adjList[u].append(v)\n                self.adjList[v].append(u)\n\n            def rerooting(\n                self, e: E[\"T\"], op: Op[\"T\"], composition: Composition[\"T\"], root=0\n            ) -> List[\"T\"]:\n                \"\"\"\n                - e: \u5358\u4f4d\u5143\n                  (root) -> res\n                  merge\u306e\u5358\u4f4d\u5143\n                  \u4f8b:\u6700\u3082\u9060\u3044\u70b9\u307e\u3067\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b\u5834\u5408 e=0\n\n                - op: \u5b50\u306e\u5024\u3092\u89aa\u306b\u30de\u30fc\u30b8\u3059\u308b\u95a2\u6570\n                  (childRes1,childRes2) -> newRes\n                  \u30e2\u30ce\u30a4\u30c9\u306e\u6027\u8cea\u3092\u6e80\u305f\u3059\u6f14\u7b97\u3092\u5b9a\u7fa9\u3059\u308b \u305d\u308c\u304c\u5168\u65b9\u4f4d\u6728DP\u3092\u3059\u308b\u6761\u4ef6\n                  \u4f8b:\u6700\u3082\u9060\u3044\u70b9\u307e\u3067\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b\u5834\u5408 return max(childRes1,childRes2)\n\n                - composition: \u9802\u70b9\u306e\u5024\u3092\u66f4\u65b0\u3059\u308b\u95a2\u6570\n                  (fromRes,parent,cur,direction) -> newRes\n                  direction: 0\u8868\u793a\u7528cur\u66f4\u65b0parent\u7684dp1,1\u8868\u793a\u7528parent\u66f4\u65b0cur\u7684dp2\n                  dp\u3092merge\u3059\u308b\u524d\u6bb5\u968e\u3067\u5b9f\u884c\u3059\u308b\u6f14\u7b97\n                  \u4f8b:\u6700\u3082\u9060\u3044\u70b9\u307e\u3067\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b\u5834\u5408 return fromRes+1\n\n                - root: \u6839\u3068\u3059\u308b\u9802\u70b9\n\n                <\u6982\u8981>\n                1. root\u3092\u6839\u3068\u3057\u3066\u307e\u305a\u4e00\u5ea6\u6728\u69cb\u9020\u3092bfs\u3067\u6c42\u3081\u308b \u591a\u304f\u306e\u5834\u5408root\u306f\u4efb\u610f (0)\n                2. \u81ea\u8eab\u306e\u90e8\u5206\u6728\u306edp\u306e\u5024\u3092dp1\u306b\u3001\u81ea\u8eab\u3092\u542b\u307e\u306a\u3044\u5144\u5f1f\u306edp\u306e\u5024\u306emerge\u3092dp2\u306b\u5165\u308c\u308b\n                  \u6728\u69cb\u9020\u304c\u5b9a\u307e\u3063\u3066\u3044\u308b\u3053\u3068\u304b\u3089\u3053\u308c\u304c\u52b9\u7387\u7684\u306b\u6c42\u3081\u3089\u308c\u308b\u3002 \u8449\u5074\u304b\u3089\u30dc\u30c8\u30e0\u30a2\u30c3\u30d7\u306b\u5b9f\u884c\u3059\u308b\n                3. \u4efb\u610f\u306e\u9802\u70b9\u3092\u65b0\u305f\u306b\u6839\u306b\u3057\u305f\u3068\u304d\u3001\u90e8\u5206\u6728\u306f\n                  \u2460\u5143\u306e\u90e8\u5206\u6728 \u2461\u5144\u5f1f\u3092\u89aa\u3068\u3057\u305f\u90e8\u5206\u6728 \u2462\u5143\u306e\u89aa\u3092\u89aa\u3068\u3057\u305f(\u5143\u306e\u6839\u306e\u65b9\u5411\u306b\u4f38\u3073\u308b)\u90e8\u5206\u6728\u306e\u4e09\u3064\u306b\u5206\u304b\u308c\u308b\u3002\n                  \u2460\u306fstep2\u306edp1\u3067\u3042\u308a\u3001\u304b\u3064dp2\u306fstep3\u306b\u304a\u3044\u3066\u3001\u2461\u304b\u3089\u2461\u3068\u2462\u3092merge\u3057\u305f\u5024\u3078\u3068\u66f4\u65b0\u3055\u308c\u3066\u3044\u308b\u306e\u3067\n                  \u2461\u3082\u2462\u3082\u5206\u304b\u3063\u3066\u3044\u308b\u3002 \u6839\u5074\u304b\u3089\u30c8\u30c3\u30d7\u30c0\u30a6\u30f3\u306b\u5b9f\u884c\u3059\u308b(\u3053\u306e\u3053\u3068\u304c\u4e0a\u8a18\u306e\u66f4\u65b0\u306b\u304a\u3044\u3066\u91cd\u8981)\n\n                \u8a08\u7b97\u91cf O(|V|) (V\u306f\u9802\u70b9\u6570)\n                \u53c2\u7167 https://qiita.com/keymoon/items/2a52f1b0fb7ef67fb89e\n                \"\"\"\n                # step1\n                root -= self._decrement\n                assert 0 <= root < self._n\n                self._root = root\n                self._parent = [-1] * self._n  # \u89aa\u306e\u756a\u53f7\u3092\u8a18\u9332\n                self._order = [root]  # bfs\u306e\u8a2a\u554f\u9806\u3092\u8a18\u9332 \u6df1\u3055\u304c\u5e83\u7fa9\u5358\u8abf\u5897\u52a0\u3057\u3066\u3044\u308b\n                stack = [root]\n                while stack:\n                    cur = stack.pop()\n                    for next in self.adjList[cur]:\n                        if next == self._parent[cur]:\n                            continue\n                        self._parent[next] = cur\n                        self._order.append(next)\n                        stack.append(next)\n\n                # step2\n                dp1 = [e(i) for i in range(self._n)]  # !\u5b50\u6811\u90e8\u5206\u7684dp\u503c\n                dp2 = [e(i) for i in range(self._n)]  # !\u975e\u5b50\u6811\u90e8\u5206\u7684dp\u503c\n                for cur in self._order[::-1]:  # \u4ece\u4e0b\u5f80\u4e0a\u62d3\u6251\u5e8fdp\n                    res = e(cur)\n                    for next in self.adjList[cur]:\n                        if self._parent[cur] == next:\n                            continue\n                        dp2[next] = res\n                        res = op(res, composition(dp1[next], cur, next, 0))  # op\u4ece\u4e0b\u5f80\u4e0a\u66f4\u65b0dp1\n                    res = e(cur)\n                    for next in self.adjList[cur][::-1]:\n                        if self._parent[cur] == next:\n                            continue\n                        dp2[next] = op(res, dp2[next])\n                        res = op(res, composition(dp1[next], cur, next, 0))\n                    dp1[cur] = res\n\n                # step3\n                for newRoot in self._order[1:]:  # \u5143\u306e\u6839\u306b\u95a2\u3059\u308bdp1\u306f\u65e2\u306b\u6c42\u307e\u3063\u3066\u3044\u308b\n                    parent = self._parent[newRoot]\n                    dp2[newRoot] = composition(\n                        op(dp2[newRoot], dp2[parent]), parent, newRoot, 1\n                    )  # op\u4ece\u4e0a\u5f80\u4e0b\u66f4\u65b0dp2\n                    dp1[newRoot] = op(dp1[newRoot], dp2[newRoot])\n                return dp1\n\n        def e(root: int) -> int:\n            # merge\u306e\u5358\u4f4d\u5143\n            # \u4f8b:\u6700\u3082\u9060\u3044\u70b9\u307e\u3067\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b\u5834\u5408 e=0\n            return 0\n\n        def op(childRes1: int, childRes2: int) -> int:\n            # \u30e2\u30ce\u30a4\u30c9\u306e\u6027\u8cea\u3092\u6e80\u305f\u3059\u6f14\u7b97\u3092\u5b9a\u7fa9\u3059\u308b \u305d\u308c\u304c\u5168\u65b9\u4f4d\u6728DP\u3092\u3059\u308b\u6761\u4ef6\n            # \u4f8b:\u6700\u3082\u9060\u3044\u70b9\u307e\u3067\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b\u5834\u5408 return max(childRes1,childRes2)\n            return max(childRes1, childRes2)\n\n        def composition(fromRes: int, parent: int, cur: int, direction: int) -> int:\n            # dp\u3092merge\u3059\u308b\u524d\u6bb5\u968e\u3067\u5b9f\u884c\u3059\u308b\u6f14\u7b97\n            # \u4f8b:\u6700\u3082\u9060\u3044\u70b9\u307e\u3067\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b\u5834\u5408 return res+1\n            if direction == 0:  # cur -> parent\n                return fromRes + price[cur]\n            return fromRes + price[parent]\n\n        R = Rerooting(n)\n        for u, v in edges:\n            R.addEdge(u, v)\n        res = R.rerooting(e, op, composition)\n        return max(res)\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_82", "label": "code_high", "messages": [{"role": "user", "content": "Can you implement a function in Python 3 that\n\nYou are given a string s containing lowercase letters and an integer k. You need to :\n\nFirst, change some characters of s to other lowercase English letters.\nThen divide s into k non-empty disjoint substrings such that each substring is a palindrome.\n\nReturn the minimal number of characters that you need to change to divide the string.\n\u00a0\nExample 1:\nInput: s = \"abc\", k = 2\nOutput: 1\nExplanation:\u00a0You can split the string into \"ab\" and \"c\", and change 1 character in \"ab\" to make it palindrome.\n\nExample 2:\nInput: s = \"aabbc\", k = 3\nOutput: 0\nExplanation:\u00a0You can split the string into \"aa\", \"bb\" and \"c\", all of them are palindrome.\nExample 3:\nInput: s = \"leetcode\", k = 8\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= k <= s.length <= 100.\ns only contains lowercase English letters.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        d = [[0]*len(s) for _ in range(len(s))]\n        for lmid in range(len(s)):\n            for rmid in [lmid, lmid+1]:\n                for move in range(len(s)):\n                    l = lmid - move\n                    r = rmid + move\n                    if l<0 or r >= len(s):\n                        break\n                    if move == 0:\n                        if l == r:\n                            d[l][r] = 0\n                        else:\n                            d[l][r] = 0 if s[l] == s[r] else 1\n                    else:\n                        d[l][r] = d[l+1][r-1]\n                        d[l][r] += 0 if s[l] == s[r] else 1\n        f = [[-1]*(k+1) for _ in range(len(s))]\n        \n        for j in range(k):\n            for i in range(len(s)):\n                if j > i:\n                    continue\n                if j == 0:\n                    f[i][j] = d[0][i]\n                for r in range(i+1, len(s)):\n                    if f[r][j+1] == -1 or f[r][j+1] > f[i][j] + d[i+1][r]:\n                        f[r][j+1] = f[i][j] + d[i+1][r]\n        return f[len(s)-1][k-1]\n                    "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_156", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 script for\n\nThere is a strange printer with the following two special requirements:\n\nOn each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\nOnce the printer has used a color for the above operation, the same color cannot be used again.\n\nYou are given a m x n matrix targetGrid, where targetGrid[row][col] is the color in the position (row, col) of the grid.\nReturn true if it is possible to print the matrix targetGrid, otherwise, return false.\n\u00a0\nExample 1:\n\nInput: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\nOutput: true\n\nExample 2:\n\nInput: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\nOutput: true\n\nExample 3:\nInput: targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\nOutput: false\nExplanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\n\n\u00a0\nConstraints:\n\nm == targetGrid.length\nn == targetGrid[i].length\n1 <= m, n <= 60\n1 <= targetGrid[row][col] <= 60\n\n"}, {"role": "assistant", "content": "INF = 1 << 60\nclass Solution:\n    def isPrintable(self, grid: List[List[int]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        \n        cols = set()\n        for i, j in product(range(m), range(n)):\n            cols.add(grid[i][j])\n        D = {v : i for i, v in enumerate(sorted(cols))}\n        for i, j in product(range(m), range(n)):\n            grid[i][j] = D[grid[i][j]]\n        col = len(cols)\n        \n        left = [INF] * col\n        right = [-INF] * col\n        up = [INF] * col\n        down = [-INF] * col\n        for i, j in product(range(m), range(n)):\n            c = grid[i][j]\n            left[c] = min(left[c], j)\n            right[c] = max(right[c], j)\n            up[c] = min(up[c], i)\n            down[c] = max(down[c], i)\n        \n        E = [set() for _ in range(col)]\n        for c in range(col):\n            for i, j in product(range(up[c], down[c] + 1), range(left[c], right[c] + 1)):\n                if grid[i][j] != c:\n                    E[c].add(grid[i][j])\n        \n        n = col\n        deg = [0] * n\n        for v in range(n):\n            for nv in E[v]:\n                deg[nv] += 1\n        \n        ans = list(v for v in range(col) if deg[v]==0)\n        deq = deque(ans)\n        used = [0]*col\n\n        while deq:\n            v = deq.popleft()\n            for t in E[v]:\n                deg[t] -= 1\n                if deg[t]==0:\n                    deq.append(t)\n                    ans.append(t)\n        \n        return len(ans) == col"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_157", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 2 to\n\nThere is a strange printer with the following two special requirements:\n\nOn each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\nOnce the printer has used a color for the above operation, the same color cannot be used again.\n\nYou are given a m x n matrix targetGrid, where targetGrid[row][col] is the color in the position (row, col) of the grid.\nReturn true if it is possible to print the matrix targetGrid, otherwise, return false.\n\u00a0\nExample 1:\n\nInput: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\nOutput: true\n\nExample 2:\n\nInput: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\nOutput: true\n\nExample 3:\nInput: targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\nOutput: false\nExplanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\n\n\u00a0\nConstraints:\n\nm == targetGrid.length\nn == targetGrid[i].length\n1 <= m, n <= 60\n1 <= targetGrid[row][col] <= 60\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def isPrintable(self, targetGrid):\n        \"\"\"\n        :type targetGrid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        minx, maxx, miny, maxy = [-1]*61, [-1]*61, [-1]*61, [-1]*61\n        m, n = len(targetGrid), len(targetGrid[0])\n        for i in range(m):\n            for j in range(n):\n                c = targetGrid[i][j]\n                if minx[c]==-1 or minx[c]>i: minx[c]=i\n                if maxx[c]==-1 or maxx[c]<i: maxx[c]=i\n                if miny[c]==-1 or miny[c]>j: miny[c]=j\n                if maxy[c]==-1 or maxy[c]<j: maxy[c]=j\n        # print minx[1], maxx[1], minx[60], maxx[60]\n        # print miny[1], maxy[1], miny[60], maxy[60]\n        while True:\n            c = 1\n            relax = False\n            while c<=60:\n                if minx[c]!=-1:\n                    match = True\n                    for i in range(minx[c], maxx[c]+1):\n                        for j in range(miny[c], maxy[c]+1):\n                            if targetGrid[i][j]==c or targetGrid[i][j]==-1:\n                                pass\n                            else:\n                                match=False\n                                break\n                        if not match: break\n                    if match:\n                        \n                        relax = True\n                        # print \"paint\", c\n                        for i in range(minx[c], maxx[c]+1):\n                            for j in range(miny[c], maxy[c]+1):\n                                targetGrid[i][j]=-1\n                        minx[c]=-1\n                c+=1\n            if not relax: break\n        # print targetGrid\n        for i in range(m):\n            for j in range(n):\n                if targetGrid[i][j]!=-1: return False\n        return True"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_177", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 3 that\n\nGiven a 2D grid of 0s and 1s, return the number of elements in\u00a0the largest square\u00a0subgrid that has all 1s on its border, or 0 if such a subgrid\u00a0doesn't exist in the grid.\n\u00a0\nExample 1:\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 9\n\nExample 2:\nInput: grid = [[1,1,0,0]]\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= grid.length <= 100\n1 <= grid[0].length <= 100\ngrid[i][j] is 0 or 1\n"}, {"role": "assistant", "content": "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        # up[i][j] stores number of 1s up.\n        m = len(grid)\n        n = len(grid[0])\n        up = [[0 for _ in range(n)] for _ in range(m)]\n        for row in range(m):\n            for col in range(n):\n                if grid[row][col] == 0: continue\n                if row == 0:\n                    up[row][col] = 1\n                else:\n                    up[row][col] = 1 + up[row - 1][col]\n        left = [[0 for _ in range(n)] for _ in range(m)]\n        for row in range(m):\n            for col in range(n):\n                if grid[row][col] == 0: continue\n                if col == 0:\n                    left[row][col] = 1\n                else:\n                    left[row][col] = 1 + left[row][col - 1]\n        for l in range(min(m, n), -1, -1):\n            # Check if there exists l.\n            for row in range(l - 1, m):\n                for col in range(l - 1, n):\n                    if up[row][col] >= l and left[row][col] >= l and up[row][col - l + 1] >= l and left[row - l + 1][col] >= l:\n                        return l ** 2\n        return 0"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_188", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 script for\n\nThere are k workers who want to move n boxes from an old warehouse to a new one. You are given the two integers n and k, and a 2D integer array time of size k x 4 where time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].\nThe warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all k workers are waiting on the left side of the bridge. To move the boxes, the ith worker (0-indexed) can :\n\nCross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in leftToRighti minutes.\nPick a box from the old warehouse and return to the bridge in pickOldi minutes. Different workers can pick up their boxes simultaneously.\nCross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in rightToLefti minutes.\nPut the box in the new warehouse and return to the bridge in putNewi minutes. Different workers can put their boxes simultaneously.\n\nA worker i is less efficient than a worker j if either condition is met:\n\nleftToRighti + rightToLefti > leftToRightj + rightToLeftj\nleftToRighti + rightToLefti == leftToRightj + rightToLeftj and i > j\n\nThe following rules regulate the movement of the workers through the bridge :\n\nIf a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge.\nIf the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\nIf the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\n\nReturn the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\n\u00a0\nExample 1:\nInput: n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]\nOutput: 6\nExplanation: \nFrom 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.\nFrom 1 to 2: worker 2 picks up a box from the old warehouse.\nFrom 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.\nFrom 6 to 7: worker 2 puts a box at the new warehouse.\nThe whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\nExample 2:\nInput: n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]\nOutput: 50\nExplanation: \nFrom 0 \u00a0to 10: worker 1 crosses the bridge from the left bank to the right bank.\nFrom 10 to 20: worker 1 picks up a box from the old warehouse.\nFrom 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 11 to 20: worker 0 picks up a box from the old warehouse.\nFrom 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.\nFrom 30 to 40: worker 1 puts a box at the new warehouse.\nFrom 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 31 to 39: worker 0 puts a box at the new warehouse.\nFrom 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 40 to 49: worker 0 picks up a box from the old warehouse.\nFrom 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 50 to 58: worker 0 puts a box at the new warehouse.\nThe whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\n\u00a0\nConstraints:\n\n1 <= n, k <= 10000\ntime.length == k\ntime[i].length == 4\n1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000\n\n"}, {"role": "assistant", "content": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        left = [(-ltr - rtl, -i, 0) for i, (ltr, po, rtl, pn) in enumerate(time)]\n        right = []\n        heapq.heapify(left)\n        leftPick = []\n        rightPick = []\n        t = 0\n        toPick = n\n        # kkk = 0\n        while n > 0:\n            while leftPick and leftPick[0][0] <= t:\n                nt, i, pri = heapq.heappop(leftPick)\n                heapq.heappush(left, (pri, -i, nt))\n            while rightPick and rightPick[0][0] <= t:\n                nt, i, pri = heapq.heappop(rightPick)\n                heapq.heappush(right, (pri, -i, nt))\n            if right and right[0][2] <= t:\n                pri, i, _ = heapq.heappop(right)\n                i = -i\n                t += time[i][2]\n                heapq.heappush(leftPick, (t + time[i][3], i, pri))\n                n -= 1\n            elif toPick > 0 and left and left[0][2] <= t:\n                pri, i, _ = heapq.heappop(left)\n                i = -i\n                t += time[i][0]\n                heapq.heappush(rightPick, (t + time[i][1], i, pri))\n                toPick -= 1\n                if toPick == 0:\n                    left = []\n            else:\n                tt = math.inf\n                if leftPick and leftPick[0][0] > t:\n                    tt = min(tt, leftPick[0][0])\n                if rightPick and rightPick[0][0] > t:\n                    tt = min(tt, rightPick[0][0])\n                if left and left[0][2] > t:\n                    tt = min(tt, left[0][2])\n                if right and right[0][2] > t:\n                    tt = min(tt, right[0][2])\n                t = max(tt, t)\n                # print(tt, t)\n                # kkk += 1\n                # if kkk == 30:\n                #     print(right)\n                #     print(left)\n                #     print(leftPick)\n                #     print(rightPick)\n                #     print(toPick)\n                #     print(n)\n                #     break\n        return t\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_193", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 3 to\n\nYou are given an m x n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's.\nThe grid is said to be connected if we have exactly one island, otherwise is said disconnected.\nIn one day, we are allowed to change any single land cell (1) into a water cell (0).\nReturn the minimum number of days to disconnect the grid.\n\u00a0\nExample 1:\n\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\n\nOutput: 2\nExplanation: We need at least 2 days to get a disconnected grid.\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island.\n\nExample 2:\n\nInput: grid = [[1,1]]\nOutput: 2\nExplanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0 islands.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either 0 or 1.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def minDays(self, grid: List[List[int]]) -> int:\n        width,height = len(grid[0]),len(grid)\n        \n        def countislands(grid):\n            islands = 0\n            seen = set()\n            for row in range(height):\n                for col in range(width):\n                    if (row,col) not in seen and grid[row][col] == 1:\n                        islands+=1\n                        tocheck = [(row,col)]\n                        seen.add((row,col))\n                        while len(tocheck)>0:\n                            newtocheck = set()\n                            for el in tocheck:\n                                compass = [(el[0]+1,el[1]),(el[0],el[1]+1),(el[0]-1,el[1]),(el[0],el[1]-1)]\n                                for d in compass:\n                                    if d[0]>=0 and d[0]<height and d[1]>=0 and d[1]<width:\n                                        if d not in seen and grid[d[0]][d[1]] == 1:\n                                            newtocheck.add(d)\n                                            seen.add(d)\n                            tocheck = newtocheck\n            return islands\n        \n        if countislands(grid)>1:\n            return 0\n\n        for row in range(len(grid)):\n            for col in range(len(grid[row])):\n                if grid[row][col] == 1:\n                    #print(row,col)\n                    clonegrid = copy.deepcopy(grid)\n                    clonegrid[row][col] = 0\n                    if countislands(clonegrid)>1:\n                        #print(\"works!\")\n                        return 1\n        \n        return 2"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_243", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 3 that\n\nGiven a string s, return the number of different non-empty palindromic subsequences in s. Since the answer may be very large, return it modulo 10^9 + 7.\nA subsequence of a string is obtained by deleting zero or more characters from the string.\nA sequence is palindromic if it is equal to the sequence reversed.\nTwo sequences a1, a2, ... and b1, b2, ... are different if there is some i for which ai != bi.\n\u00a0\nExample 1:\nInput: s = \"bccb\"\nOutput: 6\nExplanation: The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\nNote that 'bcb' is counted only once, even though it occurs twice.\n\nExample 2:\nInput: s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"\nOutput: 104860361\nExplanation: There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 1000\ns[i] is either 'a', 'b', 'c', or 'd'.\n\n"}, {"role": "assistant", "content": "import sys\n\nclass Solution:\n    MOD = 10**9 + 7\n    \n    def count(self, S, left, right):\n        if (left, right) in self.result:\n            return self.result[(left, right)]\n        \n        r = 0\n        for ch in ('a', 'b', 'c', 'd'):\n            first_ch = self.first[left].get(ch)\n            last_ch = self.last[right].get(ch)\n            if first_ch is None or first_ch > right:\n                continue\n            if last_ch is None or last_ch < left:\n                continue\n            # Single character\n            r += 1\n            if r >= self.MOD: r -= self.MOD\n            if first_ch != last_ch:\n                # Double character\n                r += 1\n                if r >= self.MOD: r -= self.MOD\n                # Contain\n                sub = self.count(S, first_ch+1, last_ch-1)\n                r += sub\n                if r >= self.MOD: r -= self.MOD\n        self.result[(left, right)] = r              \n        return r\n            \n    def countPalindromicSubsequences(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        N = len(S)\n        self.first = []\n        for i in range(N):\n            first = {}\n            for j in range(i, N):\n                if S[j] not in first:\n                    first[S[j]] = j\n            self.first.append(first)\n        self.last = []            \n        for i in range(N):\n            last = {}\n            for j in range(i, -1, -1):\n                if S[j] not in last:\n                    last[S[j]] = j                \n            self.last.append(last)\n            \n        self.result = {}\n        for i in range(0, N):\n            self.result[(i+1, i)] = 0\n        return self.count(S, 0, N-1)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_366", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 2 function for\n\nYou have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n\u00a0\nExample 1:\nInput: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\nOutput: 6\nExplanation: \nA sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\nNote that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\nbecause the wheels of the lock become stuck after the display becomes the dead end \"0102\".\n\nExample 2:\nInput: deadends = [\"8888\"], target = \"0009\"\nOutput: 1\nExplanation: We can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\n\nExample 3:\nInput: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\nOutput: -1\nExplanation: We cannot reach the target without getting stuck.\n\n\u00a0\nConstraints:\n\n1 <= deadends.length <= 500\ndeadends[i].length == 4\ntarget.length == 4\ntarget will not be in the list deadends.\ntarget and deadends[i] consist of digits only.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def openLock(self, deadends, target):\n        \"\"\"\n        :type deadends: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n\n        dic = {}\n        dic['0000'] = True\n\n        blocked = {}\n        for de in deadends:\n            blocked[de] = True\n\n        if \"0000\" in blocked:\n            return -1\n        q = []\n        q.append(('0000', 0))\n        while q:\n            cur = q.pop(0)\n            if cur[0] == target:\n                return cur[1]\n            for i in range(4):\n                if cur[0][i] == '0':\n                    temp = cur[0][0:i] + '9' + cur[0][i + 1:4]\n                    if temp not in dic and temp not in blocked:\n                        dic[temp] = True\n                        q.append((temp, cur[1] + 1))\n                    temp = cur[0][0:i] + '1' + cur[0][i + 1:4]\n                    if temp not in dic and temp not in blocked:\n                        dic[temp] = True\n                        q.append((temp, cur[1] + 1))\n                elif cur[0][i] == '9':\n                    temp = cur[0][0:i] + '0' + cur[0][i + 1:4]\n                    if temp not in dic and temp not in blocked:\n                        dic[temp] = True\n                        q.append((temp, cur[1] + 1))\n                    temp = cur[0][0:i] + '8' + cur[0][i + 1:4]\n                    if temp not in dic and temp not in blocked:\n                        dic[temp] = True\n                        q.append((temp, cur[1] + 1))\n                else:\n                    temp = cur[0][0:i] + chr(ord(cur[0][i]) - 1) + cur[0][i + 1:4]\n                    if temp not in dic and temp not in blocked:\n                        dic[temp] = True\n                        q.append((temp, cur[1] + 1))\n                    temp = cur[0][0:i] + chr(ord(cur[0][i]) + 1) + cur[0][i + 1:4]\n                    if temp not in dic and temp not in blocked:\n                        dic[temp] = True\n                        q.append((temp, cur[1] + 1))\n        return -1\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_385", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 2 to\n\nYou are given an n x n binary grid board. In each move, you can swap any two rows with each other, or any two columns with each other.\nReturn the minimum number of moves to transform the board into a chessboard board. If the task is impossible, return -1.\nA chessboard board is a board where no 0's and no 1's are 4-directionally adjacent.\n\u00a0\nExample 1:\n\nInput: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\nOutput: 2\nExplanation: One potential sequence of moves is shown.\nThe first move swaps the first and second column.\nThe second move swaps the second and third row.\n\nExample 2:\n\nInput: board = [[0,1],[1,0]]\nOutput: 0\nExplanation: Also note that the board with 0 in the top left corner, is also a valid chessboard.\n\nExample 3:\n\nInput: board = [[1,0],[1,0]]\nOutput: -1\nExplanation: No matter what sequence of moves you make, you cannot end with a valid chessboard.\n\n\u00a0\nConstraints:\n\nn == board.length\nn == board[i].length\n2 <= n <= 30\nboard[i][j] is either\u00a00 or 1.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def movesToChessboard(self, board):\n        \n        def dist(set1, set2):\n            x = [item for item in set1 if item in set2]\n            return len(set1)-len(x)\n        \n        \n        N = len(board)\n        if N<=1:\n            return 0\n        sm = sum(sum(row) for row in board)\n        if N%2==0:\n            if sm!=(N*N//2):\n                return -1\n        else:\n            m = N//2\n            if sm not in (2*m*m+2*m+1, 2*m*m+2*m):\n                return -1\n            if sm== 2*m*(m+1):\n                for i in range(N):\n                    for j in range(N):\n                        board[i][j] = 1-board[i][j]\n            \n            \n        rows1, rows2, cols1, cols2 = set(), set(), set(), set()\n        for T in range(N*N):\n            r = T//N\n            c = T%N\n            if board[r][c]==1:\n                rows1.add(r)\n                cols1.add(c)\n                break\n        for i in range (N):\n            if board[r][i]==1:\n                cols1.add(i)\n            if board[i][c]==1:\n                rows1.add(i)\n        for i in range (N):\n            if i not in rows1:\n                rows2.add(i)\n            if i not in cols1:\n                cols2.add(i)\n        for i in range (N):\n            for j in range(N):\n                if i in rows1 and j in cols1 and board[i][j]==0:\n                    return -1\n                elif i in rows1 and j in cols2 and board[i][j]==1:\n                    return -1\n                elif i in rows2 and j in cols1 and board[i][j]==1:\n                    return -1\n                elif i in rows2 and j in cols2 and board[i][j]==0:\n                    return -1\n                \n        if len(rows1)!=len(cols1):\n            return -1\n        \n        evens = set(range(0,N,2))\n        odds = set(range(1,N,2))\n        \n        if N%2==0:\n            A = dist(rows1, odds)\n            B = dist(rows1, evens)\n            \n            C = dist(cols1, odds)\n            D = dist(cols1, evens)\n            \n            return min(A,B)+min(C,D)         \n            \n        else:\n            if len(rows1)==m:\n                return dist(rows1, odds)+dist(cols1, odds)\n            else:\n                return dist(rows1,evens)+dist(cols1, evens)\n                    \n                \n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_451", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 2 to\n\nGiven an integer n, return the number of positive integers in the range [1, n] that have at least one repeated digit.\n\u00a0\nExample 1:\nInput: n = 20\nOutput: 1\nExplanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\n\nExample 2:\nInput: n = 100\nOutput: 10\nExplanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\n\nExample 3:\nInput: n = 1000\nOutput: 262\n\n\u00a0\nConstraints:\n\n1 <= n <= 10^9\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def numDupDigitsAtMostN(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def helper(n,used):\n            if not used:\n                if n == 0:\n                    return 0\n                if n == 1:\n                    return 9\n                res = 9\n                tmp = 9\n                while n > 1:\n                    res *= tmp\n                    n -= 1\n                    tmp -= 1\n                return res\n            else:\n                N = 10-used\n                res = 1\n                for _ in range(n):\n                    res *= N\n                    N -= 1\n                return res\n        if N < 11:\n            return 0\n        res = 0\n        l = len(str(N))-1\n        while l:\n            res += helper(l,0)\n            l -= 1\n        # print(res)\n        lenN = len(str(N))\n        l = lenN-1\n        used = set()\n        total = N\n        flag = False\n        while l:\n            digit = N/(10**(l))\n            if digit in used:\n                flag = True\n            used.add(digit)\n            # print(digit,l,used,res)\n            if l == lenN-1:\n                res += (digit-1)*helper(l,lenN-l)\n            else:\n                for i in range(digit):\n                    if i not in used:\n                        res += helper(l,lenN-l)\n            if flag:\n                break\n            l -= 1\n            N %= (10**(l+1))\n        # print(res)\n        used = set(str(total)[:-1])\n        if len(used) != len(str(total))-1:\n            return total-res\n        N = total/10*10\n        while N <= total:\n            if str(N%10) not in used:\n                res += 1\n            N += 1\n        return total-res"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_487", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 3 program that\n\nYou are given a 0-indexed integer array nums, and you are allowed to traverse between its indices. You can traverse between index i and index j, i != j, if and only if gcd(nums[i], nums[j]) > 1, where gcd is the greatest common divisor.\nYour task is to determine if for every pair of indices i and j in nums, where i < j, there exists a sequence of traversals that can take us from i to j.\nReturn true if it is possible to traverse between all such pairs of indices, or false otherwise.\n\u00a0\nExample 1:\nInput: nums = [2,3,6]\nOutput: true\nExplanation: In this example, there are 3 possible pairs of indices: (0, 1), (0, 2), and (1, 2).\nTo go from index 0 to index 1, we can use the sequence of traversals 0 -> 2 -> 1, where we move from index 0 to index 2 because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 > 1, and then move from index 2 to index 1 because gcd(nums[2], nums[1]) = gcd(6, 3) = 3 > 1.\nTo go from index 0 to index 2, we can just go directly because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 > 1. Likewise, to go from index 1 to index 2, we can just go directly because gcd(nums[1], nums[2]) = gcd(3, 6) = 3 > 1.\n\nExample 2:\nInput: nums = [3,9,5]\nOutput: false\nExplanation: No sequence of traversals can take us from index 0 to index 2 in this example. So, we return false.\n\nExample 3:\nInput: nums = [4,3,12,8]\nOutput: true\nExplanation: There are 6 possible pairs of indices to traverse between: (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), and (2, 3). A valid sequence of traversals exists for each pair, so we return true.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105\n\n"}, {"role": "assistant", "content": "class PrimeTable:\n    def __init__(self, n:int) -> None:\n        self.n = n\n        self.primes = []\n        self.max_div = list(range(n+1))\n        self.max_div[1] = 1\n        self.phi = list(range(n+1))\n\n        for i in range(2, n + 1):\n            if self.max_div[i] == i:\n                self.primes.append(i)\n                for j in range(i, n+1, i):\n                    self.max_div[j] = i\n                    self.phi[j] = self.phi[j] // i * (i-1)\n\n    def is_prime(self, x:int):\n        if x < 2: return False\n        if x <= self.n: return self.max_div[x] == x\n        for p in self.primes:\n            if p * p > x: break\n            if x % i == 0: return False\n        return True\n\n    def prime_factorization(self, x:int):\n        if x > self.n:\n            for p in self.primes:\n                if p * p > x: break\n                if x <= self.n: break\n                if x % p == 0:\n                    cnt = 0\n                    while x % p == 0: cnt += 1; x //= p\n                    yield p, cnt\n        while (1 < x and x <= self.n):\n            p, cnt = self.max_div[x], 0\n            while x % p == 0: cnt += 1; x //= p\n            yield p, cnt\n        if x >= self.n and x > 1:\n            yield x, 1\n\n    def get_factors(self, x:int):\n        factors = [1]\n        for p, b in self.prime_factorization(x):\n            n = len(factors)\n            for j in range(1, b+1):\n                for d in factors[:n]:\n                    factors.append(d * (p ** j))\n        return factors\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n\n    def find(self, a):\n        a = self.parent[a]\n        acopy = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while acopy != a:\n            self.parent[acopy], acopy = a, self.parent[acopy]\n        return a\n\n    def merge(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb: return False\n        self.parent[pb] = pa\n        return True\n\npt = PrimeTable(10 ** 5 + 1)\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        primes = set()\n        for num in nums:\n            for p, c in pt.prime_factorization(num):\n                primes.add(p)\n        primes = sorted(primes)\n        union = UnionFind(len(nums) + len(primes))\n        for i, v in enumerate(nums):\n            for p, c in pt.prime_factorization(v):\n                j = len(nums) + bisect.bisect_left(primes, p)\n                union.merge(i, j)\n        return len({union.find(i) for i in range(len(nums))}) == 1"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_500", "label": "code_high", "messages": [{"role": "user", "content": "Can you implement a function in Python 3 that\n\nYou are given a string expression representing a Lisp-like expression to return the integer value of.\nThe syntax for these expressions is given as follows.\n\nAn expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer.\n(An integer could be positive or negative.)\nA let expression takes the form \"(let v1 e1 v2 e2 ... vn en expr)\", where let is always the string \"let\", then there are one or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let expression is the value of the expression expr.\nAn add expression takes the form \"(add e1 e2)\" where add is always the string \"add\", there are always two expressions e1, e2 and the result is the addition of the evaluation of e1 and the evaluation of e2.\nA mult expression takes the form \"(mult e1 e2)\" where mult is always the string \"mult\", there are always two expressions e1, e2 and the result is the multiplication of the evaluation of e1 and the evaluation of e2.\nFor this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names \"add\", \"let\", and \"mult\" are protected and will never be used as variable names.\nFinally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope.\n\n\u00a0\nExample 1:\nInput: expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"\nOutput: 14\nExplanation: In the expression (add x y), when checking for the value of the variable x,\nwe check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\nSince x = 3 is found first, the value of x is 3.\n\nExample 2:\nInput: expression = \"(let x 3 x 2 x)\"\nOutput: 2\nExplanation: Assignment in let statements is processed sequentially.\n\nExample 3:\nInput: expression = \"(let x 1 y 2 x (add x y) (add x y))\"\nOutput: 5\nExplanation: The first (add x y) evaluates as 3, and is assigned to x.\nThe second (add x y) evaluates as 3+2 = 5.\n\n\u00a0\nConstraints:\n\n1 <= expression.length <= 2000\nThere are no leading or trailing spaces in expression.\nAll tokens are separated by a single space in expression.\nThe answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.\nThe expression is guaranteed to be legal and evaluate to an integer.\n\n"}, {"role": "assistant", "content": "from collections import ChainMap\n\ndef find(s, i):\n    while s[i] == \" \":\n        i += 1\n    start = i\n    if s[i]==\"(\":\n        i += 1\n        left = 1\n        while i < len(s):\n            if s[i] == \"(\":\n                left += 1\n            elif s[i] == \")\":\n                left -= 1\n                if left == 0:\n                    return s[start:i+1], i+1\n            i += 1\n    else:\n        while i < len(s) and s[i] != \" \":\n            i += 1\n        return s[start:i], i\n    \nclass Solution:\n    def evaluate(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: int\n        \"\"\"\n        \n        m = ChainMap()\n        \n        def calc(exp, m):\n            exp = exp.strip()\n            if exp.startswith(\"(let\"):\n                exp = exp[1:-1]\n                pos = 3\n                map = {}\n                m.maps.insert(0, map)\n                arr = []\n                while pos < len(exp)-1:\n                    s, pos = find(exp, pos)\n                    arr.append(s)\n                for i in range(0, len(arr), 2):\n                    if i == len(arr) - 1:\n                        ret = calc(arr[i], m) \n                    else:\n                        map[arr[i]] = calc(arr[i+1], m)\n                m.maps.pop(0)\n                return ret\n            elif exp.startswith(\"(add\"):\n                exp = exp[1:-1]\n                exp1, pos = find(exp, 4)\n                exp2, pos = find(exp, pos)\n                x = calc(exp1, m)\n                y = calc(exp2, m)\n                return x+y\n            elif exp.startswith(\"(mult\"):\n                exp = exp[1:-1]\n                exp1, pos = find(exp, 5)\n                exp2, pos = find(exp, pos)\n                x = calc(exp1, m)\n                y = calc(exp2, m)\n                return x*y\n            elif exp[0].islower():\n                return m[exp]\n            else:\n                return int(exp)\n        return calc(expression, m)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_526", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 2 function for\n\nYou are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.\nWe will remove exactly one node from initial, completely removing it and any connections from this node to any other node.\nReturn the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\n\u00a0\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\nExample 2:\nInput: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]\nOutput: 1\nExample 3:\nInput: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]\nOutput: 1\n\n\u00a0\nConstraints:\n\nn == graph.length\nn == graph[i].length\n2 <= n <= 300\ngraph[i][j] is 0 or 1.\ngraph[i][j] == graph[j][i]\ngraph[i][i] == 1\n1 <= initial.length <\u00a0n\n0 <= initial[i] <= n - 1\nAll the integers in initial are unique.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n  def minMalwareSpread(self, graph, initial):\n    def fill_with_removed_node(edges,removed,sources):\n      filled = [False]*len(edges)\n      q = sources\n      new_q = []\n      for source in sources:\n        if source!=removed:\n          new_q.append(source)\n          filled[source] = True\n      q = new_q\n      while len(q)>0:\n        node = q.pop()\n        filled[node] = True\n        for neighbor in edges[node]:\n          if not filled[neighbor] and neighbor!=removed:\n            q.append(neighbor)\n      return sum(filled)\n    initial = sorted(initial)\n    comps = []\n    labels = [-1]*len(graph)\n    cur = 0\n    edges = [[] for i in range(len(graph))]\n    for i in range(len(graph)):\n      for j in range(i):\n        if graph[i][j]==1:\n          edges[i].append(j)\n          edges[j].append(i)\n    for i in range(len(graph)):\n      if labels[i]==-1:\n        q = [i]\n        while len(q)>0:\n          node = q.pop()\n          labels[node] = cur\n          for neighbor in edges[node]:\n            if labels[neighbor]==-1:\n              q.append(neighbor)\n        cur+=1\n    label_lookup = [[] for i in range(cur)]\n    for i,label in enumerate(labels):\n      label_lookup[label].append(i)\n    labels_of_initial = [[] for i in range(cur)]\n    for node in initial:\n      labels_of_initial[labels[node]].append(node)\n    best = initial[0]\n    best_size = 0\n    for i,label in enumerate(labels_of_initial):\n      if len(label)==1:\n        n = len(label_lookup[i])\n        if n>best_size or (n==best_size and label[0]<best):\n          best_size = n\n          best = label[0]\n      elif len(label)>1:\n        for candidate in label:\n          n = len(label_lookup[i])-fill_with_removed_node(edges,candidate,label)\n          if n>best_size or (n==best_size and candidate<best):\n            best_size = n\n            best = candidate\n    return best"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_572", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 script for\n\nAn n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a '/', '\\', or blank space ' '. These characters divide the square into contiguous regions.\nGiven the grid grid represented as a string array, return the number of regions.\nNote that backslash characters are escaped, so a '\\' is represented as '\\\\'.\n\u00a0\nExample 1:\n\nInput: grid = [\" /\",\"/ \"]\nOutput: 2\n\nExample 2:\n\nInput: grid = [\" /\",\"  \"]\nOutput: 1\n\nExample 3:\n\nInput: grid = [\"/\\\\\",\"\\\\/\"]\nOutput: 5\nExplanation: Recall that because \\ characters are escaped, \"\\\\/\" refers to \\/, and \"/\\\\\" refers to /\\.\n\n\u00a0\nConstraints:\n\nn == grid.length == grid[i].length\n1 <= n <= 30\ngrid[i][j] is either '/', '\\', or ' '.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def regionsBySlashes(self, grid):\n        \"\"\"\n        :type grid: List[str]\n        :rtype: int\n        \"\"\"\n        from collections import deque\n        \n        self.M,self.N=len(grid),len(grid[0])\n        def flood(start):\n            \n            Q=deque()\n            Q.append(start)\n            \n            while(Q):\n                node=Q.popleft()\n                if(node in Wall or node in See):\n                    continue\n                if node[0]<=0 or node[0]>=self.M or node[1]<=0 or node[1]>=self.N:\n                    continue\n                \n                See.add(node)\n                for dx,dy in [(0,0.25),(0,-0.25),(0.25,0),(-0.25,0)]:\n                    Q.append((node[0]+dx,node[1]+dy))\n                #print(node)\n        \n        Wall=set()\n        for row in range(0,len(grid)):\n            for col in range(0,len(grid[0])):\n                if grid[row][col]=='\\\\':\n                    Wall.add((row,   col))\n                    Wall.add((row+0.25,col+0.25))\n                    Wall.add((row+0.5, col+0.5))\n                    Wall.add((row+0.75,col+0.75))\n                    Wall.add((row+1,   col+1))\n                elif grid[row][col]=='/':\n                    Wall.add((row,     col+1))\n                    Wall.add((row+0.25,col+0.75))\n                    Wall.add((row+0.5, col+0.5))\n                    Wall.add((row+0.75,col+0.25))\n                    Wall.add((row+1,   col))\n        \n        See=set()\n        Part=0\n        \n        for row in range(0,len(grid)):\n            for col in range(0,len(grid[0])):\n                for dx in [0.25,0.5,0.75]:\n                    for dy in [0.25,0.5,0.75]:\n                        start=(row+dx,col+dy)\n                        if (start in See) or (start in Wall):\n                            continue\n                        else:\n                            #print(start)\n                            #print(See)\n                            Part+=1\n                            #print(\"Part:\",Part)\n                            flood(start)\n        \n        #print(Wall)\n        return Part\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_634", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 2 to\n\nYou are given a positive integer 0-indexed\u00a0array nums.\nA subset of the array nums is square-free if the product of its elements is a square-free integer.\nA square-free integer is an integer that is divisible by no square number other than 1.\nReturn the number of square-free non-empty subsets of the array nums. Since the answer may be too large, return it modulo 10^9 + 7.\nA non-empty\u00a0subset of nums is an array that can be obtained by deleting some (possibly none but not all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.\n\u00a0\nExample 1:\nInput: nums = [3,4,4,5]\nOutput: 3\nExplanation: There are 3 square-free subsets in this example:\n- The subset consisting of the 0th element [3]. The product of its elements is 3, which is a square-free integer.\n- The subset consisting of the 3rd element [5]. The product of its elements is 5, which is a square-free integer.\n- The subset consisting of 0th and 3rd elements [3,5]. The product of its elements is 15, which is a square-free integer.\nIt can be proven that there are no more than 3 square-free subsets in the given array.\nExample 2:\nInput: nums = [1]\nOutput: 1\nExplanation: There is 1 square-free subset in this example:\n- The subset consisting of the 0th element [1]. The product of its elements is 1, which is a square-free integer.\nIt can be proven that there is no more than 1 square-free subset in the given array.\n\n\u00a0\nConstraints:\n\n1 <= nums.length\u00a0<= 1000\n1 <= nums[i] <= 30\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def squareFreeSubsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def _factor(v):\n            r = []\n            for p in xrange(2, v):\n                if p*p > v:\n                    break\n                c = 0\n                while v % p == 0:\n                    v //= p\n                    c += 1\n                if c:\n                    r.append((p, c))\n            if v > 1:\n                r.append((v, 1))\n            return r\n\n        a = []\n        m = 0\n        d = {}\n        for v in nums:\n            f = _factor(v)\n            if any(e>=2 for _, e in f):\n                continue\n            x = 0\n            for p, _ in f:\n                if p not in d:\n                    d[p] = m\n                    m += 1\n                x |= (1<<d[p])\n            a.append(x)\n\n        f = [0] * (1<<m)\n        f[0] = 1\n        mod = 10**9 + 7\n        for i in a:\n            for j in xrange(1<<m):\n                if (i & j) == 0:\n                    f[i^j] = (f[j] + f[i^j]) % mod\n        return (sum(f) - 1) % mod"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_696", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 3 to\n\nA farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren.\nA pyramidal plot of land can be defined as a set of cells with the following criteria:\n\nThe number of cells in the set has to be greater than 1 and all cells must be fertile.\nThe apex of a pyramid is the topmost cell of the pyramid. The height of a pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r).\n\nAn inverse pyramidal plot of land can be defined as a set of cells with similar criteria:\n\nThe number of cells in the set has to be greater than 1 and all cells must be fertile.\nThe apex of an inverse pyramid is the bottommost cell of the inverse pyramid. The height of an inverse pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i).\n\nSome examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.\n\nGiven a 0-indexed m x n binary matrix grid representing the farmland, return the total number of pyramidal and inverse pyramidal plots that can be found in grid.\n\u00a0\nExample 1:\n\nInput: grid = [[0,1,1,0],[1,1,1,1]]\nOutput: 2\nExplanation: The 2 possible pyramidal plots are shown in blue and red respectively.\nThere are no inverse pyramidal plots in this grid. \nHence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.\n\nExample 2:\n\nInput: grid = [[1,1,1],[1,1,1]]\nOutput: 2\nExplanation: The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. \nHence the total number of plots is 1 + 1 = 2.\n\nExample 3:\n\nInput: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]\nOutput: 13\nExplanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.\nThere are 6 inverse pyramidal plots, 2 of which are shown in the last figure.\nThe total number of plots is 7 + 6 = 13.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 100000\ngrid[i][j] is either 0 or 1.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def countPyramids(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        \n        pre_sum = []\n        for line in grid :\n            lt = [0]\n            for t in line :\n                lt.append(lt[-1]+t)\n            pre_sum.append(lt)\n            \n        to_ret = 0\n        for i in range(m) :\n            for j in range(n) :\n                if not grid[i][j] == 1 :\n                    continue\n                for h1 in range(1, 99999) :\n                    if i+h1 >= m or j+h1 >= n or j-h1 < 0:\n                        break\n                    if not pre_sum[i+h1][j+h1+1] - pre_sum[i+h1][j-h1] == 2*h1+1:\n                        break\n                    to_ret += 1\n                for h1 in range(1, 99999) :\n                    if i-h1 < 0 or j+h1 >= n or j-h1 < 0:\n                        break\n                    if not pre_sum[i-h1][j+h1+1] - pre_sum[i-h1][j-h1] == 2*h1+1:\n                        break\n                    to_ret += 1\n        return to_ret\n                    \n            "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_698", "label": "code_high", "messages": [{"role": "user", "content": "Can you write a program in Python 2 where\n\nA farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren.\nA pyramidal plot of land can be defined as a set of cells with the following criteria:\n\nThe number of cells in the set has to be greater than 1 and all cells must be fertile.\nThe apex of a pyramid is the topmost cell of the pyramid. The height of a pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r).\n\nAn inverse pyramidal plot of land can be defined as a set of cells with similar criteria:\n\nThe number of cells in the set has to be greater than 1 and all cells must be fertile.\nThe apex of an inverse pyramid is the bottommost cell of the inverse pyramid. The height of an inverse pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i).\n\nSome examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.\n\nGiven a 0-indexed m x n binary matrix grid representing the farmland, return the total number of pyramidal and inverse pyramidal plots that can be found in grid.\n\u00a0\nExample 1:\n\nInput: grid = [[0,1,1,0],[1,1,1,1]]\nOutput: 2\nExplanation: The 2 possible pyramidal plots are shown in blue and red respectively.\nThere are no inverse pyramidal plots in this grid. \nHence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.\n\nExample 2:\n\nInput: grid = [[1,1,1],[1,1,1]]\nOutput: 2\nExplanation: The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. \nHence the total number of plots is 1 + 1 = 2.\n\nExample 3:\n\nInput: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]\nOutput: 13\nExplanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.\nThere are 6 inverse pyramidal plots, 2 of which are shown in the last figure.\nThe total number of plots is 7 + 6 = 13.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 100000\ngrid[i][j] is either 0 or 1.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def countPyramids(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        \n        m = len(grid)\n        n = len(grid[0])\n        go_left = [[0 for c in range(n)] for r in range(m)]\n        go_right = [[0 for c in range(n)] for r in range(m)]\n        \n        for r in range(m):\n            go_left[r][0] = grid[r][0]\n            for c in range(1, n):\n                go_left[r][c] = (0 if grid[r][c] == 0 else go_left[r][c - 1] + 1)\n            go_right[r][n - 1] = grid[r][n - 1]\n            for c in range(n - 2, -1, -1):\n                go_right[r][c] = (0 if grid[r][c] == 0 else go_right[r][c + 1] + 1)\n        \n        \n        for c in range(n):\n            nr = 0\n            for r in range(m):\n                while nr < m and min(go_left[nr][c], go_right[nr][c]) >= nr - r + 1:\n                    nr += 1\n                if nr - r >= 2:\n                    ans += (nr - r - 1)\n            nr = m - 1\n            for r in range(m - 1, -1, -1):\n                while nr >= 0 and min(go_left[nr][c], go_right[nr][c]) >= r - nr + 1:\n                    nr -= 1\n                if r - nr >= 2:\n                    ans += (r - nr - 1)\n        \n        return ans\n            \n            \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_709", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 2 program that\n\nYou are given a 2D integer array grid of size m x n, where each cell contains a positive integer.\nA cornered path is defined as a set of adjacent cells with at most one turn. More specifically, the path should exclusively move either horizontally or vertically up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the alternate direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.\nThe product of a path is defined as the product of all the values in the path.\nReturn the maximum number of trailing zeros in the product of a cornered path found in grid.\nNote:\n\nHorizontal movement means moving in either the left or right direction.\nVertical movement means moving in either the up or down direction.\n\n\u00a0\nExample 1:\n\nInput: grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\nOutput: 3\nExplanation: The grid on the left shows a valid cornered path.\nIt has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\n\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell.\n\nExample 2:\n\nInput: grid = [[4,3,2],[7,6,1],[8,8,8]]\nOutput: 0\nExplanation: The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100000\n1 <= m * n <= 100000\n1 <= grid[i][j] <= 1000\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def maxTrailingZeros(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        t, u, d, r = [[[0, 0] for _ in grid[0]] for _ in grid], [[[0, 0] for _ in grid[0]] for _ in grid], [[[0, 0] for _ in grid[0]] for _ in grid], 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                while not grid[i][j] % 2:\n                    grid[i][j], t[i][j][0] = grid[i][j] / 2, t[i][j][0] + 1\n                while not grid[i][j] % 5:\n                    grid[i][j], t[i][j][1] = grid[i][j] / 5, t[i][j][1] + 1\n        for j in range(len(grid[0])):\n            v, f, w, g = 0, 0, 0, 0\n            for i in range(0, len(grid)):\n                v, f, d[i][j][0], d[i][j][1], r = v + t[i][j][0], f + t[i][j][1], v + t[i][j][0], f + t[i][j][1], max(r, min(v + t[i][j][0], f + t[i][j][1]))\n            for i in range(len(grid) - 1, -1, -1):\n                w, g, u[i][j][0], u[i][j][1], r = w + t[i][j][0], g + t[i][j][1], w + t[i][j][0], g + t[i][j][1], max(r, min(w + t[i][j][0], g + t[i][j][1]))\n        for i in range(len(grid)):\n            v, f, w, g = 0, 0, 0, 0\n            for j in range(len(grid[0]) - 1):\n                v, f, r = v + t[i][j][0], f + t[i][j][1], max(r, min(v + t[i][j][0] + u[i][j + 1][0], f + t[i][j][1] + u[i][j + 1][1]), min(v + t[i][j][0] + d[i][j + 1][0], f + t[i][j][1] + d[i][j + 1][1]))\n            for j in range(len(grid[0]) - 1, 0, -1):\n                w, g, r = w + t[i][j][0], g + t[i][j][1], max(r, min(w + t[i][j][0] + u[i][j - 1][0], g + t[i][j][1] + u[i][j - 1][1]), min(w + t[i][j][0] + d[i][j - 1][0], g + t[i][j][1] + d[i][j - 1][1]))\n        return r"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_710", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 3 function for\n\nYou are given a 2D integer array grid of size m x n, where each cell contains a positive integer.\nA cornered path is defined as a set of adjacent cells with at most one turn. More specifically, the path should exclusively move either horizontally or vertically up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the alternate direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.\nThe product of a path is defined as the product of all the values in the path.\nReturn the maximum number of trailing zeros in the product of a cornered path found in grid.\nNote:\n\nHorizontal movement means moving in either the left or right direction.\nVertical movement means moving in either the up or down direction.\n\n\u00a0\nExample 1:\n\nInput: grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\nOutput: 3\nExplanation: The grid on the left shows a valid cornered path.\nIt has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\n\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell.\n\nExample 2:\n\nInput: grid = [[4,3,2],[7,6,1],[8,8,8]]\nOutput: 0\nExplanation: The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100000\n1 <= m * n <= 100000\n1 <= grid[i][j] <= 1000\n\n"}, {"role": "assistant", "content": "class Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        def get_25(v) :\n            to_ret = [0, 0]\n            while v % 2 == 0 :\n                v = v // 2\n                to_ret[0] += 1\n            while v % 5 == 0 :\n                v = v // 5\n                to_ret[1] += 1\n            return to_ret\n        \n        m, n = len(grid), len(grid[0])\n        pre_sum1 = [[[0, 0] for a in range(n+1)] for b in range(m+1)] # \u5411\u4e0a\n        pre_sum2 = [[[0, 0] for a in range(n+1)] for b in range(m+1)] # \u5411\u5de6\n        \n        for i in range(m) :\n            for j in range(n) :\n                gs = get_25(grid[i][j])\n                pre_sum1[i+1][j+1][0] = pre_sum1[i][j+1][0] + gs[0]\n                pre_sum1[i+1][j+1][1] = pre_sum1[i][j+1][1] + gs[1]\n                pre_sum2[i+1][j+1][0] = pre_sum2[i+1][j][0] + gs[0]\n                pre_sum2[i+1][j+1][1] = pre_sum2[i+1][j][1] + gs[1]\n        \n        to_ret = 0\n        for i in range(m) :\n            for j in range(n) :\n                \n                a, b = pre_sum1[i+1][j+1]\n                r1 = min(a+pre_sum2[i+1][j][0], b+pre_sum2[i+1][j][1])\n                to_ret = max(to_ret, r1)\n                r2 = min(a+pre_sum2[i+1][-1][0]-pre_sum2[i+1][j+1][0], b+pre_sum2[i+1][-1][1]-pre_sum2[i+1][j+1][1])\n                to_ret = max(to_ret, r2)\n                a = pre_sum1[-1][j+1][0] - pre_sum1[i][j+1][0]\n                b = pre_sum1[-1][j+1][1] - pre_sum1[i][j+1][1]\n                r3 = min(a+pre_sum2[i+1][j][0], b+pre_sum2[i+1][j][1])\n                to_ret = max(to_ret, r3)\n                r4 = min(a+pre_sum2[i+1][-1][0]-pre_sum2[i+1][j+1][0], b+pre_sum2[i+1][-1][1]-pre_sum2[i+1][j+1][1])\n                to_ret = max(to_ret, r4)\n        return to_ret\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_770", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 2 program that\n\nA game is played by a cat and a mouse named Cat and Mouse.\nThe environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food.\n\nPlayers are represented by the characters 'C'(Cat),'M'(Mouse).\nFloors are represented by the character '.' and can be walked on.\nWalls are represented by the character '#' and cannot be walked on.\nFood is represented by the character 'F' and can be walked on.\nThere is only one of each character 'C', 'M', and 'F' in grid.\n\nMouse and Cat play according to the following rules:\n\nMouse moves first, then they take turns to move.\nDuring each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the grid.\ncatJump, mouseJump are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\nStaying in the same position is allowed.\nMouse can jump over Cat.\n\nThe game can end in 4 ways:\n\nIf Cat occupies the same position as Mouse, Cat wins.\nIf Cat reaches the food first, Cat wins.\nIf Mouse reaches the food first, Mouse wins.\nIf Mouse cannot get to the food within 1000 turns, Cat wins.\n\nGiven a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false.\n\u00a0\nExample 1:\n\nInput: grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2\nOutput: true\nExplanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n\nExample 2:\n\nInput: grid = [\"M.C...F\"], catJump = 1, mouseJump = 4\nOutput: true\n\nExample 3:\nInput: grid = [\"M.C...F\"], catJump = 1, mouseJump = 3\nOutput: false\n\n\u00a0\nConstraints:\n\nrows == grid.length\ncols = grid[i].length\n1 <= rows, cols <= 8\ngrid[i][j] consist only of characters 'C', 'M', 'F', '.', and '#'.\nThere is only one of each character 'C', 'M', and 'F' in grid.\n1 <= catJump, mouseJump <= 8\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def canMouseWin(self, grid, catJump, mouseJump):\n        \"\"\"\n        :type grid: List[str]\n        :type catJump: int\n        :type mouseJump: int\n        :rtype: bool\n        \"\"\"\n        # if there is winning solution, it's length is probably very short (<100)\n        a = grid\n        n, m = len(a), len(a[0])\n        mpos = cpos = fpos = -1\n        for i in xrange(n):\n            for j in xrange(m):\n                if a[i][j] == 'M': mpos = i*m + j\n                elif a[i][j] == 'C': cpos = i*m + j\n                elif a[i][j] == 'F': fpos = i*m + j\n        def traj(i, j, d):\n            if grid[i][j] == '#': return []\n            pos = i*m+j\n            nei = [pos]\n            for k in xrange(1, d+1):\n                if i+k>=n or grid[i+k][j]=='#': break\n                nei.append(pos+k*m)\n            for k in xrange(1, d+1):\n                if i-k<0 or grid[i-k][j]=='#': break\n                nei.append(pos-k*m)\n            for k in xrange(1, d+1):\n                if j+k>=m or grid[i][j+k]=='#': break\n                nei.append(pos+k)\n            for k in xrange(1, d+1):\n                if j-k<0 or grid[i][j-k]=='#': break\n                nei.append(pos-k)\n            return nei\n        mnei = [traj(i, j, mouseJump) for i in xrange(n) for j in xrange(m)]\n        cnei = [traj(i, j, catJump) for i in xrange(n) for j in xrange(m)]\n        k = n * m\n        lim = 100\n        cache = [[-1]*(k*k) for _ in xrange(lim)]\n        def mouse_win(mpos, cpos, turn):\n            if turn == lim: return 0\n            e = mpos*k+cpos\n            if cache[turn][e] >= 0:\n                return cache[turn][e] == 1\n            if cpos == fpos or cpos == mpos: return 0\n            if mpos == fpos: return 1\n            if turn & 1: # cat turn\n                if all(mouse_win(mpos, newcpos, turn+1) for newcpos in cnei[cpos]):\n                    cache[turn][e] = 1\n                else:\n                    cache[turn][e] = 0\n            else: # mouse turn\n                if any(mouse_win(newmpos, cpos, turn+1) for newmpos in mnei[mpos]):\n                    cache[turn][e] = 1\n                else:\n                    cache[turn][e] = 0\n            return cache[turn][e] == 1\n        return mouse_win(mpos, cpos, 0)\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_772", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 3 to\n\nA game is played by a cat and a mouse named Cat and Mouse.\nThe environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food.\n\nPlayers are represented by the characters 'C'(Cat),'M'(Mouse).\nFloors are represented by the character '.' and can be walked on.\nWalls are represented by the character '#' and cannot be walked on.\nFood is represented by the character 'F' and can be walked on.\nThere is only one of each character 'C', 'M', and 'F' in grid.\n\nMouse and Cat play according to the following rules:\n\nMouse moves first, then they take turns to move.\nDuring each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the grid.\ncatJump, mouseJump are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\nStaying in the same position is allowed.\nMouse can jump over Cat.\n\nThe game can end in 4 ways:\n\nIf Cat occupies the same position as Mouse, Cat wins.\nIf Cat reaches the food first, Cat wins.\nIf Mouse reaches the food first, Mouse wins.\nIf Mouse cannot get to the food within 1000 turns, Cat wins.\n\nGiven a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false.\n\u00a0\nExample 1:\n\nInput: grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2\nOutput: true\nExplanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n\nExample 2:\n\nInput: grid = [\"M.C...F\"], catJump = 1, mouseJump = 4\nOutput: true\n\nExample 3:\nInput: grid = [\"M.C...F\"], catJump = 1, mouseJump = 3\nOutput: false\n\n\u00a0\nConstraints:\n\nrows == grid.length\ncols = grid[i].length\n1 <= rows, cols <= 8\ngrid[i][j] consist only of characters 'C', 'M', 'F', '.', and '#'.\nThere is only one of each character 'C', 'M', and 'F' in grid.\n1 <= catJump, mouseJump <= 8\n\n"}, {"role": "assistant", "content": "class Solution:\n    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:\n        row, column = len(grid), len(grid[0])\n        \n        for i in range(row):\n            for j in range(column):\n                if grid[i][j] == \"C\":\n                    cx, cy = i, j\n                elif grid[i][j] == \"M\":\n                    mx, my = i, j\n                elif grid[i][j] == \"F\":\n                    fx, fy = i, j\n        \n        from functools import lru_cache\n        \n        @lru_cache(None)\n        def dfs(cat, rat, move):\n            # true if mouse wins else false\n            if cat == rat or cat == (fx, fy) or move>=2*row*column:\n                return False\n            if rat == (fx, fy): \n                return True\n            \n            if move & 1: # cat\n                x, y = cat\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    for j in range(catJump+1):\n                        xx, yy = x+dx*j, y+dy*j\n                        if xx<0 or xx >= row or yy<0 or yy>=column or grid[xx][yy]==\"#\":\n                            break\n                        if not dfs((xx, yy), rat, move+1):\n                            return False\n                return True\n            else: # mouse\n                x, y = rat\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    for j in range(mouseJump+1):\n                        xx, yy = x+dx*j, y+dy*j\n                        if xx<0 or xx >= row or yy<0 or yy>=column or grid[xx][yy]==\"#\":\n                            break\n                        if dfs(cat, (xx, yy), move+1):\n                            return True\n                return False\n        \n        return dfs((cx, cy), (mx, my), 0)\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_870", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 3 to\n\nYou have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry.\nYou are given an array boxes, where boxes[i] = [ports\u200b\u200bi\u200b, weighti], and three integers portsCount, maxBoxes, and maxWeight.\n\nports\u200b\u200bi is the port where you need to deliver the ith box and weightsi is the weight of the ith box.\nportsCount is the number of ports.\nmaxBoxes and maxWeight are the respective box and weight limits of the ship.\n\nThe boxes need to be delivered in the order they are given. The ship will follow these steps:\n\nThe ship will take some number of boxes from the boxes queue, not violating the maxBoxes and maxWeight constraints.\nFor each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.\nThe ship then makes a return trip to storage to take more boxes from the queue.\n\nThe ship must end at storage after all the boxes have been delivered.\nReturn the minimum number of trips the ship needs to make to deliver all boxes to their respective ports.\n\u00a0\nExample 1:\nInput: boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3\nOutput: 4\nExplanation: The optimal strategy is as follows: \n- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.\nSo the total number of trips is 4.\nNote that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).\n\nExample 2:\nInput: boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6\nOutput: 6\nExplanation: The optimal strategy is as follows: \n- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.\n- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n\nExample 3:\nInput: boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7\nOutput: 6\nExplanation: The optimal strategy is as follows:\n- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.\n- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n\n\u00a0\nConstraints:\n\n1 <= boxes.length <= 100000\n1 <= portsCount, maxBoxes, maxWeight <= 100000\n1 <= ports\u200b\u200bi <= portsCount\n1 <= weightsi <= maxWeight\n\n"}, {"role": "assistant", "content": "class Solution:\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n        n = len(boxes)\n        if n == 1:\n            return 2\n        dp = [100000000] * (n + 1)\n        dp[0] = 0\n        g = [0] * (n + 1)\n        g[1] = 1\n        for i in range(1, n):\n            if boxes[i][0] == boxes[i - 1][0]:\n                g[i + 1] = g[i]\n            else:\n                g[i + 1] = g[i] + 1\n        s = [0] * (n + 1)\n        s[0] = 0\n        for i in range(n):\n            s[i + 1] = s[i] + boxes[i][1]\n        l = [0] * (n + 1)\n        r = [0] * (n + 1)\n        l[1] = 1\n        for i in range(1, n):\n            if boxes[i][0] == boxes[i - 1][0]:\n                l[i + 1] = l[i]\n            else:\n                l[i + 1] = i + 1\n        r[n] = n\n        for i in range(n - 2, -1, -1):\n            if boxes[i][0] == boxes[i + 1][0]:\n                r[i + 1] = r[i + 2]\n            else:\n                r[i + 1] = i + 1\n        for i in range(1, n + 1):\n            left = 0\n            right = i - 1\n            ans = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if s[i] - s[mid] <= maxWeight:\n                    ans = mid;\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            ans = max(i - maxBoxes, ans)\n            tmp_x = g[i] - g[ans] + 1\n            if ans != 0 and boxes[ans - 1][0] == boxes[ans][0]:\n                tmp_x += 1\n            dp[i] = dp[ans] + tmp_x\n            if ans != 0:\n                tmp_y = r[ans]\n                dp[i] = min(dp[i], dp[tmp_y] + g[i] - g[tmp_y] + 1)\n        return dp[n]\n        \n        \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_885", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 2 that\n\nGiven 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.\n\u00a0\nExample 1:\nInput: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1\n\nExample 2:\nInput: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667\n\nExample 3:\nInput: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6\n\n\u00a0\nConstraints:\n\n1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def comb(self, n, k):\n        ans = 1\n        for i in range(k):\n            ans *= (n - i)\n            ans //= i + 1\n        return ans\n    def getProbability(self, balls):\n        \"\"\"\n        :type balls: List[int]\n        :rtype: float\n        \"\"\"\n        dp = [[[0 for _ in range(50)] for _ in range(10)] for _ in range(10)]\n        n = len(balls)\n        dp[0][0][0] = 1\n        for idx in range(n):\n            curr = balls[idx]\n            new_dp = [[[0 for _ in range(50)] for _ in range(10)] for _ in range(10)]\n            for j in range(10):\n                for k in range(10):\n                    for s in range(0, curr + 1):\n                        jp = j if s == 0 else j - 1\n                        kp = k if s == curr else k - 1\n                        if jp >= 0 and kp >= 0:\n                            for curr_cnt in range(50):\n                                prev_cnt = curr_cnt - s\n                                if prev_cnt >= 0:\n                                    new_dp[j][k][curr_cnt] += dp[jp][kp][prev_cnt] * self.comb(curr, s)\n                                    if new_dp[j][k][curr_cnt] and False:\n                                        print((jp,kp,prev_cnt))\n                                        print((j,k,curr_cnt))\n                                        print(new_dp[j][k][curr_cnt])\n            dp = new_dp\n            #print(dp)\n        target = sum(balls) // 2\n        tot = 0\n        for j in range(10):\n            for k in range(10):\n                tot += dp[j][k][target]\n        now = 0\n        \n        for j in range(10):\n            now += dp[j][j][target]\n        return float(now) / float(tot)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_922", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 program that can\n\nA storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.\nThe game is represented by an m x n grid of characters grid where each element is a wall, floor, or box.\nYour task is to move the box 'B' to the target position 'T' under the following rules:\n\nThe character 'S' represents the player. The player can move up, down, left, right in grid if it is a floor (empty cell).\nThe character '.' represents the floor which means a free cell to walk.\nThe character '#' represents the wall which means an obstacle (impossible to walk there).\nThere is only one box 'B' and one target cell 'T' in the grid.\nThe box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.\nThe player cannot walk through the box.\n\nReturn the minimum number of pushes to move the box to the target. If there is no way to reach the target, return -1.\n\u00a0\nExample 1:\n\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n               [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: 3\nExplanation: We return only the number of times the box is pushed.\nExample 2:\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: -1\n\nExample 3:\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\n               [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: 5\nExplanation: push the box down, left, left, up and up.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 20\ngrid contains only characters '.', '#', 'S', 'T', or 'B'.\nThere is only one character 'S', 'B', and 'T' in the grid.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def minPushBox(self, A):\n        R, C = len(A), len(A[0])\n        for r, row in enumerate(A):\n            for c, v in enumerate(row):\n                if v == 'S':\n                    sr, sc = r, c\n                if v == 'T':\n                    tr, tc = r, c\n                if v == 'B':\n                    br, bc = r, c\n        \n        def neighbors(sr, sc, br, bc):\n            for nr, nc, dr, dc in ((sr+1, sc, 1, 0), (sr, sc+1, 0,1), (sr-1, sc, -1, 0), (sr, sc-1, 0, -1)):\n                if 0 <= nr < R and 0 <= nc < C and A[nr][nc] != '#':\n                    if (nr != br or nc != bc):\n                        yield 0, nr, nc, br, bc\n                    else:  # trying to push box\n                        zr = br + dr\n                        zc = bc + dc\n                        if 0 <= zr < R and 0 <= zc < C and A[zr][zc] != '#':\n                            yield 1, nr, nc, zr, zc\n        \n        pq = [(0, sr, sc, br, bc)]\n        dist = {(sr, sc, br, bc): 0}\n        INF = float('inf')\n        while pq:\n            d, sr, sc, br, bc = heapq.heappop(pq)\n            if br==tr and bc==tc: return d\n            if dist.get((sr, sc, br, bc), INF) < d: continue\n            for nei in neighbors(sr, sc, br, bc):\n                node = nei[1:]\n                w = nei[0]\n                if d + w < dist.get(node, INF):\n                    dist[node] = d + w\n                    heapq.heappush(pq, (d+w, ) + node)\n                        \n        return -1"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_923", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 3 to\n\nA storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.\nThe game is represented by an m x n grid of characters grid where each element is a wall, floor, or box.\nYour task is to move the box 'B' to the target position 'T' under the following rules:\n\nThe character 'S' represents the player. The player can move up, down, left, right in grid if it is a floor (empty cell).\nThe character '.' represents the floor which means a free cell to walk.\nThe character '#' represents the wall which means an obstacle (impossible to walk there).\nThere is only one box 'B' and one target cell 'T' in the grid.\nThe box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.\nThe player cannot walk through the box.\n\nReturn the minimum number of pushes to move the box to the target. If there is no way to reach the target, return -1.\n\u00a0\nExample 1:\n\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n               [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: 3\nExplanation: We return only the number of times the box is pushed.\nExample 2:\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: -1\n\nExample 3:\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\n               [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: 5\nExplanation: push the box down, left, left, up and up.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 20\ngrid contains only characters '.', '#', 'S', 'T', or 'B'.\nThere is only one character 'S', 'B', and 'T' in the grid.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def minPushBox(self, grid: List[List[str]]) -> int:\n        n, m = len(grid), len(grid[0])\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'T':\n                    t = (i, j)\n                elif grid[i][j] == 'S':\n                    s = (i, j)\n                elif grid[i][j] == 'B':\n                    b = (i, j)\n        \n        dirs = [[1,0],[-1,0],[0,1],[0,-1]]\n        q = [tuple(s + b)]\n        seen = set(q)\n        steps = 0\n        while q:\n            nq = []\n            for si, sj, bi, bj in q:\n                if t == (bi, bj): return steps\n                for di, dj in dirs:\n                    nsi, nsj = si+di, sj+dj\n                    if nsi==bi and nsj==bj:\n                        nbi, nbj = bi+di, bj+dj\n                        ds = 1\n                    else:\n                        nbi, nbj = bi, bj\n                        ds = 0\n                    if not (0 <= nsi < n and 0 <= nsj < m): continue\n                    if not (0 <= nbi < n and 0 <= nbj < m): continue\n                    if grid[nsi][nsj] == '#' or grid[nbi][nbj] == '#': continue\n                    nsb = (nsi, nsj, nbi, nbj)\n                    if nsb in seen: continue\n                    seen.add(nsb)\n                    if ds == 0:\n                        q.append(nsb)\n                    else:\n                        nq.append(nsb)\n            q = nq\n            steps += 1\n        return -1\n        \n        \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_962", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 3 function for\n\nDesign a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character '#').\n\nYou are given a string array sentences and an integer array times both of length n where sentences[i] is a previously typed sentence and times[i] is the corresponding number of times the sentence was typed. For each input character except '#', return the top 3 historical hot sentences that have the same prefix as the part of the sentence already typed.\n\nHere are the specific rules:\n\nThe hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.\nThe returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same hot degree, use ASCII-code order (smaller one appears first).\nIf less than 3 hot sentences exist, return as many as you can.\nWhen the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.\n\nImplement the AutocompleteSystem class:\n\nAutocompleteSystem(String[] sentences, int[] times) Initializes the object with the sentences and times arrays.\nList<String> input(char c) This indicates that the user typed the character c.\nReturns an empty array [] if c == '#' and stores the inputted sentence in the system.\nReturns the top 3 historical hot sentences that have the same prefix as the part of the sentence already typed. If there are fewer than 3 matches, return them all.\n\n \n\nExample 1:\n\nInput\n[\"AutocompleteSystem\", \"input\", \"input\", \"input\", \"input\"]\n[[[\"i love you\", \"island\", \"iroman\", \"i love leetcode\"], [5, 3, 2, 2]], [\"i\"], [\" \"], [\"a\"], [\"#\"]]\nOutput\n[null, [\"i love you\", \"island\", \"i love leetcode\"], [\"i love you\", \"i love leetcode\"], [], []]\n\nExplanation\nAutocompleteSystem obj = new AutocompleteSystem([\"i love you\", \"island\", \"iroman\", \"i love leetcode\"], [5, 3, 2, 2]);\nobj.input(\"i\"); // return [\"i love you\", \"island\", \"i love leetcode\"]. There are four sentences that have prefix \"i\". Among them, \"ironman\" and \"i love leetcode\" have same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, \"i love leetcode\" should be in front of \"ironman\". Also we only need to output top 3 hot sentences, so \"ironman\" will be ignored.\nobj.input(\" \"); // return [\"i love you\", \"i love leetcode\"]. There are only two sentences that have prefix \"i \".\nobj.input(\"a\"); // return []. There are no sentences that have prefix \"i a\".\nobj.input(\"#\"); // return []. The user finished the input, the sentence \"i a\" should be saved as a historical sentence in system. And the following input will be counted as a new search.\n\n \n\nConstraints:\n\nn == sentences.length\nn == times.length\n1 <= n <= 100\n1 <= sentences[i].length <= 100\n1 <= times[i] <= 50\nc is a lowercase English letter, a hash '#', or space ' '.\nEach tested sentence will be a sequence of characters c that end with the character '#'.\nEach tested sentence will have a length in the range [1, 200].\nThe words in each input sentence are separated by single spaces.\nAt most 5000 calls will be made to input.\n\n"}, {"role": "assistant", "content": "\nclass AutocompleteSystem:\n\n    def __init__(self, sentences, times):\n        \"\"\"\n        :type sentences: List[str]\n        :type times: List[int]\n        \"\"\"\n        self.heap = {}\n        self.cur = \"\"\n        n = len(sentences)\n        for i in range(0, n):\n            if sentences[i] not in self.heap:\n                self.heap[sentences[i]] = times[i]\n            else:\n                self.heap[sentences[i]] += times[i]\n        self.sortedlist = []\n        for key, value in self.heap.items():\n            temp = [key, value]\n            self.sortedlist.append(temp)\n        self.sortedlist = sorted(self.sortedlist, key=self.cmp_to_key(self.compare))\n\n    def input(self, c):\n        \"\"\"\n        :type c: str\n        :rtype: List[str]\n        \"\"\"\n        if c == '#':\n            if self.cur not in self.heap:\n                self.heap[self.cur] = 1\n            else:\n                self.heap[self.cur] += 1\n            self.cur = \"\"\n            self.sortedlist = []\n            for key, value in self.heap.items():\n                temp = [key, value]\n                self.sortedlist.append(temp)\n            self.sortedlist = sorted(self.sortedlist, key=self.cmp_to_key(self.compare))\n            return []\n        self.cur += c\n        res = []\n        for x in self.sortedlist:\n            if x[0].startswith(self.cur):\n                res.append(x)\n        self.sortedlist = res\n        if len(res)>=3:\n            return list(map(lambda x: x[0], res[0:3]))\n        return list(map(lambda x: x[0], res))\n\n    def cmp_to_key(self, mycmp):\n        'Convert a cmp= function into a key= function'\n        class K(object):\n            def __init__(self, obj, *args):\n                self.obj = obj\n\n            def __lt__(self, other):\n                return mycmp(self.obj, other.obj) < 0\n\n            def __gt__(self, other):\n                return mycmp(self.obj, other.obj) > 0\n\n            def __eq__(self, other):\n                return mycmp(self.obj, other.obj) == 0\n\n            def __le__(self, other):\n                return mycmp(self.obj, other.obj) <= 0\n\n            def __ge__(self, other):\n                return mycmp(self.obj, other.obj) >= 0\n\n            def __ne__(self, other):\n                return mycmp(self.obj, other.obj) != 0\n        return K\n\n    def compare(self, a, b):\n        if a[1] == b[1]:\n            if a[0] == b[0]:\n                return 0\n            elif a[0] < b[0]:\n                return -1\n            else:\n                return 1\n        elif a[1] < b[1]:\n            return 1\n        else:\n            return -1\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_969", "label": "code_high", "messages": [{"role": "user", "content": "Can you implement a function in Python 2 that\n\nGiven the strings s1 and s2 of size n and the string evil, return the number of good strings.\nA good string has size n, it is alphabetically greater than or equal to s1, it is alphabetically smaller than or equal to s2, and it does not contain the string evil as a substring. Since the answer can be a huge number, return this modulo 10^9 + 7.\n\u00a0\nExample 1:\nInput: n = 2, s1 = \"aa\", s2 = \"da\", evil = \"b\"\nOutput: 51 \nExplanation: There are 25 good strings starting with 'a': \"aa\",\"ac\",\"ad\",...,\"az\". Then there are 25 good strings starting with 'c': \"ca\",\"cc\",\"cd\",...,\"cz\" and finally there is one good string starting with 'd': \"da\".\u00a0\n\nExample 2:\nInput: n = 8, s1 = \"leetcode\", s2 = \"leetgoes\", evil = \"leet\"\nOutput: 0 \nExplanation: All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix \"leet\", therefore, there is not any good string.\n\nExample 3:\nInput: n = 2, s1 = \"gx\", s2 = \"gz\", evil = \"x\"\nOutput: 2\n\n\u00a0\nConstraints:\n\ns1.length == n\ns2.length == n\ns1 <= s2\n1 <= n <= 500\n1 <= evil.length <= 50\nAll strings consist of lowercase English letters.\n\n"}, {"role": "assistant", "content": "from collections import defaultdict\nfrom string import ascii_lowercase\n\nclass Solution(object):\n    def findGoodStrings(self, n, s1, s2, evil):\n        \"\"\"\n        :type n: int\n        :type s1: str\n        :type s2: str\n        :type evil: str\n        :rtype: int\n        \"\"\"\n        kmp = [-1]*(len(evil)+1)\n        j = 0\n        for i in xrange(1, len(evil)):\n            if evil[i] == evil[j]:\n                kmp[i] = kmp[j]\n            else:\n                kmp[i] = j\n                while j >= 0 and evil[i] != evil[j]: j = kmp[j]\n            j += 1\n        kmp[-1] = j\n\n        def match(lpm, c):\n            if lpm == len(evil): lpm = kmp[lpm]\n            while lpm >= 0 and evil[lpm] != c: lpm = kmp[lpm]\n            return lpm + 1\n\n        M = 10**9 + 7\n        def ways_below(s):\n            n = len(s)\n            # num chars\n            # whether equal to s\n            # lpm\n            w = defaultdict(int)\n            w[(True, 0)] = 1\n            for i in xrange(n):\n                ww = defaultdict(int)\n                for (m, lpm), v in w.iteritems():\n                    v %= M\n                    for c in ascii_lowercase:\n                        if m and c > s[i]: break\n                        mm = m and c == s[i]\n                        lpmm = match(lpm, c)\n                        if lpmm == len(evil): continue\n                        ww[(mm, lpmm)] += v\n                w = ww\n            return sum(v for _, v in w.iteritems()) % M\n        \n        r = ways_below(s2) - ways_below(s1)\n        if evil not in s1: r += 1\n        return r % M"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1006", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 2 that\n\nYou are given an m x n binary grid, where each 1 represents a brick and 0 represents an empty space. A brick is stable if:\n\nIt is directly connected to the top of the grid, or\nAt least one other brick in its four adjacent cells is stable.\n\nYou are also given an array hits, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location hits[i] = (rowi, coli). The brick on that location\u00a0(if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the grid (i.e., it does not land on other stable bricks).\nReturn an array result, where each result[i] is the number of bricks that will fall after the ith erasure is applied.\nNote that an erasure may refer to a location with no brick, and if it does, no bricks drop.\n\u00a0\nExample 1:\nInput: grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\nOutput: [2]\nExplanation: Starting with the grid:\n[[1,0,0,0],\n [1,1,1,0]]\nWe erase the underlined brick at (1,0), resulting in the grid:\n[[1,0,0,0],\n [0,1,1,0]]\nThe two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is:\n[[1,0,0,0],\n [0,0,0,0]]\nHence the result is [2].\n\nExample 2:\nInput: grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\nOutput: [0,0]\nExplanation: Starting with the grid:\n[[1,0,0,0],\n [1,1,0,0]]\nWe erase the underlined brick at (1,1), resulting in the grid:\n[[1,0,0,0],\n [1,0,0,0]]\nAll remaining bricks are still stable, so no bricks fall. The grid remains the same:\n[[1,0,0,0],\n [1,0,0,0]]\nNext, we erase the underlined brick at (1,0), resulting in the grid:\n[[1,0,0,0],\n [0,0,0,0]]\nOnce again, all remaining bricks are still stable, so no bricks fall.\nHence the result is [0,0].\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\ngrid[i][j] is 0 or 1.\n1 <= hits.length <= 4 * 10000\nhits[i].length == 2\n0 <= xi\u00a0<= m - 1\n0 <=\u00a0yi <= n - 1\nAll (xi, yi) are unique.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def hitBricks(self, grid, hits):\n        \n        grid2 = [[[] for _ in row] for row in grid]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                for i2, j2 in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                    if i2 < 0 or i2 >= len(grid) or j2 < 0 or j2 >= len(grid[0]): continue\n                    grid2[i][j].append((i2, j2))\n        \n        grid3 = [[[] for _ in row] for row in grid]\n        \n        for j in range(len(grid[0])):\n            q = [(0, j)]\n            seen = set(q)\n            while q:\n                i, j = q.pop(0)\n                seen.add((i, j))\n                if grid[i][j] != 1: continue\n                for child in grid2[i][j]:\n                    i2, j2 = child\n                    if i2 == 0: continue\n                    if child not in seen and (i, j) not in grid3[i2][j2]:\n                        q.append(child)\n                        grid3[child[0]][child[1]].append((i, j))\n        \n        ans = []\n        for i, j in hits:\n            #print(\"\\n\".join(\"\".join(str(len(c)) if c else '.' for c in row) for row in grid3))\n            grid[i][j] = 0\n            q = [(i, j)]\n            seen = set(q)\n            res = 0\n            while q:\n                i2, j2 = q.pop(0)\n                seen.add((i2, j2))\n                for child in grid2[i2][j2]:\n                    if child in seen: continue\n                    if child[0] == 0: continue\n                    i3, j3 = child\n                    if grid[i3][j3] == 0: continue\n                    \n                    if (i2, j2) in grid3[i3][j3]:\n                        grid3[child[0]][child[1]].remove((i2, j2))\n                    \n                    x, y = i3, j3\n                    while len(grid3[x][y]) == 1:\n                        i4, j4 = grid3[x][y][0]\n                        if (x, y) in grid3[i4][j4]:\n                            grid3[i4][j4].remove((x, y))\n                            if len(grid3[i4][j4]) == 1:\n                                x, y = i4, j4\n                            else:\n                                break\n                        else:\n                            break\n                        \n                    if not grid3[child[0]][child[1]]:\n                        grid[i3][j3] = 0\n                        q.append((i3, j3))\n                        res += 1\n            ans.append(res)\n        return ans\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1009", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 2 to\n\nThere is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, where pieces[i] describes the type (rook, queen, or bishop) of the ith piece. In addition, you are given a 2D integer array positions also of length n, where positions[i] = [ri, ci] indicates that the ith piece is currently at the 1-based coordinate (ri, ci) on the chessboard.\nWhen making a move for a piece, you choose a destination square that the piece will travel toward and stop on.\n\nA rook can only travel horizontally or vertically from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), or (r, c-1).\nA queen can only travel horizontally, vertically, or diagonally from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), (r, c-1), (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\nA bishop can only travel diagonally from (r, c) to the direction of (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\n\nYou must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square.\nReturn the number of valid move combinations\u200b\u200b\u200b\u200b\u200b.\nNotes:\n\nNo two pieces will start in the same square.\nYou may choose the square a piece is already on as its destination.\nIf two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second.\n\n\u00a0\nExample 1:\n\nInput: pieces = [\"rook\"], positions = [[1,1]]\nOutput: 15\nExplanation: The image above shows the possible squares the piece can move to.\n\nExample 2:\n\nInput: pieces = [\"queen\"], positions = [[1,1]]\nOutput: 22\nExplanation: The image above shows the possible squares the piece can move to.\n\nExample 3:\n\nInput: pieces = [\"bishop\"], positions = [[4,3]]\nOutput: 12\nExplanation: The image above shows the possible squares the piece can move to.\n\n\u00a0\nConstraints:\n\nn == pieces.length \nn == positions.length\n1 <= n <= 4\npieces only contains the strings \"rook\", \"queen\", and \"bishop\".\nThere will be at most one queen on the chessboard.\n1 <= xi, yi <= 8\nEach positions[i] is distinct.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n\n    def countCombinations(self, p, pos):\n        res = []\n        n = len(p)\n        for k in range(n):\n            cur = set()\n            x, y = pos[k]\n            for i in xrange(1, 9):\n                for j in xrange(1, 9):\n                    if (i == x or j == y) and p[k][0] in 'rq':\n                        cur.add((i, j))\n                    if (i - j == x - y or i + j == x + y) and p[k][0] in 'qb':\n                        cur.add((i, j))\n            res.append(list(cur))\n        ress = 0\n\n        def check(pos2):\n            if len(set(pos2)) < n:\n                return False\n            tt = []\n            for i in xrange(n):\n                x0, y0 = pos[i]\n                x1, y1 = pos2[i]\n                t = max(abs(x0 - x1), abs(y0 - y1))\n                tt.append(t)\n            for t in range(max(tt)):\n                cur = []\n                for i in xrange(n):\n                    x0, y0 = pos[i]\n                    x1, y1 = pos2[i]\n                    if tt[i] == 0:\n                        cur.append((x0, y0))\n                    else:\n                        x = x0 + (x1 - x0) / tt[i] * t if t < tt[i] else x1\n                        y = y0 + (y1 - y0) / tt[i] * t if t < tt[i] else y1\n                        cur.append((x, y))\n                if len(set(cur)) < n:\n                    # print pos, cur, pos2\n                    return False\n            return True\n\n        for case in itertools.product(*res):\n            ress += check(case)\n        return ress"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1010", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 3 program that\n\nThere is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, where pieces[i] describes the type (rook, queen, or bishop) of the ith piece. In addition, you are given a 2D integer array positions also of length n, where positions[i] = [ri, ci] indicates that the ith piece is currently at the 1-based coordinate (ri, ci) on the chessboard.\nWhen making a move for a piece, you choose a destination square that the piece will travel toward and stop on.\n\nA rook can only travel horizontally or vertically from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), or (r, c-1).\nA queen can only travel horizontally, vertically, or diagonally from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), (r, c-1), (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\nA bishop can only travel diagonally from (r, c) to the direction of (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\n\nYou must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square.\nReturn the number of valid move combinations\u200b\u200b\u200b\u200b\u200b.\nNotes:\n\nNo two pieces will start in the same square.\nYou may choose the square a piece is already on as its destination.\nIf two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second.\n\n\u00a0\nExample 1:\n\nInput: pieces = [\"rook\"], positions = [[1,1]]\nOutput: 15\nExplanation: The image above shows the possible squares the piece can move to.\n\nExample 2:\n\nInput: pieces = [\"queen\"], positions = [[1,1]]\nOutput: 22\nExplanation: The image above shows the possible squares the piece can move to.\n\nExample 3:\n\nInput: pieces = [\"bishop\"], positions = [[4,3]]\nOutput: 12\nExplanation: The image above shows the possible squares the piece can move to.\n\n\u00a0\nConstraints:\n\nn == pieces.length \nn == positions.length\n1 <= n <= 4\npieces only contains the strings \"rook\", \"queen\", and \"bishop\".\nThere will be at most one queen on the chessboard.\n1 <= xi, yi <= 8\nEach positions[i] is distinct.\n\n"}, {"role": "assistant", "content": "DIR_STRAIGHT = (1, 0, -1, 0, 1)\nDIR_DIAGNAL = (1, -1, -1, 1, 1)\nclass Solution:\n    def dfs(self, player: int, buffer: List[List[int]], length: int, valids):  #\n        if (player == length):\n            if self.bfs(buffer):\n                self.res += 1\n        else:\n            for each in valids[player]:\n                buffer.append(each)\n                self.dfs(player + 1, buffer, length, valids)\n                buffer.pop()\n\n    def bfs(self, combination)-> bool:\n            board = [[0] * 9 for _ in range(9)]\n            q = []\n            for player in combination:\n                board[player[2]][player[3]] = 1\n                if player[2] != player[4] or player[3] != player[5]:\n                    q.append([*player])\n            while q:\n                for player in q: # vaccate\n                    board[player[2]][player[3]] = 0\n                q2 = []\n                for player in q:\n                    player[2] += player[0]\n                    player[3] += player[1]\n                    if board[player[2]][player[3]] == 1:\n                        return False\n                    board[player[2]][player[3]] = 1\n                    if player[2] != player[4] or player[3] != player[5]:\n                        q2.append(player)\n                q = q2\n            return True\n    def moves(self, dir: tuple, valid: List[tuple], sr: int, sc: int):\n        er, ec = sr, sc\n        while 1:\n            er += dir[0]\n            ec += dir[1]\n            if er == 0 or er == 9 or ec == 0 or ec == 9:\n                break\n            valid.append((dir[0], dir[1], sr, sc, er, ec))\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\n        valids = []\n        for idx in range(len(pieces)):\n            valid = []\n            valids.append(valid)\n            valid.append((0, 0, positions[idx][0], positions[idx][1], positions[idx][0], positions[idx][1]))\n            chesser = pieces[idx][0]\n            if 'b' != chesser:\n                for i in range(4):\n                    self.moves((DIR_STRAIGHT[i], DIR_STRAIGHT[i+1]), valid, positions[idx][0], positions[idx][1])\n            if 'r' != chesser:\n                for i in range(4):\n                    self.moves((DIR_DIAGNAL[i],DIR_DIAGNAL[i+1]), valid, positions[idx][0], positions[idx][1])\n        self.res = 0\n        if len(pieces) == 1:\n            return len(valids[0])\n        self.dfs(0, [], len(pieces), valids)\n        return self.res\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1061", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 2 function for\n\nThere is an undirected graph with n nodes, numbered from 0 to n - 1.\nYou are given a 0-indexed integer array scores of length n where scores[i] denotes the score of node i. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nA node sequence is valid if it meets the following conditions:\n\nThere is an edge connecting every pair of adjacent nodes in the sequence.\nNo node appears more than once in the sequence.\n\nThe score of a node sequence is defined as the sum of the scores of the nodes in the sequence.\nReturn the maximum score of a valid node sequence with a length of 4. If no such sequence exists, return -1.\n\u00a0\nExample 1:\n\nInput: scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\nOutput: 24\nExplanation: The figure above shows the graph and the chosen node sequence [0,1,2,3].\nThe score of the node sequence is 5 + 2 + 9 + 8 = 24.\nIt can be shown that no other node sequence has a score of more than 24.\nNote that the sequences [3,1,2,0] and [1,0,2,3] are also valid and have a score of 24.\nThe sequence [0,3,2,4] is not valid since no edge connects nodes 0 and 3.\n\nExample 2:\n\nInput: scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]\nOutput: -1\nExplanation: The figure above shows the graph.\nThere are no valid node sequences of length 4, so we return -1.\n\n\u00a0\nConstraints:\n\nn == scores.length\n4 <= n <= 5 * 10000\n1 <= scores[i] <= 10^8\n0 <= edges.length <= 5 * 10000\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\nThere are no duplicate edges.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def maximumScore(self, scores, edges):\n        \"\"\"\n        :type scores: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(scores)\n        rs = [[(-1,-1),(-1,-1),(-1,-1)] for _ in range(n)]\n        for a, b in edges:\n            v, i = scores[b], b\n            if v>rs[a][0][0]:\n                rs[a][2], rs[a][1] = rs[a][1], rs[a][0]\n                rs[a][0]=(v, i)\n            elif v>rs[a][1][0]:\n                rs[a][2]=rs[a][1]\n                rs[a][1] = (v,i)\n            elif v>rs[a][2][0]:\n                rs[a][2]=(v, i)\n            v, i = scores[a], a\n            if v>rs[b][0][0]:\n                rs[b][2], rs[b][1] = rs[b][1], rs[b][0]\n                rs[b][0]=(v, i)\n            elif v>rs[b][1][0]:\n                rs[b][2]=rs[b][1]\n                rs[b][1] = (v,i)\n            elif v>rs[b][2][0]:\n                rs[b][2]=(v, i)\n        rc=-1\n        for a, b in edges:\n            v=scores[a]+scores[b]\n            for k1 in range(3):\n                v1, i1 = rs[a][k1]\n                if v1==-1: break\n                if i1==b: continue\n                for k2 in range(3):\n                    v2, i2 = rs[b][k2]\n                    if v2==-1: break\n                    if i2==a: continue\n                    if i1==i2: continue\n                    vv=v1+v2+v\n                    if rc<vv: rc=vv\n        return rc"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1157", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 2 to\n\nA k x k magic square is a k x k grid filled with integers such that every row sum, every column sum, and both diagonal sums are all equal. The integers in the magic square do not have to be distinct. Every 1 x 1 grid is trivially a magic square.\nGiven an m x n integer grid, return the size (i.e., the side length k) of the largest magic square that can be found within this grid.\n\u00a0\nExample 1:\n\nInput: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]\nOutput: 3\nExplanation: The largest magic square has a size of 3.\nEvery row sum, column sum, and diagonal sum of this magic square is equal to 12.\n- Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12\n- Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12\n- Diagonal sums: 5+4+3 = 6+4+2 = 12\n\nExample 2:\n\nInput: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]\nOutput: 2\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 1000000\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def largestMagicSquare(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        s = min(m, n)\n        rsum = [[0]*(n+1) for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                rsum[i][j+1]=rsum[i][j]+grid[i][j]\n        csum = [[0]*(m+1) for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                csum[i][j+1]=csum[i][j]+grid[j][i]\n        def check(s):\n            i=0\n            while i+s<=m:\n                j=0\n                ei=i+s-1\n                while j+s<=n:\n                    ej = j+s-1\n                    v = rsum[i][ej+1]-rsum[i][j]\n                    k=i+1\n                    while k<=ei:\n                        t = rsum[k][ej+1]-rsum[k][j]\n                        if t!=v: break\n                        k+=1\n                    if k<=ei:\n                        j+=1\n                        continue\n                    k=j\n                    while k<=ej:\n                        t = csum[k][ei+1]-csum[k][i]\n                        if t!=v: break\n                        k+=1\n                    if k<=ej:\n                        j+=1\n                        continue\n                    k=0\n                    t=0\n                    while k<s:\n                        t+=grid[i+k][j+k]\n                        k+=1\n                    if t!=v:\n                        j+=1\n                        continue\n                    k, t = 0, 0\n                    while k<s:\n                        t+=grid[i+s-1-k][j+k]\n                        k+=1\n                    if t==v: return True\n                    j+=1\n                i+=1\n            return False\n        \n        while s>1:\n            if check(s): break\n            s-=1\n        return s"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1222", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 3 to\n\nYou are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m.\nYou have to perform m independent queries on the tree where in the ith query you do the following:\n\nRemove the subtree rooted at the node with the value queries[i] from the tree. It is guaranteed that queries[i] will not be equal to the value of the root.\n\nReturn an array answer of size m where answer[i] is the height of the tree after performing the ith query.\nNote:\n\nThe queries are independent, so the tree returns to its initial state after each query.\nThe height of a tree is the number of edges in the longest simple path from the root to some node in the tree.\n\n\u00a0\nExample 1:\n\nInput: root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]\nOutput: [2]\nExplanation: The diagram above shows the tree after removing the subtree rooted at node with value 4.\nThe height of the tree is 2 (The path 1 -> 3 -> 2).\n\nExample 2:\n\nInput: root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]\nOutput: [3,2,3,2]\nExplanation: We have the following queries:\n- Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4).\n- Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -> 8 -> 1).\n- Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6).\n- Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -> 9 -> 3).\n\n\u00a0\nConstraints:\n\nThe number of nodes in the tree is n.\n2 <= n <= 100000\n1 <= Node.val <= n\nAll the values in the tree are unique.\nm == queries.length\n1 <= m <= min(n, 10000)\n1 <= queries[i] <= n\nqueries[i] != root.val\n\n"}, {"role": "assistant", "content": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sz(self, node):\n        if node == None:\n            return 0\n        node.val -= 1\n        return 1 + self.sz(node.left) + self.sz(node.right)\n    \n    def ch(self, node, dep, par):\n        if node == None:\n            return\n        \n        self.h[node.val] = dep\n        self.par[node.val] = par\n        \n        self.ti[node.val] = self.nex        \n        self.early[dep] = min(self.early[dep], self.nex)\n        self.late[dep] = max(self.late[dep], self.nex)\n        \n        self.topo.append(node.val)\n        \n        assert self.topo[self.nex] == node.val\n        \n        self.nex += 1\n        \n        self.ch(node.left, dep + 1, node.val)\n        self.ch(node.right, dep + 1, node.val)\n    \n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        n = self.sz(root)\n        \n        self.par = [-1] * n\n        self.h = [-1] * n \n        self.ti = [-1] * n\n        \n        self.early = [n] * (n + 5)\n        self.late = [-1] * (n + 5)\n        \n        self.nex = 0\n        \n        self.topo = []\n        \n        self.ch(root, 0, -1)\n        \n        \n        self.end = self.ti[:]\n        for v in self.topo[::-1]:\n            if self.par[v] != -1:\n                self.end[self.par[v]] = max(self.end[self.par[v]], self.end[v])\n        \n        out = []\n        for q in queries:\n            q -= 1\n            \n            lo = 0\n            hi = n + 1\n            while hi - lo > 1:\n                mid = (lo + hi) // 2\n                \n                if self.early[mid] >= self.ti[q] and self.late[mid] <= self.end[q]:\n                    hi = mid\n                else:\n                    lo = mid\n                    \n            out.append(lo)\n            \n        return out"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1277", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 program that can\n\nYou are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\n\u00a0\nExample 1:\n\nInput: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.\n\nExample 2:\n\nInput: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6\n\nExample 3:\n\nInput: grid = [\"@Aa\"]\nOutput: -1\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.\n\n"}, {"role": "assistant", "content": "from collections import deque\n\nclass Solution(object):\n    def shortestPathAllKeys(self, grid):\n        \"\"\"\n        :type grid: List[str]\n        :rtype: int\n        \"\"\"\n        si, sj = 0, 0\n        n = len(grid)\n        m = len(grid[0])\n        k = 0\n        for i in xrange(n):\n            for j in xrange(m):\n                if grid[i][j] == '@':\n                    si, sj = i, j\n                if grid[i][j] >= 'a' and grid[i][j] <= 'f':\n                    k = max(k, ord(grid[i][j])-ord('a')+1)\n        print k\n        keys = 0\n        q = deque([(si, sj, 0, keys)])\n        vis = set([(si, sj, keys)])\n        while q:\n            i, j, dst, keys = q.pop()\n            for di, dj in [(-1, 0), (1, 0), (0, 1), (0, -1)]:\n                ni, nj = i + di, j + dj\n                if ni < 0 or ni == n or nj < 0 or nj == m:\n                    continue\n                if grid[ni][nj] == '#':\n                    continue\n                if grid[ni][nj] >= 'A' and grid[ni][nj] <= 'F':\n                    if (keys >> (ord(grid[ni][nj]) - ord('A'))) & 1 == 0:\n                        continue\n                nkeys = keys\n                if grid[ni][nj] >= 'a' and grid[ni][nj] <= 'f':\n                    nkeys |= (1 << (ord(grid[ni][nj]) - ord('a')))\n                    if nkeys == (1 << k) - 1:\n                        return dst + 1\n                if (ni, nj, nkeys) in vis:\n                    continue\n                q.appendleft((ni, nj, dst+1, nkeys))\n                vis.add((ni, nj, nkeys))\n        return -1\n                \n        \n        \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1278", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 program that can\n\nYou are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\n\u00a0\nExample 1:\n\nInput: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.\n\nExample 2:\n\nInput: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6\n\nExample 3:\n\nInput: grid = [\"@Aa\"]\nOutput: -1\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def shortestPathAllKeys(self, grid):\n        \"\"\"\n        :type grid: List[str]\n        :rtype: int\n        \"\"\"\n        n, m = len(grid), len(grid[0])\n        k = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '@':\n                    si, sj = i, j\n                elif 'a' <= grid[i][j] <= 'z':\n                    k += 1\n        if k == 0: return 0\n        kc = 1 << k\n        allkeys = kc - 1\n        s = [[[False] * kc for j in range(m)] for i in range(n)]\n        cur = [(si, sj, 0)]\n        s[si][sj][0] = True\n        step = 1\n        ds = [(1,0),(-1,0),(0,1),(0,-1)]\n        while cur:\n            next = []\n            for i, j, msk in cur:\n                for di,dj in ds:\n                    ni,nj = i+di,j+dj\n                    nmsk = msk\n                    if not (0 <= ni < n and 0 <= nj < m): continue\n                    if grid[ni][nj] == '#': continue\n                    if 'A' <= grid[ni][nj] <= 'Z':\n                        door = ord(grid[ni][nj]) - ord('A')\n                        if (msk & (1 << door)) == 0: continue\n                    if 'a' <= grid[ni][nj] <= 'z':\n                        key = ord(grid[ni][nj]) - ord('a')\n                        nmsk |= 1 << key\n                        if nmsk == allkeys:\n                            return step\n                    if not s[ni][nj][nmsk]:\n                        s[ni][nj][nmsk] = True\n                        next.append((ni,nj,nmsk))\n                        \n            step, cur = step + 1, next\n        return -1\n            \n        \n        \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1348", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 3 to\n\nYou are given a string s consisting only of lowercase English letters.\nIn one move, you can select any two adjacent characters of s and swap them.\nReturn the minimum number of moves needed to make s a palindrome.\nNote that the input will be generated such that s can always be converted to a palindrome.\n\u00a0\nExample 1:\nInput: s = \"aabb\"\nOutput: 2\nExplanation:\nWe can obtain two palindromes from s, \"abba\" and \"baab\". \n- We can obtain \"abba\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"abba\".\n- We can obtain \"baab\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"baab\".\nThus, the minimum number of moves needed to make s a palindrome is 2.\n\nExample 2:\nInput: s = \"letelt\"\nOutput: 2\nExplanation:\nOne of the palindromes we can obtain from s in 2 moves is \"lettel\".\nOne of the ways we can obtain it is \"letelt\" -> \"letetl\" -> \"lettel\".\nOther palindromes such as \"tleelt\" can also be obtained in 2 moves.\nIt can be shown that it is not possible to obtain a palindrome in less than 2 moves.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 2000\ns consists only of lowercase English letters.\ns can be converted to a palindrome using a finite number of moves.\n\n"}, {"role": "assistant", "content": "class BIT:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(self.n+1) # 1-indexed\n \n    def init(self, init_val):\n        for i, v in enumerate(init_val):\n            self.add(i, v)\n \n    def add(self, i, x):\n        # i: 0-indexed\n        i += 1 # to 1-indexed\n        while i <= self.n:\n            self.bit[i] += x\n            i += (i & -i)\n \n    def sum(self, i, j):\n        # return sum of [i, j)\n        # i, j: 0-indexed\n        return self._sum(j) - self._sum(i)\n \n    def _sum(self, i):\n        # return sum of [0, i)\n        # i: 0-indexed\n        res = 0\n        while i > 0:\n            res += self.bit[i]\n            i -= i & (-i)\n        return res\n \n    def lower_bound(self, x):\n        s = 0\n        pos = 0\n        depth = self.n.bit_length()\n        v = 1 << depth\n        for i in range(depth, -1, -1):\n            k = pos + v\n            if k <= self.n and s + self.bit[k] < x:\n                    s += self.bit[k]\n                    pos += v\n            v >>= 1\n        return pos\n \n    def __str__(self): # for debug\n        arr = [self.sum(i,i+1) for i in range(self.n)]\n        return str(arr)\n\nclass Solution:\n    def minMovesToMakePalindrome(self, s: str) -> int:\n        S = list(s)\n        S = [ord(c)-ord('a') for c in S]\n\n        n = len(S)\n\n        C = [[] for i in range(26)]\n        for i, c in enumerate(S):\n            C[c].append(i)\n        o = 0\n        for c in range(26):\n            if len(C[c])%2 == 1:\n                o += 1\n        #if o > 1:\n            #print(-1)\n            #exit()\n        L = []\n        M = []\n        R = []\n        for c in range(26):\n            if len(C[c])%2 == 0:\n                for j in range(len(C[c])):\n                    i = C[c][j]\n                    if j < len(C[c])//2:\n                        L.append(i)\n                    else:\n                        R.append(i)\n            else:\n                for j in range(len(C[c])):\n                    i = C[c][j]\n                    if j < len(C[c])//2:\n                        L.append(i)\n                    elif j == len(C[c])//2:\n                        M.append(i)\n                    else:\n                        R.append(i)\n\n        L.sort()\n\n        C = [list(reversed(l)) for l in C]\n\n        N = L+M+list(reversed(L))\n        toid = {}\n        for j, k in enumerate(N):\n            c = S[k]\n            i = C[c].pop()\n            toid[i] = j\n        bit = BIT(n+1)\n        ans = 0\n        for i in range(n):\n            ans += bit.sum(toid[i]+1, bit.n)\n            bit.add(toid[i], 1)\n        return ans\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1350", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 2 function for\n\nYou are given a string s consisting only of lowercase English letters.\nIn one move, you can select any two adjacent characters of s and swap them.\nReturn the minimum number of moves needed to make s a palindrome.\nNote that the input will be generated such that s can always be converted to a palindrome.\n\u00a0\nExample 1:\nInput: s = \"aabb\"\nOutput: 2\nExplanation:\nWe can obtain two palindromes from s, \"abba\" and \"baab\". \n- We can obtain \"abba\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"abba\".\n- We can obtain \"baab\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"baab\".\nThus, the minimum number of moves needed to make s a palindrome is 2.\n\nExample 2:\nInput: s = \"letelt\"\nOutput: 2\nExplanation:\nOne of the palindromes we can obtain from s in 2 moves is \"lettel\".\nOne of the ways we can obtain it is \"letelt\" -> \"letetl\" -> \"lettel\".\nOther palindromes such as \"tleelt\" can also be obtained in 2 moves.\nIt can be shown that it is not possible to obtain a palindrome in less than 2 moves.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 2000\ns consists only of lowercase English letters.\ns can be converted to a palindrome using a finite number of moves.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def minMovesToMakePalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        cs = [0]*26\n        b=ord('a')\n        ss = [ord(c)-b for c in s]\n        for c in ss: cs[c]+=1\n        ccs = [0]*26\n        n = len(s)\n        m = n/2\n        rc=0\n        for i in range(m):\n            j=i\n            while j<n:\n                c=ss[j]\n                if ccs[c]+ccs[c]+1+1>cs[c]:\n                    j+=1\n                else:\n                    break\n            c=ss[j]\n            while j>i:\n                ss[j]=ss[j-1]\n                j-=1\n                rc+=1\n            ss[i]=c\n            ccs[c]+=1\n        if n&1:\n            i=m\n            while i<n:\n                c=ss[i]\n                if ccs[c]+ccs[c]<cs[c]: break\n                i+=1\n            c=ss[i]\n            while i>m:\n                ss[i]=ss[i-1]\n                i-=1\n                rc+=1\n            ss[i]=c\n        nss = []\n        for i in range(m):\n            nss.append(ss[n-1-i])\n        # print ss[:m], nss\n        for i in range(m):\n            if ss[i]==nss[i]: continue\n            j=i\n            while j<m and nss[j]!=ss[i]: j+=1\n            c=nss[j]\n            while j>i:\n                nss[j]=nss[j-1]\n                j-=1\n                rc+=1\n        return rc\n                    "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1377", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 3 to\n\nYou are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.\n\u00a0\nExample 1:\n\nInput: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).\n\nExample 2:\n\nInput: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)\n\nExample 3:\nInput: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6\n\n"}, {"role": "assistant", "content": "class Solution:\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\n        R, C = len(grid), len(grid[0])\n        \n        \n        parents = {}\n        def find(p):\n            if p not in parents:\n                parents[p] = p\n            if parents[p] != p:\n                parents[p] = find(parents[p])\n            return parents[p]\n        def union(p, q):\n            i, j = find(p), find(q)\n            parents[j] = i\n        \n        def connect(r, c):\n            if grid[r][c] == 1:\n                if c > 0 and grid[r][c-1] in [1,4,6]:\n                    union((r, c), (r, c-1))\n                if c < C - 1 and grid[r][c+1] in [1,3,5]:\n                    union((r, c), (r, c+1))\n            elif grid[r][c] == 2:\n                if r > 0 and grid[r-1][c] in [2,3,4]:\n                    union((r, c), (r-1, c))\n                if r < R - 1 and grid[r+1][c] in [2,5,6]:\n                    union((r, c), (r+1, c))\n            elif grid[r][c] == 3:\n                if c > 0 and grid[r][c-1] in [1,4,6]:\n                    union((r, c-1), (r, c))\n                if r < R - 1 and grid[r+1][c] in [2,5,6]:\n                    union((r, c), (r+1, c))\n            elif grid[r][c] == 4:\n                if r < R - 1 and grid[r+1][c] in [2,5,6]:\n                    union((r, c), (r+1, c))\n                if c < C - 1 and grid[r][c+1] in [1,3,5]:\n                    union((r, c), (r, c+1))\n            elif grid[r][c] == 5:\n                if r > 0 and grid[r-1][c] in [2,3,4]:\n                    union((r, c), (r-1, c))\n                if c > 0 and grid[r][c-1] in [1,4,6]:\n                    union((r, c-1), (r, c))\n            elif grid[r][c] == 6:\n                if r > 0 and grid[r-1][c] in [2,3,4]:\n                    union((r, c), (r-1, c))\n                if c < C - 1 and grid[r][c+1] in [1,3,5]:\n                    union((r, c), (r, c+1))\n        \n        \n        for r in range(R):\n            for c in range(C):\n                connect(r, c)\n        \n        return find((0, 0)) == find((R-1, C-1))"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1406", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 3 program that\n\nA parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true:\n\nIt is ().\nIt can be written as AB (A concatenated with B), where A and B are valid parentheses strings.\nIt can be written as (A), where A is a valid parentheses string.\n\nYou are given an m x n matrix of parentheses grid. A valid parentheses string path in the grid is a path satisfying all of the following conditions:\n\nThe path starts from the upper left cell (0, 0).\nThe path ends at the bottom-right cell (m - 1, n - 1).\nThe path only ever moves down or right.\nThe resulting parentheses string formed by the path is valid.\n\nReturn true if there exists a valid parentheses string path in the grid. Otherwise, return false.\n\u00a0\nExample 1:\n\nInput: grid = [[\"(\",\"(\",\"(\"],[\")\",\"(\",\")\"],[\"(\",\"(\",\")\"],[\"(\",\"(\",\")\"]]\nOutput: true\nExplanation: The above diagram shows two possible paths that form valid parentheses strings.\nThe first path shown results in the valid parentheses string \"()(())\".\nThe second path shown results in the valid parentheses string \"((()))\".\nNote that there may be other valid parentheses string paths.\n\nExample 2:\n\nInput: grid = [[\")\",\")\"],[\"(\",\"(\"]]\nOutput: false\nExplanation: The two possible paths form the parentheses strings \"))(\" and \")((\". Since neither of them are valid parentheses strings, we return false.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\ngrid[i][j] is either '(' or ')'.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\n        h,w=len(grid),len(grid[0])\n        g=grid\n        dp=[[set() for _ in range(w)] for _ in range(h)]\n        for y in range(h):\n            for x in range(w):\n                t= 1 if g[y][x]==\"(\" else -1\n                if y==0 and x==0:\n                    if g[y][x]==\"(\":\n                        dp[y][x].add(1)\n                elif y==0: \n                    for a in dp[y][x-1]:\n                        if a+t>=0:\n                            dp[y][x].add(a+t)\n                elif x==0:\n                    for a in dp[y-1][x]:\n                        if a+t>=0:\n                            dp[y][x].add(a+t)\n                else:\n                    for a in dp[y-1][x]:\n                        if a+t>=0:\n                            dp[y][x].add(a+t)\n                    for a in dp[y][x-1]:\n                        if a+t>=0:\n                            dp[y][x].add(a+t)\n        return 0 in dp[h-1][w-1]                            \n                            \n                        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1490", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 script for\n\nGiven a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.\n\u00a0\nExample 1:\n\nInput: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\nExample 2:\nInput: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1\n\nExample 3:\nInput: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def ways(self, pizza, k):\n        \"\"\"\n        :type pizza: List[str]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        M = 10**9 + 7\n        n, m = len(pizza), len(pizza[0])\n        s = [[0]*(m+1) for _ in xrange(n+1)]\n        for i in xrange(n):\n            for j in xrange(m):\n                s[i+1][j+1] = s[i+1][j] + s[i][j+1] - s[i][j]\n                if pizza[i][j] == 'A': s[i+1][j+1] += 1\n        def has_apple(i0, j0, i1, j1):\n            return s[i1][j1] + s[i0][j0] > s[i0][j1] + s[i1][j0]\n        w = [[0]*(m+1) for _ in xrange(n+1)]\n        for i in xrange(n):\n            for j in xrange(m):\n                if has_apple(i, j, n, m):\n                    w[i][j] = 1\n        for _ in xrange(k-1):\n            for i in xrange(n):\n                for j in xrange(m):\n                    t = 0\n                    for ii in xrange(i+1, n):\n                        if not has_apple(i, j, ii, m): continue\n                        t += w[ii][j]\n                    for jj in xrange(j+1, m):\n                        if not has_apple(i, j, n, jj): continue\n                        t += w[i][jj]\n                    w[i][j] = t % M\n        return w[0][0]"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1491", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 3 to\n\nGiven a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.\n\u00a0\nExample 1:\n\nInput: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\nExample 2:\nInput: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1\n\nExample 3:\nInput: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        r = len(pizza)\n        c = len(pizza[0])\n        mod = 1000000007\n        ss = [[0 for i in range(c+2)] for j in range(r+2)]\n        for i in range(r):\n            for j in range(c):\n                ss[i+1][j+1] = int(pizza[i][j]=='A') + ss[i][j+1] + ss[i+1][j] - ss[i][j]\n\n        def valid(i,j,k,m):\n            return ss[k][m] - ss[i-1][m] - ss[k][j-1] + ss[i-1][j-1] > 0\n\n        dp = [[0 for i in range(c+2)] for j in range(r+2)]\n        dp[1][1] = 1\n        for ___ in range(k-1):\n            ndp = [[0 for i in range(c+2)] for j in range(r+2)]\n            for i in range(1,r+1):\n                for j in range(1,c+1):\n                    if dp[i][j] == 0: continue\n                    for k in range(i+1,r+1):\n                        if valid(i,j,k-1,c):\n                            ndp[k][j] += dp[i][j]\n                            if ndp[k][j] >= mod: ndp[k][j] -= mod\n                            \n                    for k in range(j+1,c+1):\n                        if valid(i,j,r,k-1):\n                            ndp[i][k] += dp[i][j]\n                            if ndp[i][k] >= mod: ndp[i][k] -= mod\n            dp = ndp\n        res = 0\n        for i in range(1,r+1):\n            for j in range(1,c+1):\n                if valid(i,j,r,c):\n                    res = (res + dp[i][j]) % mod\n        return res\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1508", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 3 to\n\nTwo strings X\u00a0and Y\u00a0are similar if we can swap two letters (in different positions) of X, so that\u00a0it equals Y. Also two strings X and Y are similar if they are equal.\nFor example, \"tars\"\u00a0and \"rats\"\u00a0are similar (swapping at positions 0 and 2), and \"rats\" and \"arts\" are similar, but \"star\" is not similar to \"tars\", \"rats\", or \"arts\".\nTogether, these form two connected groups by similarity: {\"tars\", \"rats\", \"arts\"} and {\"star\"}.\u00a0 Notice that \"tars\" and \"arts\" are in the same group even though they are not similar.\u00a0 Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\nWe are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?\n\u00a0\nExample 1:\nInput: strs = [\"tars\",\"rats\",\"arts\",\"star\"]\nOutput: 2\n\nExample 2:\nInput: strs = [\"omv\",\"ovm\"]\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= strs.length <= 300\n1 <= strs[i].length <= 300\nstrs[i] consists of lowercase letters only.\nAll words in strs have the same length and are anagrams of each other.\n\n"}, {"role": "assistant", "content": "class WeightedQuickUnionUF:\n    def __init__(self, n):\n        self.count = n\n        self.uid = [i for i in range(n)]\n        self.sz = [1] * n\n        \n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n\n    def find(self, p):\n        while p != self.uid[p]:\n            p = self.uid[p]\n        return p\n    \n    def union(self, p, q):\n        i = self.find(p)\n        j = self.find(q)\n        if i == j: return\n        if self.sz[i] < self.sz[j]: \n            self.uid[i] = j\n            self.sz[j] += self.sz[i]\n        else:\n            self.uid[j] = i\n            self.sz[i] += self.sz[j]\n        self.count -= 1\n\nclass Solution:\n    def numSimilarGroups(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: int\n        \"\"\"\n        uf = WeightedQuickUnionUF(len(A))\n        for i in range(len(A)):\n            for j in range(i+1, len(A)):\n                if self.isSimilar(A[i], A[j]):\n                    uf.union(i, j)\n        return uf.count\n                \n    def isSimilar(self, a, b):\n        i = 0\n        j = len(a) - 1\n        while i < len(a):\n            if a[i] != b[i]:\n                break\n            i += 1\n        while j >= i:\n            if a[j] != b[j]:\n                break\n            j -= 1\n        return a[i] == b[j] and a[j] == b[i] and a[i+1:j] == b[i+1:j]\n    \n    "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1526", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 script for\n\nGiven an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.\n\u00a0\nExample 1:\n\nInput: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\nOutput: 4\nExplanation: After the rain, water is trapped between the blocks.\nWe have two small ponds 1 and 3 units trapped.\nThe total volume of water trapped is 4.\n\nExample 2:\n\nInput: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\nOutput: 10\n\n\u00a0\nConstraints:\n\nm == heightMap.length\nn == heightMap[i].length\n1 <= m, n <= 200\n0 <= heightMap[i][j] <= 2 * 10000\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if len(heightMap) == 0 or len(heightMap[0]) == 0: return 0\n        y, x = len(heightMap), len(heightMap[0])\n        queue = (\n            [(0, i) for i in range(y)] +\n            [(x - 1, i) for i in range(y)] +\n            [(i, 0) for i in range(x)] +\n            [(i, y - 1) for i in range(x)]\n        )\n        level = [[1000000] * x for i in range(y)]\n        for i in range(x):\n            for j in range(y):\n                if (i, j) in queue: level[j][i] = heightMap[j][i]\n        while len(queue):\n            i, j = queue.pop(0)\n            if i > 0:\n                n = max(heightMap[j][i - 1], min(level[j][i - 1], level[j][i]))\n                if level[j][i - 1] != n:\n                    level[j][i - 1] = n\n                    queue.append((i - 1, j))\n            if i < x - 1:\n                n = max(heightMap[j][i + 1], min(level[j][i + 1], level[j][i]))\n                if level[j][i + 1] != n:\n                    level[j][i + 1] = n\n                    queue.append((i + 1, j))\n            if j > 0:\n                n = max(heightMap[j - 1][i], min(level[j - 1][i], level[j][i]))\n                if level[j - 1][i] != n:\n                    level[j - 1][i] = n\n                    queue.append((i, j - 1))\n            if j < y - 1:\n                n = max(heightMap[j + 1][i], min(level[j + 1][i], level[j][i]))\n                if level[j + 1][i] != n:\n                    level[j + 1][i] = n\n                    queue.append((i, j + 1))\n        result = 0\n        for i in range(x):\n            for j in range(y):\n                result += level[j][i] - heightMap[j][i]\n        return result\n\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1536", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 3 program that\n\nYou are given an m x n integer matrix grid and an array queries of size k.\nFind an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:\n\nIf queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.\nOtherwise, you do not get any points, and you end this process.\n\nAfter the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.\nReturn the resulting array answer.\n\u00a0\nExample 1:\n\nInput: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\nOutput: [5,8,1]\nExplanation: The diagrams above show which cells we visit to get points for each query.\nExample 2:\n\nInput: grid = [[5,2,1],[1,1,2]], queries = [3]\nOutput: [0]\nExplanation: We can not get any points because the value of the top left cell is already greater than or equal to 3.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 100000\nk == queries.length\n1 <= k <= 10000\n1 <= grid[i][j], queries[i] <= 1000000\n\n"}, {"role": "assistant", "content": "# \u6807\u51c6\u5e76\u67e5\u96c6\nclass UnionFind:\n    def __init__(self, n):\n        self.root = [i for i in range(n)]\n        self.size = [1] * n\n        self.part = n\n\n    def find(self, x):\n        if x != self.root[x]:\n            # \u5728\u67e5\u8be2\u7684\u65f6\u5019\u5408\u5e76\u5230\u987a\u5e26\u76f4\u63a5\u6839\u8282\u70b9\n            root_x = self.find(self.root[x])\n            self.root[x] = root_x\n            return root_x\n        return x\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        if self.size[root_x] >= self.size[root_y]:\n            root_x, root_y = root_y, root_x\n        self.root[root_x] = root_y\n        self.size[root_y] += self.size[root_x]\n        # \u5c06\u975e\u6839\u8282\u70b9\u7684\u79e9\u8d4b0\n        self.size[root_x] = 0\n        self.part -= 1\n        return True\n\n    def is_connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_root_part(self):\n        # \u83b7\u53d6\u6bcf\u4e2a\u6839\u8282\u70b9\u5bf9\u5e94\u7684\u7ec4\n        part = defaultdict(list)\n        n = len(self.root)\n        for i in range(n):\n            part[self.find(i)].append(i)\n        return part\n\n    def get_root_size(self):\n        # \u83b7\u53d6\u6bcf\u4e2a\u6839\u8282\u70b9\u5bf9\u5e94\u7684\u7ec4\u5927\u5c0f\n        size = defaultdict(int)\n        n = len(self.root)\n        for i in range(n):\n            size[self.find(i)] = self.size[self.find(i)]\n        return size\n    \n    \nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        k = len(queries)\n        ind = list(range(k))\n        ind.sort(key=lambda x: queries[x])\n        dct = []\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if i+1<m:\n                    dct.append([i*n+j,i*n+n+j, max(grid[i][j], grid[i+1][j])])\n                if j+1<n:\n                    dct.append([i * n + j, i * n + 1 + j, max(grid[i][j], grid[i][j+1])])\n        dct.sort(key=lambda x: x[2])\n        uf = UnionFind(m*n)\n        ans = []\n        j = 0\n        length = len(dct)\n        for i in ind:\n            cur = queries[i]\n            while j<length and dct[j][2] < cur:\n                uf.union(dct[j][0], dct[j][1])\n                j += 1\n            if cur > grid[0][0]:\n                ans.append([i,uf.size[uf.find(0)]])\n            else:\n                ans.append([i, 0])\n        ans.sort(key=lambda x: x[0])\n        return [a[1] for a in ans]"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1537", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 program that can\n\nYou are given an m x n integer matrix grid and an array queries of size k.\nFind an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:\n\nIf queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.\nOtherwise, you do not get any points, and you end this process.\n\nAfter the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.\nReturn the resulting array answer.\n\u00a0\nExample 1:\n\nInput: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\nOutput: [5,8,1]\nExplanation: The diagrams above show which cells we visit to get points for each query.\nExample 2:\n\nInput: grid = [[5,2,1],[1,1,2]], queries = [3]\nOutput: [0]\nExplanation: We can not get any points because the value of the top left cell is already greater than or equal to 3.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 100000\nk == queries.length\n1 <= k <= 10000\n1 <= grid[i][j], queries[i] <= 1000000\n\n"}, {"role": "assistant", "content": "class DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n\n    def find(self, a):\n        acopy = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while acopy != a:\n            self.parent[acopy], acopy = a, self.parent[acopy]\n        return a\n\n    def union(self, a, b):\n        a, b = self.find(a), self.find(b)\n        if a != b:\n            if self.size[a] < self.size[b]:\n                a, b = b, a\n\n            self.num_sets -= 1\n            self.parent[b] = a\n            self.size[a] += self.size[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\nclass Solution(object):\n    def maxPoints(self, grid, queries):\n        m = len(grid)\n        n = len(grid[0])\n\n        pts = []\n        for i in range(m):\n            for j in range(n):\n                pts.append((grid[i][j], i, j))\n        pts.sort(key = lambda x: -x[0])\n        \n        UF = DisjointSetUnion(m * n)\n        best = 1\n        \n        ans = {}\n        for v in sorted(queries):\n            while pts and pts[-1][0] < v:\n                w, ii, jj = pts.pop()\n                \n                for di, dj in zip([0,0,-1,1], [1,-1,0,0]):\n                    i2, j2 = ii + di, jj + dj\n        \n                    \n                    if 0 <= i2 < m and 0 <= j2 < n and grid[i2][j2] <= w:\n                        UF.union(n * i2 + j2, n * ii + jj)\n            \n                best = max(best, UF.set_size(n * ii + jj))\n                \n            ans[v] = UF.set_size(0)\n            \n        out = [ans[v] if v > grid[0][0] else 0 for v in queries]\n        return out\n\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1616", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 3 function for\n\nWe had some 2-dimensional coordinates, like \"(1, 3)\" or \"(2, 0.5)\". Then, we removed all commas, decimal points, and spaces and ended up with the string s.\n\nFor example, \"(1, 3)\" becomes s = \"(13)\" and \"(2, 0.5)\" becomes s = \"(205)\".\n\nReturn a list of strings representing all possibilities for what our original coordinates could have been.\nOur original representation never had extraneous zeroes, so we never started with numbers like \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", or any other number that can be represented with fewer digits. Also, a decimal point within a number never occurs without at least one digit occurring before it, so we never started with numbers like \".1\".\nThe final answer list can be returned in any order. All coordinates in the final answer have exactly one space between them (occurring after the comma.)\n\u00a0\nExample 1:\nInput: s = \"(123)\"\nOutput: [\"(1, 2.3)\",\"(1, 23)\",\"(1.2, 3)\",\"(12, 3)\"]\n\nExample 2:\nInput: s = \"(0123)\"\nOutput: [\"(0, 1.23)\",\"(0, 12.3)\",\"(0, 123)\",\"(0.1, 2.3)\",\"(0.1, 23)\",\"(0.12, 3)\"]\nExplanation: 0.0, 00, 0001 or 00.01 are not allowed.\n\nExample 3:\nInput: s = \"(00011)\"\nOutput: [\"(0, 0.011)\",\"(0.001, 1)\"]\n\n\u00a0\nConstraints:\n\n4 <= s.length <= 12\ns[0] == '(' and s[s.length - 1] == ')'.\nThe rest of s are digits.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def ambiguousCoordinates(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        if not S:\n            return []\n\n        res = {}\n        S = S[1:-1]\n        n = len(S)\n        for i in range(1, n):\n            left = S[:i]\n            right = S[i:]\n            if len(left)==1:\n                 for y in range(1, len(right)):\n                    rl = right[:y]\n                    rr = right[y:]\n                    if self.isValidI(left) and self.isValidI(rl) and self.isValidD(rr):\n                        temp = '(%s, %s.%s)' % (left, rl, rr)\n                        res[temp] = True\n            elif len(right)==1:\n                 for x in range(1, len(left)):\n                    ll = left[:x]\n                    lr = left[x:]\n                    if self.isValidI(right) and self.isValidI(ll) and self.isValidD(lr):\n                        temp = '(%s.%s, %s)' % (ll, lr, right)\n                        res[temp] = True\n            else:\n                for x in range(1, len(left)):\n                    for y in range(1, len(right)):\n                        ll = left[:x]\n                        lr = left[x:]\n                        rl = right[:y]\n                        rr = right[y:]\n                        if self.isValidI(left) and self.isValidI(rl) and self.isValidD(rr):\n                            temp = '(%s, %s.%s)' % (left, rl, rr)\n                            res[temp] = True\n                        if self.isValidI(right) and self.isValidI(ll) and self.isValidD(lr):\n                            temp = '(%s.%s, %s)' % (ll, lr, right)\n                            res[temp] = True\n                        if self.isValidI(ll) and self.isValidI(rl) and self.isValidD(lr) and self.isValidD(rr):\n                            temp = '(%s.%s, %s.%s)' % (ll, lr, rl, rr)\n                            res[temp] = True\n\n            if self.isValidI(left) and self.isValidI(right):\n                cur = '(%s, %s)' % (str(left), str(right))\n                res[cur] = True\n\n        rrr = []\n        for k in res.keys():\n            rrr.append(k)\n        return rrr\n\n    def isValidI(self, s):\n        if int(s) == 0 and len(s) > 1:\n            return False\n        if len(s)>1 and s[0] == '0':\n            return False\n        return True\n\n    def isValidD(self, s):\n        if int(s) == 0:\n            return False\n        if s[-1] == '0':\n            return False\n        return True\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1648", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 3 to\n\nYou are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right.\nReturn the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 10^9 + 7.\n\u00a0\nExample 1:\n\nInput: grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3\nOutput: 2\nExplanation: There are two paths where the sum of the elements on the path is divisible by k.\nThe first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3.\nThe second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3.\n\nExample 2:\n\nInput: grid = [[0,0]], k = 5\nOutput: 1\nExplanation: The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5.\n\nExample 3:\n\nInput: grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1\nOutput: 10\nExplanation: Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 5 * 10000\n1 <= m * n <= 5 * 10000\n0 <= grid[i][j] <= 100\n1 <= k <= 50\n\n"}, {"role": "assistant", "content": "class Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        mod = 10 ** 9 + 7\n        n, m = len(grid), len(grid[0])\n        dp = [[[0] * k for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    dp[i][j][grid[i][j] % k] = 1\n                    continue\n                for u in range(k):\n                    if i == 0:\n                        dp[i][j][u] = dp[i][j - 1][(u + k * 100 - grid[i][j]) % k]\n                    elif j == 0:\n                        dp[i][j][u] = dp[i - 1][j][(u + k * 100 - grid[i][j]) % k]\n                    else:\n                        dp[i][j][u] = dp[i][j - 1][(u + k * 100 - grid[i][j]) % k] + dp[i - 1][j][(u + k * 100 - grid[i][j]) % k]\n                    dp[i][j][u] %= mod\n        return dp[-1][-1][0]"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1687", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 3 that\n\nYou are given an array points, an integer angle, and your location, where location = [posx, posy] and points[i] = [xi, yi] both denote integral coordinates on the X-Y plane.\nInitially, you are facing directly east from your position. You cannot move from your position, but you can rotate. In other words, posx and posy cannot be changed. Your field of view in degrees is represented by angle, determining how wide you can see from any given view direction. Let d be the amount in degrees that you rotate counterclockwise. Then, your field of view is the inclusive range of angles [d - angle/2, d + angle/2].\n\nYour browser does not support the video tag or this video format.\n\nYou can see some set of points if, for each point, the angle formed by the point, your position, and the immediate east direction from your position is in your field of view.\nThere can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points.\nReturn the maximum number of points you can see.\n\u00a0\nExample 1:\n\nInput: points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]\nOutput: 3\nExplanation: The shaded region represents your field of view. All points can be made visible in your field of view, including [3,3] even though [2,2] is in front and in the same line of sight.\n\nExample 2:\nInput: points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]\nOutput: 4\nExplanation: All points can be made visible in your field of view, including the one at your location.\n\nExample 3:\n\nInput: points = [[1,0],[2,1]], angle = 13, location = [1,1]\nOutput: 1\nExplanation: You can only see one of the two points, as shown above.\n\n\u00a0\nConstraints:\n\n1 <= points.length <= 100000\npoints[i].length == 2\nlocation.length == 2\n0 <= angle < 360\n0 <= posx, posy, xi, yi <= 100\n\n"}, {"role": "assistant", "content": "class Solution:\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\n        to_ret_base = 0\n        to_ret = 0\n        lx, ly = location\n        pts = []\n        for x, y in points :\n            if x == lx and y == ly :\n                to_ret_base += 1\n                continue\n            db = y-ly\n            lb = x-lx\n            if lb == 0 and db > 0 :\n                pts.append(90)\n            elif lb == 0 and db < 0 :\n                pts.append(-90)\n            elif lb < 0 :\n                lb = -lb\n                arg = math.atan(db/lb)\n                to_append = arg/math.pi*180\n                if to_append > 0 :\n                    to_append = 90 + 90 - to_append\n                elif to_append < 0 :\n                    to_append = -90 + -90 - to_append\n                else :\n                    to_append = 180\n                pts.append(to_append)\n            else :\n                arg = math.atan(db/lb)\n                pts.append(arg/math.pi*180)\n        pts = sorted(pts)\n        pts = pts + [t+360 for t in pts]\n        # print(pts)\n        s, e = -1, 0\n        while e < len(pts) :\n            s += 1\n            while e < len(pts) and pts[e] <= pts[s] + angle :\n                e += 1\n            to_ret = max(e-s, to_ret)\n        return to_ret + to_ret_base"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1703", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 script for\n\nYou are given an integer array nums and an integer k.\nFind the longest subsequence of nums that meets the following requirements:\n\nThe subsequence is strictly increasing and\nThe difference between adjacent elements in the subsequence is at most k.\n\nReturn the length of the longest subsequence that meets the requirements.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\nExample 1:\nInput: nums = [4,2,1,4,3,4,5,8,15], k = 3\nOutput: 5\nExplanation:\nThe longest subsequence that meets the requirements is [1,3,4,5,8].\nThe subsequence has a length of 5, so we return 5.\nNote that the subsequence [1,3,4,5,8,15] does not meet the requirements because 15 - 8 = 7 is larger than 3.\n\nExample 2:\nInput: nums = [7,4,5,1,8,12,4,7], k = 5\nOutput: 4\nExplanation:\nThe longest subsequence that meets the requirements is [4,5,8,12].\nThe subsequence has a length of 4, so we return 4.\n\nExample 3:\nInput: nums = [1,5], k = 1\nOutput: 1\nExplanation:\nThe longest subsequence that meets the requirements is [1].\nThe subsequence has a length of 1, so we return 1.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 100000\n1 <= nums[i], k <= 100000\n\n"}, {"role": "assistant", "content": "class Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        tmp = SegmentTree([0] * (10 ** 5 + 1))\n        for x in nums:\n            note = tmp.query(max(0, x-k), x-1)\n            tmp.update(x, note + 1)\n        return tmp.query(0, 10 ** 5)\n        \nclass SegmentTree:\n    def __init__(self, data, merge=max): \n        '''\n        data:\u4f20\u5165\u7684\u6570\u7ec4\n        merge:\u5904\u7406\u7684\u4e1a\u52a1\u903b\u8f91\uff0c\u4f8b\u5982\u6c42\u548c/\u6700\u5927\u503c/\u6700\u5c0f\u503c\uff0clambda\u8868\u8fbe\u5f0f\n        '''\n\n        self.data = data\n        self.n = len(data)\n        #  \u7533\u8bf74\u500ddata\u957f\u5ea6\u7684\u7a7a\u95f4\u6765\u5b58\u7ebf\u6bb5\u6811\u8282\u70b9\n        self.tree = [None] * (4 * self.n) # \u7d22\u5f15i\u7684\u5de6\u5b69\u5b50\u7d22\u5f15\u4e3a2i+1\uff0c\u53f3\u5b69\u5b50\u4e3a2i+2\n        self._merge = merge\n        if self.n:\n            self._build(0, 0, self.n-1)\n\n\n    def query(self, ql, qr):\n        '''\n        \u8fd4\u56de\u533a\u95f4[ql,..,qr]\u7684\u503c\n        '''\n        return self._query(0, 0, self.n-1, ql, qr)\n\n    def update(self, index, value):\n        # \u5c06data\u6570\u7ec4index\u4f4d\u7f6e\u7684\u503c\u66f4\u65b0\u4e3avalue,\u7136\u540e\u9012\u5f52\u66f4\u65b0\u7ebf\u6bb5\u6811\u4e2d\u88ab\u5f71\u54cd\u7684\u5404\u8282\u70b9\u7684\u503c\n        self.data[index] = value\n        self._update(0, 0, self.n-1, index)\n\n    def _build(self, tree_index, l, r):\n        '''\n        \u9012\u5f52\u521b\u5efa\u7ebf\u6bb5\u6811\n        tree_index : \u7ebf\u6bb5\u6811\u8282\u70b9\u5728\u6570\u7ec4\u4e2d\u4f4d\u7f6e\n        l, r : \u8be5\u8282\u70b9\u8868\u793a\u7684\u533a\u95f4\u7684\u5de6,\u53f3\u8fb9\u754c\n        '''\n        if l == r:\n            self.tree[tree_index] = self.data[l]\n            return\n        mid = (l+r) // 2 # \u533a\u95f4\u4e2d\u70b9,\u5bf9\u5e94\u5de6\u5b69\u5b50\u533a\u95f4\u7ed3\u675f,\u53f3\u5b69\u5b50\u533a\u95f4\u5f00\u5934\n        left, right = 2 * tree_index + 1, 2 * tree_index + 2 # tree_index\u7684\u5de6\u53f3\u5b50\u6811\u7d22\u5f15\n        self._build(left, l, mid)\n        self._build(right, mid+1, r)\n        self.tree[tree_index] = self._merge(self.tree[left], self.tree[right])\n\n    def _query(self, tree_index, l, r, ql, qr):\n        '''\n        \u9012\u5f52\u67e5\u8be2\u533a\u95f4[ql,..,qr]\u7684\u503c\n        tree_index : \u67d0\u4e2a\u6839\u8282\u70b9\u7684\u7d22\u5f15\n        l, r : \u8be5\u8282\u70b9\u8868\u793a\u7684\u533a\u95f4\u7684\u5de6\u53f3\u8fb9\u754c\n        ql, qr: \u5f85\u67e5\u8be2\u533a\u95f4\u7684\u5de6\u53f3\u8fb9\u754c\n        '''\n        if l == ql and r == qr:\n            return self.tree[tree_index]\n\n        mid = (l+r) // 2 # \u533a\u95f4\u4e2d\u70b9,\u5bf9\u5e94\u5de6\u5b69\u5b50\u533a\u95f4\u7ed3\u675f,\u53f3\u5b69\u5b50\u533a\u95f4\u5f00\u5934\n        left, right = tree_index * 2 + 1, tree_index * 2 + 2\n        if qr <= mid:\n            # \u67e5\u8be2\u533a\u95f4\u5168\u5728\u5de6\u5b50\u6811\n            return self._query(left, l, mid, ql, qr)\n        elif ql > mid:\n            # \u67e5\u8be2\u533a\u95f4\u5168\u5728\u53f3\u5b50\u6811\n            return self._query(right, mid+1, r, ql, qr)\n\n        # \u67e5\u8be2\u533a\u95f4\u4e00\u90e8\u5206\u5728\u5de6\u5b50\u6811\u4e00\u90e8\u5206\u5728\u53f3\u5b50\u6811\n        return self._merge(self._query(left, l, mid, ql, mid), \n                          self._query(right, mid+1, r, mid+1, qr))\n\n    def _update(self, tree_index, l, r, index):\n        '''\n        tree_index:\u67d0\u4e2a\u6839\u8282\u70b9\u7d22\u5f15\n        l, r : \u6b64\u6839\u8282\u70b9\u4ee3\u8868\u533a\u95f4\u7684\u5de6\u53f3\u8fb9\u754c\n        index : \u66f4\u65b0\u7684\u503c\u7684\u7d22\u5f15\n        '''\n        if l == r == index:\n            self.tree[tree_index] = self.data[index]\n            return\n        mid = (l+r)//2\n        left, right = 2 * tree_index + 1, 2 * tree_index + 2\n        if index > mid:\n            # \u8981\u66f4\u65b0\u7684\u533a\u95f4\u5728\u53f3\u5b50\u6811\n            self._update(right, mid+1, r, index)\n        else:\n            # \u8981\u66f4\u65b0\u7684\u533a\u95f4\u5728\u5de6\u5b50\u6811index<=mid\n            self._update(left, l, mid, index)\n        # \u91cc\u9762\u7684\u5c0f\u533a\u95f4\u53d8\u5316\u4e86\uff0c\u5305\u88f9\u7684\u5927\u533a\u95f4\u4e5f\u8981\u66f4\u65b0\n        self.tree[tree_index] = self._merge(self.tree[left], self.tree[right])"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1736", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 2 function for\n\nA k-mirror number is a positive integer without leading zeros that reads the same both forward and backward in base-10 as well as in base-k.\n\nFor example, 9 is a 2-mirror number. The representation of 9 in base-10 and base-2 are 9 and 1001 respectively, which read the same both forward and backward.\nOn the contrary, 4 is not a 2-mirror number. The representation of 4 in base-2 is 100, which does not read the same both forward and backward.\n\nGiven the base k and the number n, return the sum of the n smallest k-mirror numbers.\n\u00a0\nExample 1:\nInput: k = 2, n = 5\nOutput: 25\nExplanation:\nThe 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows:\n  base-10    base-2\n    1          1\n    3          11\n    5          101\n    7          111\n    9          1001\nTheir sum = 1 + 3 + 5 + 7 + 9 = 25. \n\nExample 2:\nInput: k = 3, n = 7\nOutput: 499\nExplanation:\nThe 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows:\n  base-10    base-3\n    1          1\n    2          2\n    4          11\n    8          22\n    121        11111\n    151        12121\n    212        21212\nTheir sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499.\n\nExample 3:\nInput: k = 7, n = 17\nOutput: 20379000\nExplanation: The 17 smallest 7-mirror numbers are:\n1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596\n\n\u00a0\nConstraints:\n\n2 <= k <= 9\n1 <= n <= 30\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def kMirror(self, k, n):\n        \"\"\"\n        :type k: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        bs = [0]*128\n        def fit(v):\n            i=0\n            while v:\n                bs[i]=v%k\n                v/=k\n                i+=1\n            j=0\n            i-=1\n            while j<i:\n                if bs[j]!=bs[i]: return False\n                j+=1\n                i-=1\n            return True\n        ds = [0]*128\n        r  =[]\n        def dfs(v, b1, b2):\n            if len(r) >= n: return\n            if b1>b2:\n                if fit(v): r.append(v)\n                return\n            if b1==b2:\n                if b1==1:\n                    for i in range(1, 10):\n                        dfs(v+b1*i, b1*10, b2/10)\n                else:\n                    for i in range(0, 10):\n                        dfs(v+b1*i, b1*10, b2/10)\n            else:\n                if b1==1:\n                    for i in range(1, 10):\n                        dfs(v+b1*i+b2*i, b1*10, b2/10)\n                else:\n                    for i in range(0, 10):\n                        dfs(v+b1*i+b2*i, b1*10, b2/10)\n        i=1\n        while True:\n            if len(r)>=n: break\n            dfs(0, 1, i)\n            i*=10\n        # print r\n        return sum(r[:n])\n            "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1740", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 function for\n\nYou are given an integer array arr. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.\nYou may jump forward from index i to index j (with i < j) in the following way:\n\nDuring odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index j such that arr[i] <= arr[j] and arr[j] is the smallest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.\nDuring even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index j such that arr[i] >= arr[j] and arr[j] is the largest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.\nIt may be the case that for some index i, there are no legal jumps.\n\nA starting index is good if, starting from that index, you can reach the end of the array (index arr.length - 1) by jumping some number of times (possibly 0 or more than once).\nReturn the number of good starting indices.\n\u00a0\nExample 1:\nInput: arr = [10,13,12,14,15]\nOutput: 2\nExplanation: \nFrom starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.\nFrom starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\nFrom starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\nFrom starting index i = 4, we have reached the end already.\nIn total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of\njumps.\n\nExample 2:\nInput: arr = [2,3,1,1,4]\nOutput: 3\nExplanation: \nFrom starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\nDuring our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].\nDuring our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\nDuring our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].\nWe can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can't jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some\nnumber of jumps.\n\nExample 3:\nInput: arr = [5,1,3,4,2]\nOutput: 3\nExplanation: We can reach the end from starting indices 1, 2, and 4.\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 2 * 10000\n0 <= arr[i] < 100000\n\n"}, {"role": "assistant", "content": "import bisect\n\nclass Solution:\n    def oddEvenJumps(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        a = A\n        n = len(a)\n\n        p = [None for _ in range(n)]\n        v = []\n        idx = {}\n        for i in range(n)[::-1]:\n            if i != n - 1:\n                if a[i] in idx:\n                    p[i] = idx[a[i]]\n                elif a[i] > v[-1]:\n                    p[i] = None\n                else:\n                    tmp = bisect.bisect(v, a[i])\n                    p[i] = idx[v[tmp]]\n                    \n            if a[i] not in idx:\n                bisect.insort(v, a[i])\n            idx[a[i]] = i\n\n        q = [None for _ in range(n)]\n        v = []\n        idx = {}\n        for i in range(n)[::-1]:\n            if i != n - 1:\n                if a[i] in idx:\n                    q[i] = idx[a[i]]\n                elif a[i] < v[0]:\n                    q[i] = None\n                else:\n                    tmp = bisect.bisect(v, a[i])\n                    q[i] = idx[v[tmp - 1]]\n                    \n            if a[i] not in idx:\n                bisect.insort(v, a[i])\n            idx[a[i]] = i\n        \n        # print(p)\n        # print(q)\n\n        pvalid = [None for _ in range(n)]\n        qvalid = [None for _ in range(n)]\n        pvalid[-1] = qvalid[-1] = True\n        ans = 1\n        for i in range(n - 1)[::-1]:\n            pvalid[i] = False if p[i] is None else qvalid[p[i]]\n            qvalid[i] = False if q[i] is None else pvalid[q[i]]\n        \n\n            # print(i, pvalid[i], qvalid[i])\n            ans += pvalid[i]\n        return ans\n\n\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1760", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 program that can\n\nYou are given a valid boolean expression as a string expression consisting of the characters '1','0','&' (bitwise AND operator),'|' (bitwise OR operator),'(', and ')'.\n\nFor example, \"()1|1\" and \"(1)&()\" are not valid while \"1\", \"(((1))|(0))\", and \"1|(0&(1))\" are valid expressions.\n\nReturn the minimum cost to change the final value of the expression.\n\nFor example, if expression = \"1|1|(0&0)&1\", its value is 1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1. We want to apply operations so that the new expression evaluates to 0.\n\nThe cost of changing the final value of an expression is the number of operations performed on the expression. The types of operations are described as follows:\n\nTurn a '1' into a '0'.\nTurn a '0' into a '1'.\nTurn a '&' into a '|'.\nTurn a '|' into a '&'.\n\nNote: '&' does not take precedence over '|' in the order of calculation. Evaluate parentheses first, then in left-to-right order.\n\u00a0\nExample 1:\nInput: expression = \"1&(0|1)\"\nOutput: 1\nExplanation: We can turn \"1&(0|1)\" into \"1&(0&1)\" by changing the '|' to a '&' using 1 operation.\nThe new expression evaluates to 0. \n\nExample 2:\nInput: expression = \"(0&0)&(0&0&0)\"\nOutput: 3\nExplanation: We can turn \"(0&0)&(0&0&0)\" into \"(0|1)|(0&0&0)\" using 3 operations.\nThe new expression evaluates to 1.\n\nExample 3:\nInput: expression = \"(0|(1|0&1))\"\nOutput: 1\nExplanation: We can turn \"(0|(1|0&1))\" into \"(0|(0|0&1))\" using 1 operation.\nThe new expression evaluates to 0.\n\u00a0\nConstraints:\n\n1 <= expression.length <= 100000\nexpression\u00a0only contains\u00a0'1','0','&','|','(', and\u00a0')'\nAll parentheses\u00a0are properly matched.\nThere will be no empty parentheses (i.e:\u00a0\"()\"\u00a0is not a substring of\u00a0expression).\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def minOperationsToFlip(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: int\n        \"\"\"\n        e = expression\n        n = len(expression)\n        class Node(object):\n            def __init__(self, t, v, left=None, right=None):\n                self.t=t;\n                self.v=v;\n                self.l=left\n                self.r=right\n                self.vv=None\n                self.dp = None\n            def eval(self):\n                if self.vv is not None:\n                    return self.vv\n                if self.t==0:\n                    self.vv = self.v\n                else:\n                    v1=self.l.eval()\n                    v2=self.r.eval()\n                    if self.v=='&':\n                        self.vv = v1&v2\n                    else:\n                        self.vv = v1|v2\n                return self.vv\n            \n            def dfs(self):\n                if self.dp is not None: return self.dp\n                r = -1\n                if self.t==0:\n                    r = 1\n                else:\n                    v1=self.l.eval()\n                    v2=self.r.eval()\n                    if self.v=='&':\n                        if self.vv==1:\n                            t = self.l.dfs()\n                            if r<0 or r>t: r=t\n                            t = self.r.dfs()\n                            if r<0 or r>t: r=t\n                        else:\n                            if v1==1:\n                                t = self.r.dfs()\n                                if r<0 or r>t: r=t\n                            elif v2==1:\n                                t = self.l.dfs()\n                                if r<0 or r>t: r=t\n                            else:\n                                t = self.r.dfs()+self.l.dfs()\n                                if r<0 or r>t: r=t\n                        # change to |\n                        vv = v1|v2\n                        if vv==self.vv:\n                            if self.vv==0:\n                                t = self.l.dfs()+1\n                                if r<0 or r>t: r=t\n                                t = self.r.dfs()+1\n                                if r<0 or r>t: r=t\n                            else:\n                                if v1==0:\n                                    t = self.l.dfs()+1\n                                    if r<0 or r>t: r=t\n                                elif v2==0:\n                                    t = self.r.dfs()+1\n                                    if r<0 or r>t: r=t\n                                else:\n                                    t = self.r.dfs()+self.l.dfs()+1\n                                    if r<0 or r>t: r=t\n                        else: r=1\n                        \n                    else:\n                        if self.vv==0:\n                            t = self.l.dfs()\n                            if r<0 or r>t: r=t\n                            t = self.r.dfs()\n                            if r<0 or r>t: r=t\n                        else:\n                            if v1==0:\n                                t = self.l.dfs()\n                                if r<0 or r>t: r=t\n                            elif v2==0:\n                                t = self.r.dfs()\n                                if r<0 or r>t: r=t\n                            else:\n                                t = self.r.dfs()+self.l.dfs()\n                                if r<0 or r>t: r=t\n                        vv = v1&v2\n                        if vv==self.vv:\n                            if self.vv==1:\n                                t = self.l.dfs()+1\n                                if r<0 or r>t: r=t\n                                t = self.r.dfs()+1\n                                if r<0 or r>t: r=t\n                            else:\n                                if v1==1:\n                                    t = self.r.dfs()+1\n                                    if r<0 or r>t: r=t\n                                elif v2==1:\n                                    t = self.l.dfs()+1\n                                    if r<0 or r>t: r=t\n                                else:\n                                    t = self.r.dfs()+self.l.dfs()+1\n                                    if r<0 or r>t: r=t\n                        else: r=1\n                                \n                self.dp = r\n                return r\n                \n                            \n                            \n                            \n                        \n        def build(i):\n            n1 = None\n            while True:\n                cn = None\n                if i>=n: break\n                if e[i]=='1':\n                    cn = Node(0, 1)\n                    i+=1\n                elif e[i]=='0':\n                    cn = Node(0, 0)\n                    i+=1\n                elif e[i]=='(':\n                    cn, i = build(i+1)\n                    i+=1\n                elif e[i]==')': break\n                elif e[i]=='&' or e[i]=='|':\n                    op = e[i]\n                    i+=1\n                if cn:\n                    if n1==None:\n                        n1=cn\n                    else:\n                        n1 = Node(1, op, n1, cn)\n            return n1, i\n        n, _ = build(0)\n        n.eval()\n        return n.dfs()"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1841", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 function for\n\nYou are given a 0-indexed binary string s and two integers minJump and maxJump. In the beginning, you are standing at index 0, which is equal to '0'. You can move from index i to index j if the following conditions are fulfilled:\n\ni + minJump <= j <= min(i + maxJump, s.length - 1), and\ns[j] == '0'.\n\nReturn true if you can reach index s.length - 1 in s, or false otherwise.\n\u00a0\nExample 1:\nInput: s = \"011010\", minJump = 2, maxJump = 3\nOutput: true\nExplanation:\nIn the first step, move from index 0 to index 3. \nIn the second step, move from index 3 to index 5.\n\nExample 2:\nInput: s = \"01101110\", minJump = 2, maxJump = 3\nOutput: false\n\n\u00a0\nConstraints:\n\n2 <= s.length <= 100000\ns[i] is either '0' or '1'.\ns[0] == '0'\n1 <= minJump <= maxJump < s.length\n\n"}, {"role": "assistant", "content": "class NumArray:\n    def __init__(self, nums: List[int]):\n        self.raw = [t for t in nums]\n        T = 2\n        while T <= len(nums) :\n            for i in range(T, len(nums)+1, T) :\n                nums[i-1] += nums[i-1-T//2]\n            T = T * 2\n        self.nums = nums\n        self.lowbit = lambda x : x&(-x)\n\n    def update(self, index: int, val: int) -> None:\n        dis = val - self.raw[index]\n        self.raw[index] = val\n        while index < len(self.nums) :\n            self.nums[index] += dis\n            index += self.lowbit(index+1)\n\n    def presums(self, index) :\n        to_ret = 0\n        while index >= 0 :\n            to_ret += self.nums[index]\n            index -= self.lowbit(index+1)\n        return to_ret\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.presums(right)-self.presums(left-1)\n        \nclass Solution:\n    def canReach(self, ss: str, minJump: int, maxJump: int) -> bool:\n        na = NumArray([0]*len(ss))\n        na.update(0, 1)\n        for i, t in enumerate(ss) :\n            if i == 0 :\n                continue\n            if t == '1' :\n                continue\n            if i - minJump < 0 :\n                continue\n            s, e = max(0, i-maxJump), i-minJump\n            t = na.sumRange(s, e)\n            if t > 0 :\n                if i == len(ss) - 1 :\n                    return True\n                na.update(i, 1)\n            # print(na.raw)\n        return False"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1847", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 3 to\n\nGiven an array arr that represents a permutation of numbers from 1 to n.\nYou have a binary string of size n that initially has all its bits set to zero. At each step i (assuming both the binary string and arr are 1-indexed) from 1 to n, the bit at position arr[i] is set to 1.\nYou are also given an integer m. Find the latest step at which there exists a group of ones of length m. A group of ones is a contiguous substring of 1's such that it cannot be extended in either direction.\nReturn the latest step at which there exists a group of ones of length exactly m. If no such group exists, return -1.\n\u00a0\nExample 1:\nInput: arr = [3,5,1,2,4], m = 1\nOutput: 4\nExplanation: \nStep 1: \"00100\", groups: [\"1\"]\nStep 2: \"00101\", groups: [\"1\", \"1\"]\nStep 3: \"10101\", groups: [\"1\", \"1\", \"1\"]\nStep 4: \"11101\", groups: [\"111\", \"1\"]\nStep 5: \"11111\", groups: [\"11111\"]\nThe latest step at which there exists a group of size 1 is step 4.\n\nExample 2:\nInput: arr = [3,1,5,4,2], m = 2\nOutput: -1\nExplanation: \nStep 1: \"00100\", groups: [\"1\"]\nStep 2: \"10100\", groups: [\"1\", \"1\"]\nStep 3: \"10101\", groups: [\"1\", \"1\", \"1\"]\nStep 4: \"10111\", groups: [\"1\", \"111\"]\nStep 5: \"11111\", groups: [\"11111\"]\nNo group of size 2 exists during any step.\n\n\u00a0\nConstraints:\n\nn == arr.length\n1 <= m <= n <= 100000\n1 <= arr[i] <= n\nAll integers in arr are distinct.\n\n"}, {"role": "assistant", "content": "class UnionFindSet:\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.ranks = [1] * n\n        \n    def find(self, u):\n        if u != self.parents[u]:\n            self.parents[u] = self.find(self.parents[u])\n        return self.parents[u]\n    \n    def union(self, u, v):\n        pu, pv = self.find(u), self.find(v)\n        if pu == pv:\n            return False\n        if self.ranks[pu] > self.ranks[pv]:\n            self.parents[pv] = pu\n            self.ranks[pu] += self.ranks[pv]\n        elif self.ranks[pv] > self.ranks[pu]:\n            self.parents[pu] = pv\n            self.ranks[pv] += self.ranks[pu]\n        else:\n            self.parents[pu] = pv\n            self.ranks[pv] += self.ranks[pu]\n        return True\n    \n\nclass Solution:\n    def findLatestStep(self, arr: List[int], m: int) -> int:\n        n = len(arr)\n        uf = UnionFindSet(n)\n        b_arr = [0] * n\n        ans = -1\n        for step, num in enumerate(arr):\n            idx = num - 1\n            b_arr[idx] = 1\n            if idx > 0 and b_arr[idx - 1]:\n                p = uf.find(idx - 1)\n                if uf.ranks[p] == m:\n                    ans = step\n                uf.union(idx, idx - 1)\n            if idx < n - 1 and b_arr[idx + 1]:\n                p = uf.find(idx + 1)\n                if uf.ranks[p] == m:\n                    ans = step\n                uf.union(idx, idx + 1)\n            p = uf.find(idx)\n            if uf.ranks[p] == m:\n                ans = step + 1\n                \n        for idx in range(n):\n            p = uf.find(idx)\n            if uf.ranks[p] == m:\n                return n\n            \n        return ans"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_1936", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 function for\n\nGiven an equation, represented by words on the left side and the result on the right side.\nYou need to check if the equation is solvable under the following rules:\n\nEach character is decoded as one digit (0 - 9).\nNo two characters can map to the same digit.\nEach words[i] and result are decoded as one number without leading zeros.\nSum of numbers on the left side (words) will equal to the number on the right side (result).\n\nReturn true if the equation is solvable, otherwise return false.\n\u00a0\nExample 1:\nInput: words = [\"SEND\",\"MORE\"], result = \"MONEY\"\nOutput: true\nExplanation: Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'\nSuch that: \"SEND\" + \"MORE\" = \"MONEY\" ,  9567 + 1085 = 10652\nExample 2:\nInput: words = [\"SIX\",\"SEVEN\",\"SEVEN\"], result = \"TWENTY\"\nOutput: true\nExplanation: Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4\nSuch that: \"SIX\" + \"SEVEN\" + \"SEVEN\" = \"TWENTY\" ,  650 + 68782 + 68782 = 138214\nExample 3:\nInput: words = [\"LEET\",\"CODE\"], result = \"POINT\"\nOutput: false\nExplanation: There is no possible mapping to satisfy the equation, so we return false.\nNote that two different characters cannot map to the same digit.\n\n\u00a0\nConstraints:\n\n2 <= words.length <= 5\n1 <= words[i].length, result.length <= 7\nwords[i], result contain only uppercase English letters.\nThe number of different characters used in the expression is at most 10.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def isSolvable(self, words, result):\n        unique = set()\n        for word in words:\n            for letter in word:\n                unique.add(letter)\n        for letter in result:\n            unique.add(letter)\n        unique = sorted(unique)\n        assignedinv = [None] * 10\n        assigned = {}\n        ordA = ord('A')\n        \n        K = max(len(word) for word in words)\n        K = max(K, len(result))\n        def search(ii, bal):\n            if ii == K:\n                if bal: return False\n                # check 0 prefix\n                for word in words:\n                    if len(word) > 1:\n                        first = word[0]\n                        if assigned[first] == 0:\n                            return False\n                if len(result) > 1:\n                    first = result[0]\n                    if assigned[first] == 0:\n                        return False\n                return True\n\n            # 'S'-> 6, 'I'->5, 'X'->0, 'E'->8,\n            # 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4\n            \n            unassigned = [0] * 26\n            for word in words:\n                if ii >= len(word): continue\n                letter = word[len(word) - 1 - ii]\n                d = assigned.get(letter, -1)\n                if d == -1:\n                    unassigned[ord(letter) - ordA] += 1\n                else:\n                    bal += d\n            \n            if ii < len(result):\n                letter = result[len(result) - 1- ii]\n                d = assigned.get(letter, -1)\n                if d == -1:\n                    unassigned[ord(letter) - ordA] -= 1\n                else:\n                    bal -= d\n            \n            free = [d for d, have in enumerate(assignedinv) if have is None]\n            toassign = [ci for ci, x in enumerate(unassigned) if x]\n\n\n            for choice in itertools.permutations(free, len(toassign)):\n                # assign digit choice[i] to charindex toassign[i]\n                \n                baldelta = 0\n                for i, d in enumerate(choice):\n                    ci = toassign[i]\n                    c = chr(ordA + ci)\n                    assignedinv[d] = c\n                    assigned[c] = d\n                    baldelta += unassigned[ci] * d\n                #print 'c', choice, baldelta\n                bal += baldelta\n                if bal % 10 == 0:\n                    #if ii == 0: print (\"!\", choice)\n                    if search(ii+1, bal // 10): return True\n                bal -= baldelta\n                for i, d in enumerate(choice):\n                    ci = toassign[i]\n                    c = chr(ordA + ci)\n                    assignedinv[d] = None\n                    del assigned[c]\n            if len(toassign) == 0 and bal % 10 == 0:\n                search(ii+1, bal // 10)\n            return False\n        \n        return search(0, 0)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2012", "label": "code_high", "messages": [{"role": "user", "content": "Can you implement a function in Python 2 that\n\nYou are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\nYou are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time.\nReturn the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 10^9 + 7.\n\u00a0\nExample 1:\n\nInput: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\nOutput: 4\nExplanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 \u279d 6\n- 0 \u279d 4 \u279d 6\n- 0 \u279d 1 \u279d 2 \u279d 5 \u279d 6\n- 0 \u279d 1 \u279d 3 \u279d 5 \u279d 6\n\nExample 2:\nInput: n = 2, roads = [[1,0,10]]\nOutput: 1\nExplanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n\n\u00a0\nConstraints:\n\n1 <= n <= 200\nn - 1 <= roads.length <= n * (n - 1) / 2\nroads[i].length == 3\n0 <= ui, vi <= n - 1\n1 <= timei <= 10^9\nui != vi\nThere is at most one road connecting any two intersections.\nYou can reach any intersection from any other intersection.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def countPaths(self, n, roads):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        nei = {}\n        for a, b, c in roads:\n            if a not in nei: nei[a]=[]\n            nei[a].append((b,c))\n            if b not in nei: nei[b]=[]\n            nei[b].append((a,c))\n        dis = [-1]*n\n        dis[0]=0\n        inq = set()\n        q = deque()\n        q.append(0)\n        inq.add(0)\n        mod  = 1000000007\n        while q:\n            a= q.popleft()\n            inq.remove(a)\n            if a not in nei: continue\n            for b, c in nei[a]:\n                d = dis[a]+c\n                if dis[b]==-1 or dis[b]>d:\n                    dis[b]=d\n                    if b not in inq:\n                        inq.add(b)\n                        q.append(b)\n        dp = {}\n        def dfs(s):\n            if s==0: return 1\n            if s in dp: return dp[s]\n            if s not in nei: return 0\n            r = 0\n            for b, c in nei[s]:\n                if dis[s]==dis[b]+c:\n                    r+=dfs(b)\n                    r %= mod\n            dp[s]=r\n            return r\n        return dfs(n-1)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2014", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 2 to\n\nThere is a 2D grid of size n x n where each cell of this grid has a lamp that is initially turned off.\nYou are given a 2D array of lamp positions lamps, where lamps[i] = [rowi, coli] indicates that the lamp at grid[rowi][coli] is turned on. Even if the same lamp is listed more than once, it is turned on.\nWhen a lamp is turned on, it illuminates its cell and all other cells in the same row, column, or diagonal.\nYou are also given another 2D array queries, where queries[j] = [rowj, colj]. For the jth query, determine whether grid[rowj][colj] is illuminated or not. After answering the jth query, turn off the lamp at grid[rowj][colj] and its 8 adjacent lamps if they exist. A lamp is adjacent if its cell shares either a side or corner with grid[rowj][colj].\nReturn an array of integers ans, where ans[j] should be 1 if the cell in the jth query was illuminated, or 0 if the lamp was not.\n\u00a0\nExample 1:\n\nInput: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]\nOutput: [1,0]\nExplanation: We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid[0][0] then turning on the lamp at grid[4][4].\nThe 0th\u00a0query asks if the lamp at grid[1][1] is illuminated or not (the blue square). It is illuminated, so set ans[0] = 1. Then, we turn off all lamps in the red square.\n\nThe 1st\u00a0query asks if the lamp at grid[1][0] is illuminated or not (the blue square). It is not illuminated, so set ans[1] = 0. Then, we turn off all lamps in the red rectangle.\n\n\nExample 2:\nInput: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]\nOutput: [1,1]\n\nExample 3:\nInput: n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]\nOutput: [1,1,0]\n\n\u00a0\nConstraints:\n\n1 <= n <= 10^9\n0 <= lamps.length <= 20000\n0 <= queries.length <= 20000\nlamps[i].length == 2\n0 <= rowi, coli < n\nqueries[j].length == 2\n0 <= rowj, colj < n\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def gridIllumination(self, N, lamps, queries):\n        \"\"\"\n        :type N: int\n        :type lamps: List[List[int]]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        rows = dict()\n        cols = dict()\n        diags1 = dict()\n        diags2 = dict()\n        for x, y in lamps:\n            if x not in rows: rows[x] = set()\n            rows[x].add(y)\n            if y not in cols: cols[y] = set()\n            cols[y].add(x)\n            if x + y not in diags1: diags1[x + y] = set()\n            diags1[x + y].add(x)\n            if x - y not in diags2: diags2[x - y] = set()\n            diags2[x - y].add(x)\n        rtn = []\n        for x, y in queries:\n            # Get the answer\n            if x in rows or y in cols or x + y in diags1 or x - y in diags2:\n                rtn.append(1)\n            else:\n                rtn.append(0)\n            # Turn off the lights\n            for dx in range(-1, 2):\n                for dy in range(-1, 2):\n                    newx = x + dx\n                    newy = y + dy\n                    if 0 <= newx < N and 0 <= newy < N and newx in rows and newy in rows[newx]:\n                        rows[newx].remove(newy)\n                        if not rows[newx]: del rows[newx]\n                        cols[newy].remove(newx)\n                        if not cols[newy]: del cols[newy]\n                        diags1[newx + newy].remove(newx)\n                        if not diags1[newx + newy]: del diags1[newx + newy]\n                        diags2[newx - newy].remove(newx)\n                        if not diags2[newx - newy]: del diags2[newx - newy]\n        return rtn"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2042", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 program that can\n\nA Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as half-open intervals and query about them.\nA half-open interval [left, right) denotes all the real numbers x where left <= x < right.\nImplement the RangeModule class:\n\nRangeModule() Initializes the object of the data structure.\nvoid addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.\nboolean queryRange(int left, int right) Returns true if every real number in the interval [left, right) is currently being tracked, and false otherwise.\nvoid removeRange(int left, int right) Stops tracking every real number currently being tracked in the half-open interval [left, right).\n\n\u00a0\nExample 1:\nInput\n[\"RangeModule\", \"addRange\", \"removeRange\", \"queryRange\", \"queryRange\", \"queryRange\"]\n[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]\nOutput\n[null, null, null, true, false, true]\n\nExplanation\nRangeModule rangeModule = new RangeModule();\nrangeModule.addRange(10, 20);\nrangeModule.removeRange(14, 16);\nrangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is being tracked)\nrangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)\nrangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is still being tracked, despite the remove operation)\n\n\u00a0\nConstraints:\n\n1 <= left < right <= 10^9\nAt most 10000 calls will be made to addRange, queryRange, and removeRange.\n\n"}, {"role": "assistant", "content": "import bisect\n\nclass RangeModule(object):\n\n    def __init__(self):\n        self.ranges=[]\n        \n\n    def addRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: void\n        \"\"\"\n        \n        #print self.ranges,left,right\n        \n        if len(self.ranges)==0:\n            self.ranges=[left,right]\n        else:\n            lefti=bisect.bisect_left(self.ranges,left)\n            righti=bisect.bisect_right(self.ranges,right)\n            \n            \n            if lefti%2==0:\n                if lefti==len(self.ranges):\n                    self.ranges.append(left)\n                    self.ranges.append(right)\n                else:\n                    if righti==0:\n                        self.ranges=[left,right]+self.ranges\n                    else:\n                        if righti%2==0:\n                            self.ranges=self.ranges[:lefti]+[left,right]+self.ranges[righti:]\n                        else:\n                            self.ranges=self.ranges[:lefti]+[left]+self.ranges[righti:]\n            else:\n                \n                if lefti==righti and lefti<len(self.ranges):\n                    return\n                \n                if righti%2==0:\n                    self.ranges=self.ranges[:lefti]+[right]+self.ranges[righti:]\n                else:\n                    self.ranges=self.ranges[:lefti]+self.ranges[righti:]\n                \n        \n    def queryRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: bool\n        \"\"\"\n        #print \"query\",self.ranges,left,right\n        \n        if len(self.ranges)==0:\n            return False\n        \n        lefti=bisect.bisect_right(self.ranges,left)\n        righti=bisect.bisect_left(self.ranges,right)\n        \n        return lefti==righti and lefti%2==1\n        \n        \n\n    def removeRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: void\n        \"\"\"\n        #print \"remove\",self.ranges,left,right\n        \n        if len(self.ranges)>0:\n            lefti=bisect.bisect_left(self.ranges,left)\n            righti=bisect.bisect_right(self.ranges,right)\n            \n            if lefti%2==0:\n                if lefti==len(self.ranges):\n                    return\n                else:\n                    if righti==0:\n                        return\n                    else:\n                        if righti%2==0:\n                            self.ranges=self.ranges[:lefti]+self.ranges[righti:]\n                        else:\n                            self.ranges=self.ranges[:lefti]+[right]+self.ranges[righti:]\n            else:\n                if righti%2==0:\n                    self.ranges=self.ranges[:lefti]+[left]+self.ranges[righti:]\n                else:\n                    self.ranges=self.ranges[:lefti]+[left,right]+self.ranges[righti:]\n        return\n        \n        \n\n\n# Your RangeModule object will be instantiated and called as such:\n# obj = RangeModule()\n# obj.addRange(left,right)\n# param_2 = obj.queryRange(left,right)\n# obj.removeRange(left,right)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2053", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 script for\n\nYou are given a 2D integer array ranges where ranges[i] = [starti, endi] denotes that all integers between starti and endi (both inclusive) are contained in the ith range.\nYou are to split ranges into two (possibly empty) groups such that:\n\nEach range belongs to exactly one group.\nAny two overlapping ranges must belong to the same group.\n\nTwo ranges are said to be overlapping\u00a0if there exists at least one integer that is present in both ranges.\n\nFor example, [1, 3] and [2, 5] are overlapping because 2 and 3 occur in both ranges.\n\nReturn the total number of ways to split ranges into two groups. Since the answer may be very large, return it modulo 10^9 + 7.\n\u00a0\nExample 1:\nInput: ranges = [[6,10],[5,15]]\nOutput: 2\nExplanation: \nThe two ranges are overlapping, so they must be in the same group.\nThus, there are two possible ways:\n- Put both the ranges together in group 1.\n- Put both the ranges together in group 2.\n\nExample 2:\nInput: ranges = [[1,3],[10,20],[2,5],[4,8]]\nOutput: 4\nExplanation: \nRanges [1,3], and [2,5] are overlapping. So, they must be in the same group.\nAgain, ranges [2,5] and [4,8] are also overlapping. So, they must also be in the same group. \nThus, there are four possible ways to group them:\n- All the ranges in group 1.\n- All the ranges in group 2.\n- Ranges [1,3], [2,5], and [4,8] in group 1 and [10,20] in group 2.\n- Ranges [1,3], [2,5], and [4,8] in group 2 and [10,20] in group 1.\n\n\u00a0\nConstraints:\n\n1 <= ranges.length <= 100000\nranges[i].length == 2\n0 <= starti <= endi <= 10^9\n\n"}, {"role": "assistant", "content": "from typing import List, Tuple, Optional\nfrom collections import defaultdict, Counter\nfrom sortedcontainers import SortedList\n\nMOD = int(1e9 + 7)\nINF = int(1e20)\n\n# \u7ed9\u4f60\u4e00\u4e2a\u4e8c\u7ef4\u6574\u6570\u6570\u7ec4 ranges \uff0c\u5176\u4e2d ranges[i] = [starti, endi] \u8868\u793a starti \u5230 endi \u4e4b\u95f4\uff08\u5305\u62ec\u4e8c\u8005\uff09\u7684\u6240\u6709\u6574\u6570\u90fd\u5305\u542b\u5728\u7b2c i \u4e2a\u533a\u95f4\u4e2d\u3002\n\n# \u4f60\u9700\u8981\u5c06 ranges \u5206\u6210 \u4e24\u4e2a \u7ec4\uff08\u53ef\u4ee5\u4e3a\u7a7a\uff09\uff0c\u6ee1\u8db3\uff1a\n\n# \u6bcf\u4e2a\u533a\u95f4\u53ea\u5c5e\u4e8e\u4e00\u4e2a\u7ec4\u3002\n# \u4e24\u4e2a\u6709 \u4ea4\u96c6 \u7684\u533a\u95f4\u5fc5\u987b\u5728 \u540c\u4e00\u4e2a \u7ec4\u5185\u3002\n# \u5982\u679c\u4e24\u4e2a\u533a\u95f4\u6709\u81f3\u5c11 \u4e00\u4e2a \u516c\u5171\u6574\u6570\uff0c\u90a3\u4e48\u8fd9\u4e24\u4e2a\u533a\u95f4\u662f \u6709\u4ea4\u96c6 \u7684\u3002\n\n# \u6bd4\u65b9\u8bf4\uff0c\u533a\u95f4 [1, 3] \u548c [2, 5] \u6709\u4ea4\u96c6\uff0c\u56e0\u4e3a 2 \u548c 3 \u5728\u4e24\u4e2a\u533a\u95f4\u4e2d\u90fd\u88ab\u5305\u542b\u3002\n# \u8bf7\u4f60\u8fd4\u56de\u5c06 ranges \u5212\u5206\u6210\u4e24\u4e2a\u7ec4\u7684 \u603b\u65b9\u6848\u6570 \u3002\u7531\u4e8e\u7b54\u6848\u53ef\u80fd\u5f88\u5927\uff0c\u5c06\u5b83\u5bf9 109 + 7 \u53d6\u4f59 \u540e\u8fd4\u56de\u3002\nfrom collections import defaultdict\nfrom typing import DefaultDict, List\n\n\nclass UnionFindArray:\n\n    __slots__ = (\"n\", \"part\", \"_parent\", \"_rank\")\n\n    def __init__(self, n: int):\n        self.n = n\n        self.part = n\n        self._parent = list(range(n))\n        self._rank = [1] * n\n\n    def find(self, x: int) -> int:\n        while x != self._parent[x]:\n            self._parent[x] = self._parent[self._parent[x]]\n            x = self._parent[x]\n        return x\n\n    def union(self, x: int, y: int) -> bool:\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX == rootY:\n            return False\n        if self._rank[rootX] > self._rank[rootY]:\n            rootX, rootY = rootY, rootX\n        self._parent[rootX] = rootY\n        self._rank[rootY] += self._rank[rootX]\n        self.part -= 1\n        return True\n\n    def isConnected(self, x: int, y: int) -> bool:\n        return self.find(x) == self.find(y)\n\n    def getGroups(self) -> DefaultDict[int, List[int]]:\n        groups = defaultdict(list)\n        for key in range(self.n):\n            root = self.find(key)\n            groups[root].append(key)\n        return groups\n\n    def getRoots(self) -> List[int]:\n        return list(set(self.find(key) for key in self._parent))\n\n    def getSize(self, x: int) -> int:\n        return self._rank[self.find(x)]\n\n    def __repr__(self) -> str:\n        return \"\\n\".join(f\"{root}: {member}\" for root, member in self.getGroups().items())\n\n    def __len__(self) -> int:\n        return self.part\n\n\nclass Solution:\n    def countWays(self, ranges: List[List[int]]) -> int:\n        if len(ranges) == 1:\n            return 2\n        ranges.sort()\n        n = len(ranges)\n        uf = UnionFindArray(n)\n        preEnd = ranges[0][1]\n        for i in range(1, n):\n            if ranges[i][0] <= preEnd:\n                uf.union(i - 1, i)\n            preEnd = max(preEnd, ranges[i][1])\n        groups = uf.getGroups()\n        return pow(2, len(groups), MOD)\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2064", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 2 to\n\nYou are given an undirected weighted connected graph containing n nodes labeled from 0 to n - 1, and an integer array edges where edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and bi with weight wi.\nSome edges have a weight of -1 (wi = -1), while others have a positive weight (wi > 0).\nYour task is to modify all edges with a weight of -1 by assigning them positive integer values in the range [1, 2 * 109] so that the shortest distance between the nodes source and destination becomes equal to an integer target. If there are multiple modifications that make the shortest distance between source and destination equal to target, any of them will be considered correct.\nReturn an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from source to destination equal to target, or an empty array if it's impossible.\nNote: You are not allowed to modify the weights of edges with initial positive weights.\n\u00a0\nExample 1:\n\nInput: n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5\nOutput: [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]\nExplanation: The graph above shows a possible modification to the edges, making the distance from 0 to 1 equal to 5.\n\nExample 2:\n\nInput: n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6\nOutput: []\nExplanation: The graph above contains the initial edges. It is not possible to make the distance from 0 to 2 equal to 6 by modifying the edge with weight -1. So, an empty array is returned.\n\nExample 3:\n\nInput: n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6\nOutput: [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]\nExplanation: The graph above shows a modified graph having the shortest distance from 0 to 2 as 6.\n\n\u00a0\nConstraints:\n\n1 <= n <= 100\n1 <= edges.length <= n * (n - 1) / 2\nedges[i].length == 3\n0 <= ai, bi\u00a0<\u00a0n\nwi\u00a0= -1\u00a0or 1 <= wi\u00a0<= 107\nai\u00a0!=\u00a0bi\n0 <= source, destination < n\nsource != destination\n1 <= target <= 109\nThe graph is connected, and there are no self-loops or repeated edges\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def modifiedGraphEdges(self, n, edges, source, destination, target):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type source: int\n        :type destination: int\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        g, o, p, d, q, r, a = [[0] * n for _ in range(n)], [float('inf')] * n, [[0, source]], [float('inf')] * n, [-1] * n, [[0, source]], []\n        for e, f, h in edges:\n            g[e][f], g[f][e] = h, h\n        o[source], d[source] = 0, 0\n        while p:\n            e, u = heapq.heappop(p)\n            if e == o[u]:\n                for v in range(n):\n                    if g[u][v] and g[u][v] != -1 and e + g[u][v] < o[v]:\n                        o[v] = e + g[u][v]\n                        heapq.heappush(p, [o[v], v])\n        if o[destination] < target:\n            return []\n        if o[destination] == target:\n            for e in edges:\n                e[2] = 2000000000 if e[2] == -1 else e[2]\n            return edges\n        while r:\n            e, u = heapq.heappop(r)\n            if u == destination:\n                if e > target:\n                    return []\n                break\n            if e == d[u]:\n                for v in range(n):\n                    if g[u][v]:\n                        if (e + 1 if g[u][v] == -1 else e + g[u][v]) < d[v]:\n                            d[v], q[v] = e + 1 if g[u][v] == -1 else e + g[u][v], u\n                            heapq.heappush(r, [e + 1 if g[u][v] == -1 else e + g[u][v], v])\n        while destination >= 0 and q[destination] >= 0:\n            if g[q[destination]][destination] == -1:\n                if o[q[destination]] < target:\n                    g[q[destination]][destination], g[destination][q[destination]] = target - o[q[destination]], target - o[q[destination]]\n                    break\n                g[q[destination]][destination], g[destination][q[destination]] = 1, 1\n            target, destination = target - g[destination][q[destination]], q[destination]\n        for e, f, _ in edges:\n            a.append([e, f, 2000000000 if g[e][f] == -1 else g[e][f]])\n        return a"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2065", "label": "code_high", "messages": [{"role": "user", "content": "Can you write a program in Python 3 where\n\nYou are given an undirected weighted connected graph containing n nodes labeled from 0 to n - 1, and an integer array edges where edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and bi with weight wi.\nSome edges have a weight of -1 (wi = -1), while others have a positive weight (wi > 0).\nYour task is to modify all edges with a weight of -1 by assigning them positive integer values in the range [1, 2 * 109] so that the shortest distance between the nodes source and destination becomes equal to an integer target. If there are multiple modifications that make the shortest distance between source and destination equal to target, any of them will be considered correct.\nReturn an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from source to destination equal to target, or an empty array if it's impossible.\nNote: You are not allowed to modify the weights of edges with initial positive weights.\n\u00a0\nExample 1:\n\nInput: n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5\nOutput: [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]\nExplanation: The graph above shows a possible modification to the edges, making the distance from 0 to 1 equal to 5.\n\nExample 2:\n\nInput: n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6\nOutput: []\nExplanation: The graph above contains the initial edges. It is not possible to make the distance from 0 to 2 equal to 6 by modifying the edge with weight -1. So, an empty array is returned.\n\nExample 3:\n\nInput: n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6\nOutput: [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]\nExplanation: The graph above shows a modified graph having the shortest distance from 0 to 2 as 6.\n\n\u00a0\nConstraints:\n\n1 <= n <= 100\n1 <= edges.length <= n * (n - 1) / 2\nedges[i].length == 3\n0 <= ai, bi\u00a0<\u00a0n\nwi\u00a0= -1\u00a0or 1 <= wi\u00a0<= 107\nai\u00a0!=\u00a0bi\n0 <= source, destination < n\nsource != destination\n1 <= target <= 109\nThe graph is connected, and there are no self-loops or repeated edges\n\n"}, {"role": "assistant", "content": "class Solution:\n    def modifiedGraphEdges(self, n: int, es: List[List[int]], st: int, ed: int, tar: int) -> List[List[int]]:\n        def g(es):\n            nei = defaultdict(list)\n            for x, y, w in es:\n                nei[x].append((y, w))\n                nei[y].append((x, w))\n            q = [(0, st)]\n            dis = [10**18] * n\n            dis[st] = 0\n            while q:\n                d, cur = heappop(q)\n                if d > dis[cur]:\n                    continue\n                if cur == ed:\n                    return d\n                for y, w in nei[cur]:\n                    if w+d < dis[y]:\n                        dis[y] = w+d\n                        heappush(q, (w+d, y))\n        \n        uc = []\n        cc = []\n        for x, y, w in es:\n            if w > 0:\n                uc.append([x, y, w])\n            else:\n                cc.append([x, y])\n        \n        def f(dx):\n            ncc = [[x, y, dx] for x, y in cc]\n            return g(ncc + uc)\n        \n        MAX = 2 * 10**9\n        \n        if f(1) > tar or f(MAX) < tar:\n            return []\n        \n        l, r = 1, 10 ** 9\n        while l < r:\n            mi = (l + r + 1) >> 1\n            if f(mi) > tar:\n                r = mi - 1\n            else:\n                l = mi\n        # print(l, f(l))\n        \n        cur = f(l)\n        ncc = [[x, y, l] for x, y in cc]\n        gap = tar - cur\n        if gap == 0:\n            return ncc + uc\n        \n        nnc = len(ncc)\n        for i in range(nnc):\n            ncc[i][2] += 1\n            if g(ncc + uc) == tar:\n                return ncc + uc\n        \n        \n        \n        return []\n        \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2098", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 3 that\n\nYou are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.\n\u00a0\nExample 1:\nInput: grid = [[0,1],[1,0]]\nOutput: 1\n\nExample 2:\nInput: grid = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2\n\nExample 3:\nInput: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1\n\n\u00a0\nConstraints:\n\nn == grid.length == grid[i].length\n2 <= n <= 100\ngrid[i][j] is either 0 or 1.\nThere are exactly two islands in grid.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def shortestBridge(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        q = []\n        n = len(A)\n        for i in range(n):\n            for j in range(n):\n                if A[i][j]:\n                    q.append((i, j))\n                    break\n            if q:\n                break\n        marked = [[False] * n for _ in range(n)]\n        marked[q[0][0]][q[0][1]] = True\n        while q:\n            cy, cx = q.pop()\n            for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                nx = cx + dx\n                ny = cy + dy\n                if 0 <= nx < n and 0 <= ny < n:\n                    if A[ny][nx] and not marked[ny][nx]:\n                        marked[ny][nx] = True\n                        q.append((ny, nx))\n        res = 0\n        for i in range(n):\n            for j in range(n):\n                if marked[i][j]:\n                    q.append((i, j))\n        while True:\n            q2 = []\n            while q:\n                cy, cx = q.pop()\n                for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                    nx = cx + dx\n                    ny = cy + dy\n                    if 0 <= nx < n and 0 <= ny < n:\n                        if A[ny][nx] and not marked[ny][nx]:\n                            return res\n                        if not A[ny][nx] and not marked[ny][nx]:\n                            marked[ny][nx] = True\n                            q2.append((ny, nx))\n            res += 1\n            q = q2\n        return -1"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2142", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 3 to\n\nThis question is about implementing a basic elimination algorithm for Candy Crush.\n\nGiven an m x n integer array board representing the grid of candy where board[i][j] represents the type of candy. A value of board[i][j] == 0 represents that the cell is empty.\n\nThe given board represents the state of the game following the player's move. Now, you need to restore the board to a stable state by crushing candies according to the following rules:\n\nIf three or more candies of the same type are adjacent vertically or horizontally, crush them all at the same time - these positions become empty.\nAfter crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. No new candies will drop outside the top boundary.\nAfter the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps.\nIf there does not exist more candies that can be crushed (i.e., the board is stable), then return the current board.\n\nYou need to perform the above rules until the board becomes stable, then return the stable board.\n\n \n\nExample 1:\n\nInput: board = [[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]\nOutput: [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]\n\nExample 2:\n\nInput: board = [[1,3,5,5,2],[3,4,3,3,1],[3,2,4,5,2],[2,4,4,5,5],[1,4,4,1,1]]\nOutput: [[1,3,0,0,0],[3,4,0,5,2],[3,2,0,3,1],[2,4,0,5,2],[1,4,3,1,1]]\n\n \n\nConstraints:\n\nm == board.length\nn == board[i].length\n3 <= m, n <= 50\n1 <= board[i][j] <= 2000\n\n"}, {"role": "assistant", "content": "class Solution:\n    def candyCrush(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        xlen = len(board[0])\n        ylen = len(board)\n        \n        while True:\n            crushed_some = False\n            crushed = [[False for i in range(xlen)] for j in range(ylen)]\n            for j in range(ylen):\n                typ = -1\n                nliketyp = 0\n                for i in range(xlen):\n                    if board[j][i] == typ:\n                        nliketyp += 1\n                    else:\n                        if nliketyp >= 3 and typ > 0:\n                            #print(nliketyp)\n                            for di in range(nliketyp):\n                                crushed[j][i-di-1] = True\n                            crushed_some = True\n                        typ = board[j][i]\n                        nliketyp = 1\n                if nliketyp >= 3 and typ > 0:\n                    #print(nliketyp)\n                    for di in range(nliketyp):\n                        crushed[j][xlen-di-1] = True\n                    crushed_some = True\n\n            for i in range(xlen):\n                typ = -1\n                nliketyp = 0\n                for j in range(ylen):\n                    if board[j][i] == typ:\n                        nliketyp += 1\n                    else:\n                        if nliketyp >= 3 and typ > 0:\n                            #print(nliketyp)\n                            for dj in range(nliketyp):\n                                crushed[j-dj-1][i] = True\n                            crushed_some = True\n                        typ = board[j][i]\n                        nliketyp = 1\n                if nliketyp >= 3 and typ > 0:\n                    #print(nliketyp)\n                    for dj in range(nliketyp):\n                        crushed[ylen-dj-1][i] = True\n                    crushed_some = True\n\n            #print(crushed)\n            if not crushed_some:\n                break\n\n            for i in range(xlen):\n                wj = ylen-1\n                for j in range(ylen-1, -1, -1):\n                    if crushed[j][i]:\n                        continue\n                    board[wj][i] = board[j][i]\n                    wj -= 1\n                for j in range(wj, -1, -1):\n                    board[j][i] = 0\n\n            #break\n        \n        return board\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2163", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 script for\n\nYou wrote down many positive integers in a string called num. However, you realized that you forgot to add commas to seperate the different numbers. You remember that the list of integers was non-decreasing and that no integer had leading zeros.\nReturn the number of possible lists of integers that you could have written down to get the string num. Since the answer may be large, return it modulo 10^9 + 7.\n\u00a0\nExample 1:\nInput: num = \"327\"\nOutput: 2\nExplanation: You could have written down the numbers:\n3, 27\n327\n\nExample 2:\nInput: num = \"094\"\nOutput: 0\nExplanation: No numbers can have leading zeros and all numbers must be positive.\n\nExample 3:\nInput: num = \"0\"\nOutput: 0\nExplanation: No numbers can have leading zeros and all numbers must be positive.\n\n\u00a0\nConstraints:\n\n1 <= num.length <= 3500\nnum consists of digits '0' through '9'.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def numberOfCombinations(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: int\n        \"\"\"\n        mod = 1000000007\n        n = len(num)\n        dp2 = [[0]*(n+1) for _ in range(n)]\n        i=n-1\n        while i>=0:\n            j=n-1\n            while j>i:\n                if num[i]!=num[j]:\n                    dp2[i][j]=0\n                else:\n                    dp2[i][j]=1+dp2[i+1][j+1]\n                j-=1\n            i-=1\n        dp = [[0]*(n+1) for _ in range(n)]\n        i = n-1\n        while i>=0:\n            if num[i]!='0':\n                d=n-i\n                dp[i][d]=1\n                d-=1\n                while d>0:\n                    r = dp[i][d+1]\n                    j = i+d\n                    if num[j]!='0' and j+d<=n:\n                        kk = dp2[i][j]\n                        if kk>=d or num[i+kk]<num[j+kk]: nd=d\n                        else: nd=d+1\n                        if j+nd<=n:\n                            r+=dp[j][nd]\n                            r%=mod\n                    dp[i][d]=r\n                    d-=1\n            i-=1\n        \"\"\"\n        def dfs(i, d):\n            j=i+d\n            if j==n: return 1\n            if j>n: return 0\n            k = (i, d)\n            if k in dp: return dp[k]\n            r = dfs(i, d+1)\n            if num[j]!='0' and j+d<=n:\n                kk = dp2[i][j]\n                if kk>=d or num[i+kk]<num[j+kk]: nd=d\n                else:\n                    nd=d+1\n                if j+nd<=n:\n                    r += dfs(j, nd)\n                    r %= mod\n            dp[k]=r\n            return r\n        \"\"\"\n        rc = 0\n        if num[0]=='0':\n            rc = 0\n        else:\n            rc = dp[0][1]\n        return rc\n            "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2215", "label": "code_high", "messages": [{"role": "user", "content": "Can you write a program in Python 3 where\n\nGiven a weighted undirected connected graph with n\u00a0vertices numbered from 0 to n - 1,\u00a0and an array edges\u00a0where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes\u00a0ai\u00a0and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles\u00a0and with the minimum possible total edge weight.\nFind all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a\u00a0critical edge. On\u00a0the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.\nNote that you can return the indices of the edges in any order.\n\u00a0\nExample 1:\n\nInput: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\nOutput: [[0,1],[2,3,4,5]]\nExplanation: The figure above describes the graph.\nThe following figure shows all the possible MSTs:\n\nNotice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.\nThe edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.\n\nExample 2:\n\nInput: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]\nOutput: [[],[0,1,2,3]]\nExplanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.\n\n\u00a0\nConstraints:\n\n2 <= n <= 100\n1 <= edges.length <= min(200, n * (n - 1) / 2)\nedges[i].length == 3\n0 <= ai < bi < n\n1 <= weighti\u00a0<= 1000\nAll pairs (ai, bi) are distinct.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def findCriticalAndPseudoCriticalEdges(self, n: int, e: List[List[int]]) -> List[List[int]]:\n        for i in range(len(e)):\n            e[i].append(i)\n        e.sort(key=lambda v:v[2])\n        \n        def mst(a,ig):\n            def root(n):\n                if a[n]==n:\n                    return n\n                a[n]=root(a[n])\n                return a[n]\n            w=0\n            for vv in e:\n                if vv[3]==ig:\n                    continue\n                u,v=root(vv[0]),root(vv[1])\n                if u==v:\n                    continue\n                w+=vv[2]\n                a[u]=v\n            for i in range(n):\n                if root(i) != root(0):\n                    return 1<<30\n            return w\n        \n        self.ms=mst([k for k in range(n)],-1)\n        print(self.ms)\n        def cric():\n            ans=[]\n            for i in range(len(e)):\n                a=[j for j in range(n)]\n                v=mst(a,i)\n                if self.ms<v:\n                    # print(a,i,v)\n                    ans.append(i)\n            return ans\n        \n        def pcric():\n            ans=[]\n            for vv in e:\n                a=[j for j in range(n)]\n                a[vv[0]]=vv[1]\n                if self.ms==mst(a,vv[3])+vv[2]:\n                    ans.append(vv[3])\n            return ans\n        cr=cric()\n        pcr=pcric()\n        d={x for x in cr}\n        ppcr=[]\n        for x in pcr:\n            if x in d:\n                continue\n            ppcr.append(x)\n        return [cr,ppcr]\n        \n                    "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2216", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 script for\n\nGiven a weighted undirected connected graph with n\u00a0vertices numbered from 0 to n - 1,\u00a0and an array edges\u00a0where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes\u00a0ai\u00a0and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles\u00a0and with the minimum possible total edge weight.\nFind all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a\u00a0critical edge. On\u00a0the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.\nNote that you can return the indices of the edges in any order.\n\u00a0\nExample 1:\n\nInput: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\nOutput: [[0,1],[2,3,4,5]]\nExplanation: The figure above describes the graph.\nThe following figure shows all the possible MSTs:\n\nNotice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.\nThe edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.\n\nExample 2:\n\nInput: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]\nOutput: [[],[0,1,2,3]]\nExplanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.\n\n\u00a0\nConstraints:\n\n2 <= n <= 100\n1 <= edges.length <= min(200, n * (n - 1) / 2)\nedges[i].length == 3\n0 <= ai < bi < n\n1 <= weighti\u00a0<= 1000\nAll pairs (ai, bi) are distinct.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        gid = [0]*(n+1)\n        gc = [0]*(n+1)\n        def findg(g):\n            while gid[g]!=g:\n                g=gid[g]\n            return g\n        ne = sorted([(e[2], e[0], e[1], i) for i,e in enumerate(edges)])\n        m = len(edges)\n        mk = [0]*m\n        for i in range(-1, m):\n            for j in range(n):\n                gid[j]=j\n                gc[j]=1\n            c, ww = n, 0\n            for k in range(m):\n                if k==i: continue\n                w, a, b, _ = ne[k]\n                ga, gb = findg(a), findg(b)\n                if ga==gb: continue\n                if gc[ga]>gc[gb]:\n                    gid[gb]=ga;\n                    gc[ga]+=gc[gb]\n                else:\n                    gid[ga]=gb\n                    gc[gb]+=gc[ga]\n                c-=1\n                ww += w\n            if i==-1: mw=ww\n            else:\n                if c!=1 or mw!=ww:\n                    mk[ne[i][3]] |= 1\n        for i in range(m):\n            for j in range(n):\n                gid[j]=j\n                gc[j]=1\n            w, a, b, ii = ne[i]\n            gid[a]=b\n            gc[b]+=gc[a]\n            c, ww = n-1, w\n            for k in range(m):\n                if k==i: continue\n                w, a, b, _ = ne[k]\n                ga, gb = findg(a), findg(b)\n                if ga==gb: continue\n                if gc[ga]>gc[gb]:\n                    gid[gb]=ga;\n                    gc[ga]+=gc[gb]\n                else:\n                    gid[ga]=gb\n                    gc[gb]+=gc[ga]\n                c-=1\n                ww += w\n            if mw==ww:\n                mk[ii] |= 2\n        r1, r2 = [], []\n        for i in range(m):\n            if mk[i] & 1: r1.append(i)\n            elif mk[i]&2: r2.append(i)\n        return [r1,r2]\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2306", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 2 to\n\nYou are given an n x n grid representing a field of cherries, each cell is one of three possible integers.\n\n0 means the cell is empty, so you can pass through,\n1 means the cell contains a cherry that you can pick up and pass through, or\n-1 means the cell contains a thorn that blocks your way.\n\nReturn the maximum number of cherries you can collect by following the rules below:\n\nStarting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1).\nAfter reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells.\nWhen passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.\nIf there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected.\n\n\u00a0\nExample 1:\n\nInput: grid = [[0,1,-1],[1,0,-1],[1,1,1]]\nOutput: 5\nExplanation: The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\nExample 2:\nInput: grid = [[1,1,-1],[1,-1,1],[-1,1,1]]\nOutput: 0\n\n\u00a0\nConstraints:\n\nn == grid.length\nn == grid[i].length\n1 <= n <= 50\ngrid[i][j] is -1, 0, or 1.\ngrid[0][0] != -1\ngrid[n - 1][n - 1] != -1\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        cur = [[grid[0][0]]]\n        for l in range(1, n):\n            pre, cur = cur, [[-1 for j in range(l + 1)] for i in range(l + 1)]\n            for i in range(l + 1):\n                for j in range(i, l + 1):\n                    m = -1\n                    for ii in [i - 1, i]:\n                        for jj in [j - 1, j]:\n                            if 0 <= ii < l and 0 <= jj < l:\n                                m = max(m, pre[ii][jj])\n                    if m >= 0 and grid[l - i][i] >= 0 and grid[l - j][j] >= 0:\n                        cur[i][j] = m + grid[l - i][i] + grid[l - j][j] if i != j else m + grid[l - i][i]\n                    else:\n                        cur[i][j] = -1\n            #print cur\n        for l in range(n - 2, -1, -1):\n            pre, cur = cur, [[-1 for j in range(l + 1)] for i in range(l + 1)]\n            for i in range(l + 1):\n                for j in range(i, l + 1):\n                    m = -1\n                    for ii in [i + 1, i]:\n                        for jj in [j + 1, j]:\n                            m = max(m, pre[ii][jj])\n                    if m >= 0 and grid[n - 1 - i][n - 1 - l + i] >= 0 and grid[n - 1 - j][n - 1 - l + j] >= 0:\n                        cur[i][j] = m + grid[n - 1 - i][n - 1 - l + i] + grid[n - 1 - j][n - 1 - l + j] if i != j else m + grid[n - 1 - i][n - 1 - l + i]\n                    else:\n                        cur[i][j] = -1\n            #print cur\n        return max(cur[0][0], 0)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2307", "label": "code_high", "messages": [{"role": "user", "content": "Can you implement a function in Python 3 that\n\nYou are given an n x n grid representing a field of cherries, each cell is one of three possible integers.\n\n0 means the cell is empty, so you can pass through,\n1 means the cell contains a cherry that you can pick up and pass through, or\n-1 means the cell contains a thorn that blocks your way.\n\nReturn the maximum number of cherries you can collect by following the rules below:\n\nStarting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1).\nAfter reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells.\nWhen passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.\nIf there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected.\n\n\u00a0\nExample 1:\n\nInput: grid = [[0,1,-1],[1,0,-1],[1,1,1]]\nOutput: 5\nExplanation: The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\nExample 2:\nInput: grid = [[1,1,-1],[1,-1,1],[-1,1,1]]\nOutput: 0\n\n\u00a0\nConstraints:\n\nn == grid.length\nn == grid[i].length\n1 <= n <= 50\ngrid[i][j] is -1, 0, or 1.\ngrid[0][0] != -1\ngrid[n - 1][n - 1] != -1\n\n"}, {"role": "assistant", "content": "class Solution:\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # dynamic programming\n        # dp[i1][j1][i2][j2] stores the maximum cherry can pick\n        # by starting from (i1, j1), (i2, j2) and goes to (n - 1, n - 1)\n        # base case dp[n-1,n-1,n-1,n-1] = R[n-1]\n        # R = -inf if R = 0\n        N = len(grid)\n        for i in range(N):\n            for j in range(N):\n                if grid[i][j] == -1:\n                    grid[i][j] = float('-inf')\n        cache = dict()\n        def helper(i1, j1, i2, j2):\n            if (i1, j1, i2, j2) in cache:\n                return cache[(i1, j1, i2, j2)]\n            if (i1, j1, i2, j2) == (N - 1, N - 1, N - 1, N - 1):\n                rtn = grid[N - 1][N - 1]\n                cache[(i1, j1, i2, j2)] = rtn\n                return rtn\n            if i1 >= N or j1 >= N or i2 >= N or j2 >= N or grid[i1][j1] < 0 or grid[i2][j2] < 0:\n                rtn = float('-inf')\n                cache[(i1, j1, i2, j2)] = rtn\n                return rtn\n            # Need to consider different cases\n            if i1 == i2 and j1 == j2:\n                rtn = grid[i1][j1]\n                rtn += max(helper(i1 + 1, j1, i2 + 1, j2), helper(i1 + 1, j1, i2, j2 + 1),\n                          helper(i1, j1 + 1, i2 + 1, j2), helper(i1, j1 + 1, i2, j2 + 1))\n                cache[(i1, j1, i2, j2)] = rtn\n                return rtn\n            if i1 <= i2 and j1 <= j2:\n                # i1, j1 might cross i2, j2\n                rtn = grid[i1][j1] + max(helper(i1 + 1, j1, i2, j2), helper(i1, j1 + 1, i2, j2))\n                cache[(i1, j1, i2, j2)] = rtn\n                return rtn\n            if i1 >= i2 and j1 >= j2:\n                # i2, j2 might cross i1, j1\n                rtn = grid[i2][j2] + max(helper(i1, j1, i2 + 1, j2), helper(i1, j1, i2, j2 + 1))\n                cache[(i1, j1, i2, j2)] = rtn\n                return rtn\n            rtn = grid[i1][j1] + grid[i2][j2]\n            rtn += max(helper(i1 + 1, j1, i2 + 1, j2), helper(i1 + 1, j1, i2, j2 + 1),\n                       helper(i1, j1 + 1, i2 + 1, j2), helper(i1, j1 + 1, i2, j2 + 1))\n            cache[(i1, j1, i2, j2)] = rtn\n            return rtn\n        rtn = helper(0, 0, 0, 0)\n        return max(rtn, 0)\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2309", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 3 program that\n\nYou are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.\n\u00a0\nExample 1:\n\nInput: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.\n\nExample 2:\n\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 100000\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1\n\n"}, {"role": "assistant", "content": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        R = len(grid)\n        C = len(grid[0])\n        \n        gfrom = [[False] * C for _ in range(R)]\n        gfrom[R - 1][C - 1] = True\n        \n        for i in range(R - 1, -1, -1):\n            for j in range(C - 1, -1, -1):\n                if i == R - 1 and j == C - 1:\n                    continue\n                if grid[i][j] == 0:\n                    continue\n                if i + 1 < R and gfrom[i + 1][j]:\n                    gfrom[i][j] = True\n                if j + 1 < C and gfrom[i][j + 1]:\n                    gfrom[i][j] = True\n        \n        gto = [[False] * C for _ in range(R)]\n        gto[0][0] = True\n        for i in range(R):\n            for j in range(C):\n                if i == 0 and j == 0:\n                    continue\n                if grid[i][j] == 0:\n                    continue\n                if i >= 1 and gto[i - 1][j]:\n                    gto[i][j] = True\n                if j >= 1 and gto[i][j - 1]:\n                    gto[i][j] = True\n        \n        if not gfrom[0][0]:\n            return True\n        \n        x, y, path1 = 0, 0, []\n        while y != R - 1 or x != C - 1:\n            if x + y > 0:\n                path1.append((y, x))\n            if x + 1 < C and gfrom[y][x + 1]:\n                x += 1\n            else:\n                y += 1\n        \n        x, y, path2 = 0, 0, []\n        while y != R - 1 or x != C - 1:\n            if x + y > 0:\n                path2.append((y, x))\n            if y + 1 < R and gfrom[y + 1][x]:\n                y += 1\n            else:\n                x += 1\n        \n        return (set(path1) & set(path2))"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2311", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 2 to\n\nYou are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.\n\u00a0\nExample 1:\n\nInput: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.\n\nExample 2:\n\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 100000\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def isPossibleToCutPath(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0 for k in range(0, m)] for i in range(0, n)]\n        dp1 = [[0 for k in range(0, m)] for i in range(0, n)]\n        dp[0][0] = 1\n        dp1[n - 1][m - 1] = 1\n        for i in range(0, n):\n            for k in range(0, m):\n                if grid[i][k] == 1:\n                    if i - 1 >= 0:\n                        dp[i][k] += dp[i - 1][k]\n                    if k - 1 >= 0:\n                        dp[i][k] += dp[i][k - 1]\n        i = n - 1\n        while i >= 0:\n            k = m - 1\n            while k >= 0:\n                if grid[i][k] == 1:\n                    if i + 1 < n:\n                        dp1[i][k] += dp1[i + 1][k]\n                    if k + 1 < m:\n                        dp1[i][k] += dp1[i][k + 1]\n                k = k - 1\n            i = i - 1\n        \n        if dp[n - 1][m - 1] == 0:\n            return True\n        # print(dp)\n        for i in range(0, n):\n            for k in range(0, m):\n                if dp[i][k] * dp1[i][k] == dp[n - 1][m - 1] and (i, k) != (0, 0) and (i, k) != (n - 1, m - 1):\n                    return True\n        return False"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2331", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 program that can\n\nThere is a tournament where n players are participating. The players are standing in a single row and are numbered from 1 to n based on their initial standing position (player 1 is the first player in the row, player 2 is the second player in the row, etc.).\nThe tournament consists of multiple rounds (starting from round number 1). In each round, the ith player from the front of the row competes against the ith player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.\n\nFor example, if the row consists of players 1, 2, 4, 6, 7\n\nPlayer 1 competes against player 7.\nPlayer 2 competes against player 6.\nPlayer 4 automatically advances to the next round.\n\n\n\nAfter each round is over, the winners are lined back up in the row based on the original ordering assigned to them initially (ascending order).\nThe players numbered firstPlayer and secondPlayer are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may choose the outcome of this round.\nGiven the integers n, firstPlayer, and secondPlayer, return an integer array containing two values, the earliest possible round number and the\u00a0latest possible round number in which these two players will compete against each other, respectively.\n\u00a0\nExample 1:\nInput: n = 11, firstPlayer = 2, secondPlayer = 4\nOutput: [3,4]\nExplanation:\nOne possible scenario which leads to the earliest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 2, 3, 4, 5, 6, 11\nThird round: 2, 3, 4\nOne possible scenario which leads to the latest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 1, 2, 3, 4, 5, 6\nThird round: 1, 2, 4\nFourth round: 2, 4\n\nExample 2:\nInput: n = 5, firstPlayer = 1, secondPlayer = 5\nOutput: [1,1]\nExplanation: The players numbered 1 and 5 compete in the first round.\nThere is no way to make them compete in any other round.\n\n\u00a0\nConstraints:\n\n2 <= n <= 28\n1 <= firstPlayer < secondPlayer <= n\n\n"}, {"role": "assistant", "content": "class Solution:\n    def earliestAndLatest(self, num: int, first: int, second: int) -> List[int]:\n        @cache\n        def earliest(n, f, s):\n            if f+s == n-1:\n                return 1\n            matches = n//2\n            ans = 10000000\n            for win in range(2**matches):\n                l = [1 for i in range(n)]\n                for i in range(matches):\n                    if win&(1<<i):\n                        l[i] = 1\n                        l[n-1-i] = 0\n                    else:\n                        l[i] = 0\n                        l[n-1-i] = 1\n                #print(win, l)\n                if l[f] and l[s]:\n                    for i in range(1, n):\n                        l[i] += l[i-1]\n                    ans = min(ans, earliest(n-matches, l[f]-1, l[s]-1)+1)\n            return ans\n        @cache\n        def latest(n, f, s):\n            if f+s == n-1:\n                return 1\n            matches = n//2\n            ans = -10000000\n            for win in range(2**matches):\n                l = [1 for i in range(n)]\n                for i in range(matches):\n                    if win&(1<<i):\n                        l[i] = 1\n                        l[n-1-i] = 0\n                    else:\n                        l[i] = 0\n                        l[n-1-i] = 1\n                if l[f] and l[s]:\n                    for i in range(1, n):\n                        l[i] += l[i-1]\n                    #print(n, f, s, l)\n                    ans = max(ans, latest(n-matches, l[f]-1, l[s]-1)+1)\n            return ans\n        return [earliest(num, first-1, second-1), latest(num, first-1, second-1)]\n                    \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2333", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 program that can\n\nThere is a tournament where n players are participating. The players are standing in a single row and are numbered from 1 to n based on their initial standing position (player 1 is the first player in the row, player 2 is the second player in the row, etc.).\nThe tournament consists of multiple rounds (starting from round number 1). In each round, the ith player from the front of the row competes against the ith player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.\n\nFor example, if the row consists of players 1, 2, 4, 6, 7\n\nPlayer 1 competes against player 7.\nPlayer 2 competes against player 6.\nPlayer 4 automatically advances to the next round.\n\n\n\nAfter each round is over, the winners are lined back up in the row based on the original ordering assigned to them initially (ascending order).\nThe players numbered firstPlayer and secondPlayer are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may choose the outcome of this round.\nGiven the integers n, firstPlayer, and secondPlayer, return an integer array containing two values, the earliest possible round number and the\u00a0latest possible round number in which these two players will compete against each other, respectively.\n\u00a0\nExample 1:\nInput: n = 11, firstPlayer = 2, secondPlayer = 4\nOutput: [3,4]\nExplanation:\nOne possible scenario which leads to the earliest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 2, 3, 4, 5, 6, 11\nThird round: 2, 3, 4\nOne possible scenario which leads to the latest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 1, 2, 3, 4, 5, 6\nThird round: 1, 2, 4\nFourth round: 2, 4\n\nExample 2:\nInput: n = 5, firstPlayer = 1, secondPlayer = 5\nOutput: [1,1]\nExplanation: The players numbered 1 and 5 compete in the first round.\nThere is no way to make them compete in any other round.\n\n\u00a0\nConstraints:\n\n2 <= n <= 28\n1 <= firstPlayer < secondPlayer <= n\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def earliestAndLatest(self, n, firstPlayer, secondPlayer):\n        \"\"\"\n        :type n: int\n        :type firstPlayer: int\n        :type secondPlayer: int\n        :rtype: List[int]\n        \"\"\"\n        m1={}\n        m2={}\n        def conv(a):\n            s=\"\"\n            for i in a:\n                s+=str(i)+'$'\n            return s\n        def func(arr):\n            arr.sort()\n            s=conv(arr)\n            if m1.get(s,-1)!=-1:\n                return [m1[s],m2[s]]\n            b=[[]]\n            minn=10**18\n            maxx=0\n            for i in range(len(arr)/2):\n                c=[]\n                for j in b:\n                    if arr[i]==firstPlayer and arr[len(arr)-i-1]==secondPlayer:\n                        m1[s]=1\n                        m2[s]=1\n                        return [1,1]\n                    elif arr[i]==firstPlayer or arr[i]==secondPlayer:\n                        c.append(j+[arr[i]])\n                    elif arr[len(arr)-i-1]==firstPlayer or arr[len(arr)-i-1]==secondPlayer:\n                        c.append(j+[arr[len(arr)-i-1]])\n                    else:\n                        c.append(j+[arr[i]])\n                        c.append(j+[arr[len(arr)-i-1]])\n                b=c[:]\n            if len(arr)%2==1:\n                for j in range(len(b)):\n                    b[j].append(arr[len(arr)/2])\n            for j in range(len(b)):\n                out=func(b[j])\n                minn=min(minn,out[0]+1)\n                maxx=max(maxx,out[1]+1)\n            m1[s]=minn\n            m2[s]=maxx\n            return [m1[s],m2[s]]\n        return func([i for i in range(1,n+1)])\n                        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2410", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 2 to\n\nYou are given a square board\u00a0of characters. You can move on the board starting at the bottom right square marked with the character\u00a0'S'.\nYou need\u00a0to reach the top left square marked with the character 'E'. The rest of the squares are labeled either with a numeric character\u00a01, 2, ..., 9 or with an obstacle 'X'. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.\nReturn a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, taken modulo 10^9 + 7.\nIn case there is no path, return\u00a0[0, 0].\n\u00a0\nExample 1:\nInput: board = [\"E23\",\"2X2\",\"12S\"]\nOutput: [7,1]\nExample 2:\nInput: board = [\"E12\",\"1X1\",\"21S\"]\nOutput: [4,2]\nExample 3:\nInput: board = [\"E11\",\"XXX\",\"11S\"]\nOutput: [0,0]\n\n\u00a0\nConstraints:\n\n2 <= board.length == board[i].length <= 100\n"}, {"role": "assistant", "content": "class Solution(object):\n    def pathsWithMaxScore(self, A):\n        R, C = len(A), len(A[0])\n        MOD = 10**9 + 7\n        A = map(list, A)\n        A[0][0] = \"0\"\n        A[-1][-1] = \"0\"\n        for r, row in enumerate(A):\n            for c, val in enumerate(row):\n                if val == \"X\":\n                    A[r][c] = \"-1\"\n        A = [map(int, row) for row in A]\n        \n        # max sum, number of paths to get max sum\n        dp = [[ [0, 0 ] for c in xrange(C+1) ] for _ in xrange(R+1)]\n        dp[0][0][1] = 1\n        # sum , num ways\n        \n        for r in xrange(R):\n            for c in xrange(C):\n                if r == c == 0: continue\n                if A[r][c] == -1: continue\n                s = w = None\n                if r-1 >= 0:\n                    s, w = dp[r-1][c]\n                if c-1 >= 0:\n                    s2, w2 = dp[r][c-1]\n                    if s == s2:\n                        w += w2\n                    elif s2 > s:\n                        s, w = s2, w2\n                if r-1>=0 and c-1>=0:\n                    s3, w3 = dp[r-1][c-1]\n                    if s is None:\n                        s, w = s3, w3\n                    elif s3 > s:\n                        s, w = s3, w3\n                    elif s3 == s:\n                        w += w3\n                s += A[r][c]\n                \n                w %= MOD\n                dp[r][c][0] = s\n                dp[r][c][1] = w\n                #print \"!\",r,c,';',s,w\n                \n            #print dp[r]\n        \n        s,w =  dp[-2][-2]\n        if w == 0: return [0,0]\n        return [s,w]"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2413", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 script for\n\nYou are given a square board\u00a0of characters. You can move on the board starting at the bottom right square marked with the character\u00a0'S'.\nYou need\u00a0to reach the top left square marked with the character 'E'. The rest of the squares are labeled either with a numeric character\u00a01, 2, ..., 9 or with an obstacle 'X'. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.\nReturn a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, taken modulo 10^9 + 7.\nIn case there is no path, return\u00a0[0, 0].\n\u00a0\nExample 1:\nInput: board = [\"E23\",\"2X2\",\"12S\"]\nOutput: [7,1]\nExample 2:\nInput: board = [\"E12\",\"1X1\",\"21S\"]\nOutput: [4,2]\nExample 3:\nInput: board = [\"E11\",\"XXX\",\"11S\"]\nOutput: [0,0]\n\n\u00a0\nConstraints:\n\n2 <= board.length == board[i].length <= 100\n"}, {"role": "assistant", "content": "class Solution:\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n        n = len(board)\n        score, path = [[-1] * n for _ in range(n)], [[0] * n for _ in range(n)]\n        dx, dy = [0, 1, 1], [1, 0, 1]\n        MOD = 10 ** 9 + 7\n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, -1, -1):                \n                if i == n - 1 == j:\n                    score[i][j] = 0\n                    path[i][j] = 1\n                    continue\n                if board[i][j] == 'X':\n                    continue\n                m = 0\n                p = 0\n                f = False\n                for k in range(3):                   \n                    ni, nj = i + dx[k], j + dy[k]\n                    if ni < n and nj < n and board[ni][nj] != 'X' and score[ni][nj] >= 0:\n                        f = True\n                        if m == score[ni][nj]:\n                            m = score[ni][nj]\n                            p += path[ni][nj]\n                        elif m < score[ni][nj]:\n                            m = score[ni][nj]\n                            p = path[ni][nj]\n                if f:\n                    score[i][j] = m + (int(board[i][j]) if board[i][j].isnumeric() else 0)\n                    path[i][j] = p % MOD\n        return [max(0, score[0][0]), path[0][0]]"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2430", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 2 to\n\nGiven an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.\nAs the answer can be very large, return it modulo 10^9 + 7.\n\u00a0\nExample 1:\nInput: arr = [1,1,2,2,3,3,4,4,5,5], target = 8\nOutput: 20\nExplanation: \nEnumerating by the values (arr[i], arr[j], arr[k]):\n(1, 2, 5) occurs 8 times;\n(1, 3, 4) occurs 8 times;\n(2, 2, 4) occurs 2 times;\n(2, 3, 3) occurs 2 times.\n\nExample 2:\nInput: arr = [1,1,2,2,2,2], target = 5\nOutput: 12\nExplanation: \narr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:\nWe choose one 1 from [1,1] in 2 ways,\nand two 2s from [2,2,2,2] in 6 ways.\n\nExample 3:\nInput: arr = [2,1,3], target = 6\nOutput: 1\nExplanation: (1, 2, 3) occured one time in the array so we return 1.\n\n\u00a0\nConstraints:\n\n3 <= arr.length <= 3000\n0 <= arr[i] <= 100\n0 <= target <= 300\n\n"}, {"role": "assistant", "content": "from collections import Counter\nclass Solution(object):\n    def threeSumMulti(self, A, target):\n        \"\"\"\n        :type A: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        c = Counter(A)\n        c = [(key, value) for key, value in c.iteritems()]\n        ans = 0\n        mod = 10**9 + 7\n        for i in range(len(c)):\n            for j in range(i, len(c)):\n                for k in range(j, len(c)):\n                    if c[i][0] + c[j][0] + c[k][0] == target:\n                        if i==j and j==k:\n                            ans += c[i][1]*(c[i][1]-1)*(c[i][1]-2)/6\n                            ans %= mod\n                        elif i==j:\n                            ans += c[i][1]*(c[i][1]-1)/2*c[k][1]\n                            ans %= mod\n                        elif i==k:\n                            ans += c[i][1]*(c[i][1]-1)/2*c[j][1]\n                            ans %= mod\n                        elif j==k:\n                            ans += c[j][1]*(c[j][1]-1)/2*c[i][1]\n                            ans %= mod\n                        else:\n                            ans += c[i][1]*c[j][1]*c[k][1]\n                            ans %= mod\n        return ans % mod\n                            \n                            "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2449", "label": "code_high", "messages": [{"role": "user", "content": "Can you write a program in Python 3 where\n\nGiven a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighbors if they share one edge.\nReturn the minimum number of steps required to convert mat to a zero matrix or -1 if you cannot.\nA binary matrix is a matrix with all cells equal to 0 or 1 only.\nA zero matrix is a matrix with all cells equal to 0.\n\u00a0\nExample 1:\n\nInput: mat = [[0,0],[0,1]]\nOutput: 3\nExplanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\n\nExample 2:\nInput: mat = [[0]]\nOutput: 0\nExplanation: Given matrix is a zero matrix. We do not need to change it.\n\nExample 3:\nInput: mat = [[1,0,0],[1,0,0]]\nOutput: -1\nExplanation: Given matrix cannot be a zero matrix.\n\n\u00a0\nConstraints:\n\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 3\nmat[i][j] is either 0 or 1.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def minFlips(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1), (0, 0)]\n        ans = m * n + 1\n        for i in range(1 << (m * n)):\n            mm = [x[:] for x in mat]\n            cur = 0\n            open = 0\n            for j in range(m):\n                for k in range(n):\n                    if ((i >> cur) & 1) == 1:\n                        open += 1\n                        for dx, dy in dirs:\n                            x, y = j + dx, k + dy\n                            if 0 <= x < m and 0 <= y < n:\n                                mm[x][y] = 1 - mm[x][y]\n                    cur += 1\n            judge = True\n            for j in range(m):\n                for k in range(n):\n                    if mm[j][k] != 0:\n                        judge = False\n            if judge:\n                ans = min(ans, open)\n        if ans == m * n + 1:\n            ans = -1\n        return ans"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2481", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 script for\n\nYou are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).\nThe rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\nReturn the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\n\u00a0\nExample 1:\n\nInput: grid = [[0,2],[1,3]]\nOutput: 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\nExample 2:\n\nInput: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\nOutput: 16\nExplanation: The final route is shown.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n\n\u00a0\nConstraints:\n\nn == grid.length\nn == grid[i].length\n1 <= n <= 50\n0 <= grid[i][j] <\u00a0n2\nEach value grid[i][j] is unique.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def get_father(x, y):\n            if father[x][y] == (x, y):\n                return father[x][y]\n            father[x][y] = get_father(father[x][y][0], father[x][y][1])\n            return father[x][y]\n        \n        def hebing(a, b):\n            if get_father(a[0], a[1]) == get_father(b[0], b[1]):\n                return \n            a = get_father(a[0], a[1])\n            b = get_father(b[0], b[1])\n            father[a[0]][a[1]] = b\n            \n        WEI = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n        \n        pos = {}\n        m = len(grid)\n        n = len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                pos[grid[i][j]] = (i, j)\n                \n        father = []\n        for i in range(m):\n            new_list = []\n            for j in range(n):\n                new_list.append((i, j))\n            father.append(new_list)\n        \n        for i in range(m * n):\n            x, y = pos[i]\n            for j in range(4):\n                tx = x + WEI[j][0]\n                ty = y + WEI[j][1]\n                if tx >= 0 and tx < m and ty >= 0 and ty < n:\n                    if grid[tx][ty] <= i:\n                        hebing((x, y), (tx, ty))\n                        if get_father(0, 0) == get_father(m - 1, n - 1):\n                            return i\n                    \n        \n            "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2553", "label": "code_high", "messages": [{"role": "user", "content": "Can you implement a function in Python 2 that\n\nYou are given an integer n. You have an n x n binary grid grid with all values initially 1's except for some indices given in the array mines. The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0.\nReturn the order of the largest axis-aligned plus sign of 1's contained in grid. If there is none, return 0.\nAn axis-aligned plus sign of 1's of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1's. Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's.\n\u00a0\nExample 1:\n\nInput: n = 5, mines = [[4,2]]\nOutput: 2\nExplanation: In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n\nExample 2:\n\nInput: n = 1, mines = [[0,0]]\nOutput: 0\nExplanation: There is no plus sign, so return 0.\n\n\u00a0\nConstraints:\n\n1 <= n <= 500\n1 <= mines.length <= 5000\n0 <= xi, yi < n\nAll the pairs (xi, yi) are unique.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def orderOfLargestPlusSign(self, N, mines):\n        \"\"\"\n        :type N: int\n        :type mines: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = [[1]*N for _ in range(N)]\n        up = [[0]*N for _ in range(N)]\n        down = [[0]*N for _ in range(N)]\n        left = [[0]*N for _ in range(N)]\n        right = [[0]*N for _ in range(N)]\n        for i, j in mines:\n            m[i][j] = 0\n        for i in range(N):\n            up[0][i] = m[0][i]\n            left[i][0] = m[i][0]\n            right[i][-1] = m[i][-1]\n            down[-1][i] = m[-1][i]\n            \n        for i in range(1, N):\n            for j in range(N):\n                up[i][j] = (up[i-1][j]+1)*m[i][j]\n        for i in reversed(range(N-1)):\n            for j in range(N):\n                down[i][j] = (down[i+1][j]+1)*m[i][j]\n        for j in range(1, N):\n            for i in range(N):\n                left[i][j] = (left[i][j-1]+1)*m[i][j]\n        for j in reversed(range(N-1)):\n            for i in range(N):\n                right[i][j] = (right[i][j+1]+1)*m[i][j]\n        best = 0\n        for i in range(N):\n            for j in range(N):\n                this = min(up[i][j], down[i][j], left[i][j], right[i][j])\n                if this > best:\n                    best = this\n        return best\n                \n                \n                \n            "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2679", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 3 program that\n\nYou are given a 0-indexed integer array nums of length n.\nA split at an index i where 0 <= i <= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime.\n\nFor example, if nums = [2, 3, 3], then a split at the index i = 0 is valid because 2 and 9 are coprime, while a split at the index i = 1 is not valid because 6 and 3 are not coprime. A split at the index i = 2 is not valid because i == n - 1.\n\nReturn the smallest index i at which the array can be split validly or -1 if there is no such split.\nTwo values val1 and val2 are coprime if gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor of val1 and val2.\n\u00a0\nExample 1:\n\nInput: nums = [4,7,8,15,3,5]\nOutput: 2\nExplanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThe only valid split is at index 2.\n\nExample 2:\n\nInput: nums = [4,7,15,8,3,5]\nOutput: -1\nExplanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThere is no valid split.\n\n\u00a0\nConstraints:\n\nn == nums.length\n1 <= n <= 10000\n1 <= nums[i] <= 1000000\n\n"}, {"role": "assistant", "content": "M = 10 ** 6\nprimes = []\nis_prime = [True] * (M + 1)\nmin_prime = list(range(M + 1))\nfor i in range(2, M + 1):\n    if is_prime[i]:\n        primes.append(i)\n    for p in primes:\n        if i * p > M:\n            break\n        is_prime[i * p] = False\n        min_prime[i * p] = p\n        if i % p == 0:\n            break\n\ndef fac(a):\n    c = Counter()\n    while a > 1:\n        b = min_prime[a]\n        a //= b\n        c[b] += 1\n    return c\n\n\nclass Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        n = len(nums)\n        l = Counter()\n        r = Counter()\n        for a in nums:\n            r += fac(a)\n        cnt = 0\n        for i in range(n-1):\n            items = fac(nums[i]).items()\n            for k, v in items:\n                if l[k] == 0 and r[k] > 0:\n                    cnt += 1\n                l[k] += v\n            for k, v in items:\n                if l[k] > 0 and r[k] == v:\n                    cnt -= 1\n                r[k] -= v\n            if cnt == 0:\n                return i\n        return -1"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2733", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 2 function for\n\nA virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\nThe world is modeled as an m x n binary grid isInfected, where isInfected[i][j] == 0 represents uninfected cells, and isInfected[i][j] == 1 represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There will never be a tie.\nReturn the number of walls used to quarantine all the infected regions. If the world will become fully infected, return the number of walls used.\n\u00a0\nExample 1:\n\nInput: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]\nOutput: 10\nExplanation: There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n\nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n\n\nExample 2:\n\nInput: isInfected = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 4\nExplanation: Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n\nExample 3:\nInput: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]\nOutput: 13\nExplanation: The region on the left only builds two new walls.\n\n\u00a0\nConstraints:\n\nm ==\u00a0isInfected.length\nn ==\u00a0isInfected[i].length\n1 <= m, n <= 50\nisInfected[i][j] is either 0 or 1.\nThere is always a contiguous viral region throughout the described process that will infect strictly more uncontaminated squares in the next round.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def containVirus(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        res = 0\n        self.walls = {}\n    \n        while True:\n            lst = self.findRegions(grid)\n            if not lst: return res\n            \n            for i, j in lst:\n                for ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if (i, j, ii, jj) not in self.walls and 0 <= ii < len(grid) and 0 <= jj < len(grid[0]) and grid[ii][jj] == 0:\n                        res += 1\n                        self.walls[(i, j, ii, jj)] = 1\n                        self.walls[(ii, jj, i, j)] = 1\n                        # print i, j, ii, jj\n            # print 'aaa'\n            for i, j in lst:\n                grid[i][j] = 2\n\n            self.spread(grid)\n    \n    def findRegions(self, grid):\n        tmp = []\n        num = -1\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    lst, affect = self.findRegion(grid, i, j)\n                    num1 = len(set(affect))\n                    \n                    if num1 > num:\n                        tmp = lst\n                        num = num1\n                        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                grid[i][j] %= 10\n                \n        return tmp\n    \n    def findRegion(self, grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]): return [], []\n        \n        if grid[i][j] == 0: return [], [(i, j)]\n        \n        if grid[i][j] != 1: return [], []\n        \n        res = [(i, j)]\n        affect = []\n        grid[i][j] += 10\n        \n        for ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n            if (i, j, ii, jj) not in self.walls:\n                res1, a1 = self.findRegion(grid, ii, jj)\n                res += res1\n                affect += a1\n        \n        return res, affect\n        \n    \n    def spread(self, grid):\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    for ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                        if (i, j, ii, jj) not in self.walls and 0 <= ii < len(grid) and 0 <= jj < len(grid[0]) and grid[ii][jj] == 0:\n                            grid[ii][jj] = 11\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                grid[i][j] %= 10\n\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2735", "label": "code_high", "messages": [{"role": "user", "content": "Can you implement a function in Python 3 that\n\nA virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\nThe world is modeled as an m x n binary grid isInfected, where isInfected[i][j] == 0 represents uninfected cells, and isInfected[i][j] == 1 represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There will never be a tie.\nReturn the number of walls used to quarantine all the infected regions. If the world will become fully infected, return the number of walls used.\n\u00a0\nExample 1:\n\nInput: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]\nOutput: 10\nExplanation: There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n\nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n\n\nExample 2:\n\nInput: isInfected = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 4\nExplanation: Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n\nExample 3:\nInput: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]\nOutput: 13\nExplanation: The region on the left only builds two new walls.\n\n\u00a0\nConstraints:\n\nm ==\u00a0isInfected.length\nn ==\u00a0isInfected[i].length\n1 <= m, n <= 50\nisInfected[i][j] is either 0 or 1.\nThere is always a contiguous viral region throughout the described process that will infect strictly more uncontaminated squares in the next round.\n\n"}, {"role": "assistant", "content": "\nfrom copy import deepcopy\n\nclass Solution:\n    def containVirus(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        a = grid\n        for i in range(m):\n            for j in range(n):\n                if a[i][j] == 0:\n                    a[i][j] = 'S'\n                elif a[i][j] == 1:\n                    a[i][j] = 'C'\n        n_walls = 0\n        while True:\n            #print(''.join(''.join(b) + '\\n' for b in a))\n            #print('-----------------------------------')\n            max_contam = (0, (-1, -1))\n            if sum(sum(1 for x in b if x == 'S') for b in a) == 0:\n                break\n            for i in range(m):\n                for j in range(n):\n                    if a[i][j] != 'C':\n                        continue\n                    #a = deepcopy(orig_a)\n                    stack = [(i, j)]\n                    contams = set()\n                    oi, oj = i, j\n                    while stack:\n                        i, j = stack.pop()\n                        if a[i][j] == 'S':\n                            contams.add((i, j))\n                            continue\n                        elif a[i][j] != 'C':\n                            continue\n                        a[i][j] = 'X'\n                        stack.append((i, j + 1)) if j + 1 < n else 0\n                        stack.append((i, j - 1)) if j > 0 else 0\n                        stack.append((i + 1, j)) if i + 1 < m else 0\n                        stack.append((i - 1, j)) if i > 0 else 0\n                    max_contam = max(max_contam, (len(contams), (oi, oj)))\n            if max_contam[0] == 0 or max_contam[0] == m * n:\n                break\n            #print(max_contam)\n            #print(''.join(''.join(b) + '\\n' for b in a))\n            #print('-----------------------------------')\n            for i in range(m):\n                for j in range(n):\n                    if a[i][j] == 'X':\n                        a[i][j] = 'C'\n            for i in [max_contam[1][0]]:\n                for j in [max_contam[1][1]]:\n                    more_walls = 0\n                    if a[i][j] != 'C':\n                        continue\n                    #a = deepcopy(orig_a)\n                    stack = [(i, j)]\n                    contams = set()\n                    while stack:\n                        i, j = stack.pop()\n                        if a[i][j] == 'S':\n                            more_walls += 1\n                            contams.add((i, j))\n                            continue\n                        elif a[i][j] != 'C':\n                            continue\n                        a[i][j] = 'W'\n                        stack.append((i, j + 1)) if j + 1 < n else 0\n                        stack.append((i, j - 1)) if j > 0 else 0\n                        stack.append((i + 1, j)) if i + 1 < m else 0\n                        stack.append((i - 1, j)) if i > 0 else 0\n            #print(more_walls)\n            #print(''.join(''.join(b) + '\\n' for b in a))\n            #print('-----------------------------------')\n            n_walls += more_walls\n\n            a1 = deepcopy(a)\n            for i in range(m):\n                for j in range(n):\n                    if a[i][j] == 'C':\n                        if j + 1 < n and a[i][j + 1] == 'S':\n                            a1[i][j + 1] = 'C'\n                        if j > 0 and a[i][j - 1] == 'S':\n                            a1[i][j - 1] = 'C'\n                        if i + 1 < m and a[i + 1][j] == 'S':\n                            a1[i + 1][j] = 'C'\n                        if i > 0 and a[i - 1][j] == 'S':\n                            a1[i - 1][j] = 'C'\n            a = a1\n        return n_walls"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2749", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 3 program that\n\nGiven an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col].\nThe rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:\n\nThe rank is an integer starting from 1.\nIf two elements p and q are in the same row or column, then:\n\t\nIf p < q then rank(p) < rank(q)\nIf p == q then rank(p) == rank(q)\nIf p > q then rank(p) > rank(q)\n\n\nThe rank should be as small as possible.\n\nThe test cases are generated so that answer is unique under the given rules.\n\u00a0\nExample 1:\n\nInput: matrix = [[1,2],[3,4]]\nOutput: [[1,2],[2,3]]\nExplanation:\nThe rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.\nThe rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1.\nThe rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1.\nThe rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1], matrix[1][1] > matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.\n\nExample 2:\n\nInput: matrix = [[7,7],[7,7]]\nOutput: [[1,1],[1,1]]\n\nExample 3:\n\nInput: matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]\nOutput: [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]\n\n\u00a0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 500\n-10^9 <= matrix[row][col] <= 10^9\n\n"}, {"role": "assistant", "content": "# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n# https://www.youtube.com/watch?v=VLwVU3Bi0Ek\n\nclass Solution:\n    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n        ret = [row[:] for row in matrix]\n        order = sorted([(matrix[i][j],i,j) for i in range(len(matrix)) for j in range(len(matrix[0]))])\n        row,col=[0]*len(matrix),[0]*len(matrix[0])\n        idx = 0\n        def get_groups(lst):\n            # take list of ij\n            dic = defaultdict(list)\n            # group by i\n            i_dic = defaultdict(list)\n            j_dic = defaultdict(list)\n            for idx in range(len(lst)):\n                i_dic[lst[idx][0]].append(idx)\n            for idx in range(len(lst)):\n                j_dic[lst[idx][1]].append(idx)\n            for entry in i_dic.values():\n                for idx in range(len(entry)-1):\n                    dic[entry[idx]].append(entry[idx+1])\n                    dic[entry[idx+1]].append(entry[idx])\n            for entry in j_dic.values():\n                for idx in range(len(entry)-1):\n                    dic[entry[idx]].append(entry[idx+1])\n                    dic[entry[idx+1]].append(entry[idx])\n            # print(dic)\n            ret = []\n            seen = set()\n            def dfs(idx):\n                if idx in seen:\n                    return\n                seen.add(idx)\n                ret[-1].append(lst[idx])\n                for nxt in dic[idx]:\n                    dfs(nxt)\n            for idx in range(len(lst)):\n                if idx in seen:\n                    continue\n                ret.append([])\n                dfs(idx)\n            return ret\n            \n                \n        while idx < len(order):\n            val = order[idx][0]\n            # they all get the same shit\n            locs = []\n            \n            while idx < len(order) and order[idx][0] == val:\n                i,j=order[idx][1],order[idx][2]\n                # new_val = max(new_val,row[i]+1,col[j]+1)\n                locs.append([i,j])\n                idx += 1\n            # figure out new val for these by group\n            groups = get_groups(locs)\n            # print(groups)\n            for grp in groups:\n                new_val = 1\n                for i,j in grp:\n                    new_val = max(new_val,row[i]+1,col[j]+1)\n                for i,j in grp:\n                    ret[i][j] = new_val\n                    row[i] = new_val\n                    col[j] = new_val\n        return ret\n                \n        # 1 2\n        # 3 3\n        \n        # 1 2\n        # 3 3"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2750", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 2 to\n\nGiven an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col].\nThe rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:\n\nThe rank is an integer starting from 1.\nIf two elements p and q are in the same row or column, then:\n\t\nIf p < q then rank(p) < rank(q)\nIf p == q then rank(p) == rank(q)\nIf p > q then rank(p) > rank(q)\n\n\nThe rank should be as small as possible.\n\nThe test cases are generated so that answer is unique under the given rules.\n\u00a0\nExample 1:\n\nInput: matrix = [[1,2],[3,4]]\nOutput: [[1,2],[2,3]]\nExplanation:\nThe rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.\nThe rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1.\nThe rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1.\nThe rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1], matrix[1][1] > matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.\n\nExample 2:\n\nInput: matrix = [[7,7],[7,7]]\nOutput: [[1,1],[1,1]]\n\nExample 3:\n\nInput: matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]\nOutput: [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]\n\n\u00a0\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 500\n-10^9 <= matrix[row][col] <= 10^9\n\n"}, {"role": "assistant", "content": "from collections import defaultdict, Counter, deque\nclass Solution(object):\n    def matrixRankTransform(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        arr = matrix\n        n, m = len(arr), len(arr[0])\n        loc = defaultdict(list)\n        adj = defaultdict(list)\n        for i, row in enumerate(arr):\n            for j, val in enumerate(row):\n                loc[(0,i,val)].append((i,j))\n                loc[(1,j,val)].append((i,j))\n                adj[(0,i,val)].append((1,j,val))\n                adj[(1,j,val)].append((0,i,val))\n        comp = {}\n        comp_id = 0\n        for i, row in enumerate(arr):\n            for j, val in enumerate(row):\n                src = (0,i,val)\n                if src in comp: continue\n                q = deque()\n                q.append(src)\n                comp[src] = comp_id\n                while q:\n                    u = q.popleft()\n                    for v in adj[u]:\n                        if v in comp: continue\n                        q.append(v)\n                        comp[v] = comp_id\n                comp_id += 1\n\n        dep = [[] for _ in xrange(comp_id)]\n        deg = [0]*comp_id\n        for i in xrange(n):\n            s = sorted(set(arr[i][j] for j in xrange(m)))\n            for k in xrange(1, len(s)):\n                src = comp[(0,i,s[k-1])]\n                dst = comp[(0,i,s[k])]\n                dep[src].append(dst)\n                deg[dst] += 1\n        for j in xrange(m):\n            s = sorted(set(arr[i][j] for i in xrange(n)))\n            for k in xrange(1, len(s)):\n                src = comp[(1,j,s[k-1])]\n                dst = comp[(1,j,s[k])]\n                dep[src].append(dst)\n                deg[dst] += 1\n\n        q = [u for u in xrange(comp_id) if deg[u] == 0]\n        rank = 1\n        comp_rank = [0]*comp_id\n        while q:\n            qq = []\n            for u in q:\n                comp_rank[u] = rank\n                for v in dep[u]:\n                    deg[v] -= 1\n                    if deg[v] == 0:\n                        qq.append(v)\n            q = qq\n            rank += 1\n\n        res = [[0]*m for _ in xrange(n)]\n        for i, row in enumerate(arr):\n            for j, val in enumerate(row):\n                res[i][j] = comp_rank[comp[(0,i,val)]]\n        return res"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2786", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 3 to\n\nGiven a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.\nA code snippet is valid if all the following rules hold:\n\nThe code must be wrapped in a valid closed tag. Otherwise, the code is invalid.\nA closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.\nA valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.\nA valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid.\nA start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\nA < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME (not necessarily valid).\nThe cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.\nCDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.\n\n\u00a0\nExample 1:\nInput: code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\nOutput: true\nExplanation: \nThe code is wrapped in a closed tag : <DIV> and </DIV>. \nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. \nAlthough CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag.\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.\n\nExample 2:\nInput: code = \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\nOutput: true\nExplanation:\nWe first separate the code into : start_tag|tag_content|end_tag.\nstart_tag -> \"<DIV>\"\nend_tag -> \"</DIV>\"\ntag_content could also be separated into : text1|cdata|text2.\ntext1 -> \">>  ![cdata[]] \"\ncdata -> \"<![CDATA[<div>]>]]>\", where the CDATA_CONTENT is \"<div>]>\"\ntext2 -> \"]]>>]\"\nThe reason why start_tag is NOT \"<DIV>>>\" is because of the rule 6.\nThe reason why cdata is NOT \"<![CDATA[<div>]>]]>]]>\" is because of the rule 7.\n\nExample 3:\nInput: code = \"<A>  <B> </A>   </B>\"\nOutput: false\nExplanation: Unbalanced. If \"<A>\" is closed, then \"<B>\" must be unmatched, and vice versa.\n\n\u00a0\nConstraints:\n\n1 <= code.length <= 500\ncode consists of English letters, digits, '<', '>', '/', '!', '[', ']', '.', and ' '.\n\n"}, {"role": "assistant", "content": "def is_valid_ending_with(s, i, j, tag):\n    closed_tag = '</' + tag + '>'\n    if not s.endswith(closed_tag, i, j):\n        return False\n    # Skip parsing the tag.\n    i += len(tag) + 2\n    max_i = j - len(closed_tag)\n    tag_stack = []\n    while i != max_i:\n        if s[i].isspace() or s[i].isalnum() or s[i] in '>/![]':\n            pass\n        elif s[i] == '<':\n            if i + 1 >= max_i:\n                return False\n            if s[i + 1] == '/':\n                # Closing tag\n                end_i = s.find('>', i + 1, max_i)\n                if end_i == -1:\n                    return False\n                just_closed = s[i + 2:end_i]\n                if not tag_stack or tag_stack[-1] != just_closed:\n                    return False\n                tag_stack.pop()\n                i = end_i\n            elif s[i + 1] == '!':\n                # CDATA\n                if s.startswith('<![CDATA[', i, max_i):\n                    end_i = s.find(']]>', i, max_i)\n                    if end_i == -1:\n                        return False\n                    i = end_i + 2\n                else:\n                    return False\n            else:\n                # Opening tag\n                inner_tag = digest_tag(s, i, max_i)\n                if inner_tag is None:\n                    return False\n                tag_stack.append(inner_tag)\n                i += len(inner_tag) + 1\n        i += 1\n    return not tag_stack\n\n\ndef digest_tag(s, i, j):\n    if not s.startswith('<', i, j):\n        return None\n    tag = []\n    for o in range(1, 10):\n        p = i + o\n        if p >= j:\n            return None\n        if s[p].isupper():\n            tag.append(s[p])\n        elif s[p] == '>':\n            break\n        else:\n            return None\n    if not tag:\n        return None\n    return ''.join(tag)\n\n\nclass Solution(object):\n    def isValid(self, code):\n        \"\"\"\n        :type code: str\n        :rtype: bool\n        \"\"\"\n        tag = digest_tag(code, 0, len(code))\n        if tag is None:\n            return False\n        return is_valid_ending_with(code, 0, len(code), tag)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2849", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 2 program that\n\nA company is organizing a meeting and has a list of n employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees.\nThe employees are numbered from 0 to n - 1. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself.\nGiven a 0-indexed integer array favorite, where favorite[i] denotes the favorite person of the ith employee, return the maximum number of employees that can be invited to the meeting.\n\u00a0\nExample 1:\n\nInput: favorite = [2,2,1,2]\nOutput: 3\nExplanation:\nThe above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.\nAll employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.\nNote that the company can also invite employees 1, 2, and 3, and give them their desired seats.\nThe maximum number of employees that can be invited to the meeting is 3. \n\nExample 2:\nInput: favorite = [1,2,0]\nOutput: 3\nExplanation: \nEach employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.\nThe seating arrangement will be the same as that in the figure given in example 1:\n- Employee 0 will sit between employees 2 and 1.\n- Employee 1 will sit between employees 0 and 2.\n- Employee 2 will sit between employees 1 and 0.\nThe maximum number of employees that can be invited to the meeting is 3.\n\nExample 3:\n\nInput: favorite = [3,0,1,4,1]\nOutput: 4\nExplanation:\nThe above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.\nEmployee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.\nSo the company leaves them out of the meeting.\nThe maximum number of employees that can be invited to the meeting is 4.\n\n\u00a0\nConstraints:\n\nn == favorite.length\n2 <= n <= 100000\n0 <= favorite[i] <=\u00a0n - 1\nfavorite[i] != i\n\n"}, {"role": "assistant", "content": "from collections import Counter\nclass Solution(object):\n    def maximumInvitations(self, favorite):\n        \"\"\"\n        :type favorite: List[int]\n        :rtype: int\n        \"\"\"\n        a = favorite\n        n = len(a)\n        hl = [None]*n\n        cl = [None]*n\n        cs = [None]*n\n        ctl = Counter()\n        for i in xrange(n):\n            if cs[i] is not None:\n                continue\n            u = i\n            t = {}\n            path = []\n            while True:\n                if u in t:\n                    tu = t[u]\n                    clen = len(path) - tu\n                    for j in xrange(tu):\n                        hl[path[j]] = tu - j\n                        cs[path[j]] = u\n                        cl[path[j]] = clen\n                    for j in xrange(tu, len(path)):\n                        hl[path[j]] = 0\n                        cs[path[j]] = path[j]\n                        cl[path[j]] = clen\n                    ctl[u] = max(ctl[u], tu)\n                    break\n                if cs[u] is not None:\n                    l = len(path)\n                    for j in xrange(l):\n                        hl[path[j]] = hl[u]+l-j\n                        cs[path[j]] = cs[u]\n                        cl[path[j]] = cl[u]\n                    ctl[cs[u]] = max(ctl[cs[u]], hl[u]+l)\n                    break\n                t[u] = len(path)\n                path.append(u)\n                u = a[u]\n        r1 = max(cl)\n        r2 = 0\n        for i in xrange(n):\n            if cs[i] == i and cl[i] == 2 and i < a[i]:\n                r2 += ctl[i] + ctl[a[i]] + 2\n        return max(r1, r2)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2883", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 program that can\n\nYou are an ant tasked with adding n new rooms numbered 0 to n-1 to your colony. You are given the expansion plan as a 0-indexed integer array of length n, prevRoom, where prevRoom[i] indicates that you must build room prevRoom[i] before building room i, and these two rooms must be connected directly. Room 0 is already built, so prevRoom[0] = -1. The expansion\u00a0plan is given such that once all the rooms are built, every room will be reachable from room 0.\nYou can only build one room at a time, and you can travel freely between rooms you have already built only if they are connected.\u00a0You can choose to build any room as long as its previous room\u00a0is already built.\nReturn the number of different orders you can build all the rooms in. Since the answer may be large, return it modulo 10^9 + 7.\n\u00a0\nExample 1:\n\nInput: prevRoom = [-1,0,1]\nOutput: 1\nExplanation:\u00a0There is only one way to build the additional rooms: 0 \u2192 1 \u2192 2\n\nExample 2:\n\nInput: prevRoom = [-1,0,0,1,2]\nOutput: 6\nExplanation:\nThe 6 ways are:\n0 \u2192 1 \u2192 3 \u2192 2 \u2192 4\n0 \u2192 2 \u2192 4 \u2192 1 \u2192 3\n0 \u2192 1 \u2192 2 \u2192 3 \u2192 4\n0 \u2192 1 \u2192 2 \u2192 4 \u2192 3\n0 \u2192 2 \u2192 1 \u2192 3 \u2192 4\n0 \u2192 2 \u2192 1 \u2192 4 \u2192 3\n\n\u00a0\nConstraints:\n\nn == prevRoom.length\n2 <= n <= 100000\nprevRoom[0] == -1\n0 <= prevRoom[i] < n for all 1 <= i < n\nEvery room is reachable from room 0 once all the rooms are built.\n"}, {"role": "assistant", "content": "class Solution(object):\n    def fsm(self, a, b, c):\n        ans = 1\n        \n        while b > 0:\n            if b & 1:\n                ans = ans * a % c\n            a = a * a % c\n            b = b >> 1\n        \n        return ans\n    \n    def C(self, n, m):\n        return self.frac[n] * self.revfrac[m] % self.mo * self.revfrac[n-m] % self.mo\n    \n    def Dfs(self, x):\n        \n        for e in self.E[x]:\n            self.Dfs(e)\n            self.number[x] += self.number[e]\n        \n        tot = self.number[x]\n        for e in self.E[x]:\n            self.f[x] = self.f[x] * self.f[e] % self.mo * self.C(tot, self.number[e]) % self.mo\n            tot -= self.number[e]\n        \n        self.number[x] += 1\n    \n    def waysToBuildRooms(self, prevRoom):\n        \"\"\"\n        :type prevRoom: List[int]\n        :rtype: int\n        \"\"\"\n        self.mo = int(1e9+7)\n        \n        n = len(prevRoom)\n        \n        self.frac = [1] * (n+1)\n        self.revfrac = [1] * (n+1)\n        \n        for i in range(1, n+1):\n            self.frac[i] = self.frac[i-1] * i % self.mo\n        \n        self.revfrac[n] = self.fsm(self.frac[n], self.mo - 2, self.mo)\n        \n        for i in range(n-1, 0, -1):\n            self.revfrac[i] = self.revfrac[i+1] * (i+1) % self.mo\n        \n        \n        self.number = [0] * (n+1)\n        self.f = [1] * (n+1)\n        self.E = dict()\n        \n        for i in range(n):\n            self.E[i] = []\n        \n        for i in range(n):\n            if prevRoom[i] != -1:\n                self.E[prevRoom[i]].append(i)\n        \n        self.Dfs(0)\n        \n        return self.f[0] % self.mo"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2946", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 3 to\n\nIn an\u00a0n*n\u00a0grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at\u00a0(n-1, n-2)\u00a0and\u00a0(n-1, n-1).\nIn one move the snake can:\n\nMove one cell to the right\u00a0if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nMove down one cell\u00a0if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nRotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from\u00a0(r, c)\u00a0and\u00a0(r, c+1)\u00a0to\u00a0(r, c)\u00a0and\u00a0(r+1, c).\n\nRotate counterclockwise\u00a0if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from\u00a0(r, c)\u00a0and\u00a0(r+1, c)\u00a0to\u00a0(r, c)\u00a0and\u00a0(r, c+1).\n\n\nReturn the minimum number of moves to reach the target.\nIf there is no way to reach the target, return\u00a0-1.\n\u00a0\nExample 1:\n\nInput: grid = [[0,0,0,0,0,1],\n               [1,1,0,0,1,0],\n\u00a0              [0,0,0,0,1,1],\n\u00a0              [0,0,1,0,1,0],\n\u00a0              [0,1,1,0,0,0],\n\u00a0              [0,1,1,0,0,0]]\nOutput: 11\nExplanation:\nOne possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].\n\nExample 2:\nInput: grid = [[0,0,1,1,1,1],\n\u00a0              [0,0,0,0,1,1],\n\u00a0              [1,1,0,0,0,1],\n\u00a0              [1,1,1,0,0,1],\n\u00a0              [1,1,1,0,0,1],\n\u00a0              [1,1,1,0,0,0]]\nOutput: 9\n\n\u00a0\nConstraints:\n\n2 <= n <= 100\n0 <= grid[i][j] <= 1\nIt is guaranteed that the snake starts at empty cells.\n\n"}, {"role": "assistant", "content": "from collections import deque\nclass Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        que = deque([(0, 0, 0)])\n        used = [[[-1]*N for i in range(N)] for j in range(2)]\n        used[0][0][0] = 0\n        while que:\n            p, c, r = que.popleft()\n            d = used[p][c][r] + 1\n            if p == 0:\n                if r+2 < N and grid[c][r+2] == 0 and used[0][c][r+1] == -1:\n                    used[0][c][r+1] = d\n                    que.append((0, c, r+1))\n                if c+1 < N and grid[c+1][r] == grid[c+1][r+1] == 0 and used[0][c+1][r] == -1:\n                    used[0][c+1][r] = d\n                    que.append((0, c+1, r))\n                if c+1 < N and grid[c+1][r] == grid[c+1][r+1] == 0 and used[1][c][r] == -1:\n                    used[1][c][r] = d\n                    que.append((1, c, r))\n            else:\n                if r+1 < N and grid[c][r+1] == grid[c+1][r+1] == 0 and used[1][c][r+1] == -1:\n                    used[1][c][r+1] = d\n                    que.append((1, c, r+1))\n                if c+2 < N and grid[c+2][r] == 0 and used[1][c+1][r] == -1:\n                    used[1][c+1][r] = d\n                    que.append((1, c+1, r))\n                if r+1 < N and grid[c][r+1] == grid[c+1][r+1] == 0 and used[0][c][r] == -1:\n                    used[0][c][r] = d\n                    que.append((0, c, r))\n        return used[0][N-1][N-2]\n                    \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2971", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 2 to\n\nThere is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\nReturn a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.\n\u00a0\nExample 1:\n\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\nExplanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n[0,4]: [0,4] -> Pacific Ocean \n\u00a0      [0,4] -> Atlantic Ocean\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \n\u00a0      [1,3] -> [1,4] -> Atlantic Ocean\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \n\u00a0      [1,4] -> Atlantic Ocean\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \n\u00a0      [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n[3,0]: [3,0] -> Pacific Ocean \n\u00a0      [3,0] -> [4,0] -> Atlantic Ocean\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \n\u00a0      [3,1] -> [4,1] -> Atlantic Ocean\n[4,0]: [4,0] -> Pacific Ocean \n       [4,0] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n\nExample 2:\nInput: heights = [[1]]\nOutput: [[0,0]]\nExplanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\n\n\u00a0\nConstraints:\n\nm == heights.length\nn == heights[r].length\n1 <= m, n <= 200\n0 <= heights[r][c] <= 100000\n\n"}, {"role": "assistant", "content": "class Solution(object):\r\n\tdef walk(self,x,y,z,m,h,w,q,r):\r\n\t\tif x>=h or x < 0 or y>=w or y < 0:\r\n\t\t\treturn\r\n\t\tif r[x][y]:\r\n\t\t\treturn\r\n\t\tif m[x][y]<z:\r\n\t\t\treturn\r\n\t\tr[x][y]=True\r\n\t\tq.append((x,y))\r\n\t\r\n\tdef bfs(self, m, h, w, q):\r\n\t\tr=[[False for a in range(w)] for b in range(h)]\r\n\t\tfor a in q:\r\n\t\t\tr[a[0]][a[1]]=True\r\n\t\ta=0\r\n\t\twhile a < len(q):\r\n\t\t\tq0=q[a]\r\n\t\t\ta+=1\r\n\t\t\tz=m[q0[0]][q0[1]]\r\n\t\t\tself.walk(q0[0]+1,q0[1],z,m,h,w,q,r)\r\n\t\t\tself.walk(q0[0]-1,q0[1],z,m,h,w,q,r)\r\n\t\t\tself.walk(q0[0],q0[1]+1,z,m,h,w,q,r)\r\n\t\t\tself.walk(q0[0],q0[1]-1,z,m,h,w,q,r)\r\n\t\treturn r\r\n\t\t\r\n\tdef pacificAtlantic(self, m):\r\n\t\t\"\"\"\r\n\t\t:type matrix: List[List[int]]\r\n\t\t:rtype: List[List[int]]\r\n\t\t\"\"\"\r\n\t\th=len(m)\r\n\t\tif h == 0:\r\n\t\t\treturn []\r\n\t\tw=len(m[0])\r\n\t\tif w == 0:\r\n\t\t\treturn []\r\n\r\n\t\tq=[]\r\n\t\tfor a in range(h):\r\n\t\t\tq.append([a,0])\r\n\t\tfor a in range(1,w):\r\n\t\t\tq.append([0,a])\r\n\t\tm1=self.bfs(m,h,w,q)\r\n\r\n\t\tq=[]\r\n\t\tfor a in range(h):\r\n\t\t\tq.append([a,w-1])\r\n\t\tfor a in range(0,w-1):\r\n\t\t\tq.append([h-1,a])\r\n\t\tm2=self.bfs(m,h,w,q)\r\n\t\tans=[]\r\n\t\tfor a in range(h):\r\n\t\t\tfor b in range(w):\r\n\t\t\t\tif m1[a][b] and m2[a][b]:\r\n\t\t\t\t\tans.append([a,b])\r\n\t\treturn ans\r\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_2992", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 2 that\n\nThere are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.\nThe positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\nAt any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.\nReturn the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired.\nNote that\n\nAll robots move at the same speed.\nIf two robots move in the same direction, they will never collide.\nIf two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.\nIf a robot passes by a factory that reached its limits, it crosses it as if it does not exist.\nIf the robot moved from a position x to a position y, the distance it moved is |y - x|.\n\n\u00a0\nExample 1:\n\nInput: robot = [0,4,6], factory = [[2,2],[6,2]]\nOutput: 4\nExplanation: As shown in the figure:\n- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.\n- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.\n- The third robot at position 6 will be repaired at the second factory. It does not need to move.\nThe limit of the first factory is 2, and it fixed 2 robots.\nThe limit of the second factory is 2, and it fixed 1 robot.\nThe total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.\n\nExample 2:\n\nInput: robot = [1,-1], factory = [[-2,1],[2,1]]\nOutput: 2\nExplanation: As shown in the figure:\n- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.\n- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\nThe limit of the first factory is 1, and it fixed 1 robot.\nThe limit of the second factory is 1, and it fixed 1 robot.\nThe total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.\n\n\u00a0\nConstraints:\n\n1 <= robot.length, factory.length <= 100\nfactory[j].length == 2\n-10^9 <= robot[i], positionj <= 10^9\n0 <= limitj <= robot.length\nThe input will be generated such that it is always possible to repair every robot.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def minimumTotalDistance(self, robot, factory):\n        \"\"\"\n        :type robot: List[int]\n        :type factory: List[List[int]]\n        :rtype: int\n        \"\"\"\n        a, p, s, m, f, n, t = [float('inf')], [0] * len(factory), 0, [0] * len(factory), [[0] * len(robot) for _ in factory], [[None] * len(factory) for _ in robot], 0\n        def u(v, f):\n            if v == len(robot):\n                return 0\n            elif f == len(factory) or m[f] < len(robot) - v:\n                return a[0]\n            elif n[v][f] != None:\n                return n[v][f]\n            l, r = 0, min(len(robot) - v, factory[f][1])\n            while r - l > 1:\n                r = (l + r) / 2 if g(v, f, (l + r) / 2) < g(v, f, (l + r) / 2 + 1) else r\n                l = l if g(v, f, (l + r) / 2) < g(v, f, (l + r) / 2 + 1) else (l + r) / 2\n            n[v][f] = min(g(v, f, l), g(v, f, r))\n            return n[v][f]\n        def g(r, g, v):\n            return a[0] if u(r + v, g + 1) == a[0] else (f[g][r + v - 1] if r + v else 0) - (f[g][r - 1] if r else 0) + u(r + v, g + 1)\n        robot.sort()\n        factory.sort()\n        for i in range(len(factory) - 1, -1, -1):\n            s, m[i] = s + factory[i][1], s + factory[i][1]\n        for i in range(len(factory)):\n            s = 0\n            for j in range(len(robot)):\n                s, f[i][j] = s + abs(robot[j] - factory[i][0]), s + abs(robot[j] - factory[i][0])\n        for i in range(len(p)):\n            t, p[i] = t + factory[i][1], t + factory[i][1]\n        return u(0, 0)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3095", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 2 to\n\nYou are playing a variation of the game Zuma.\nIn this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. You also have several colored balls in your hand.\nYour goal is to clear all of the balls from the board. On each turn:\n\nPick any ball from your hand and insert it in between two balls in the row or on either end of the row.\nIf there is a group of three or more consecutive balls of the same color, remove the group of balls from the board.\n\t\nIf this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.\n\n\nIf there are no more balls on the board, then you win the game.\nRepeat this process until you either win or do not have any more balls in your hand.\n\nGiven a string board, representing the row of balls on the board, and a string hand, representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.\n\u00a0\nExample 1:\nInput: board = \"WRRBBW\", hand = \"RB\"\nOutput: -1\nExplanation: It is impossible to clear all the balls. The best you can do is:\n- Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n- Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\nThere are still balls remaining on the board, and you are out of balls to insert.\nExample 2:\nInput: board = \"WWRRBBWW\", hand = \"WRBRW\"\nOutput: 2\nExplanation: To make the board empty:\n- Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.\n- Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.\n2 balls from your hand were needed to clear the board.\n\nExample 3:\nInput: board = \"G\", hand = \"GGGGG\"\nOutput: 2\nExplanation: To make the board empty:\n- Insert 'G' so the board becomes GG.\n- Insert 'G' so the board becomes GGG. GGG -> empty.\n2 balls from your hand were needed to clear the board.\n\n\u00a0\nConstraints:\n\n1 <= board.length <= 16\n1 <= hand.length <= 5\nboard and hand consist of the characters 'R', 'Y', 'B', 'G', and 'W'.\nThe initial row of balls on the board will not have any groups of three or more consecutive balls of the same color.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def __init__(self):\n        self.visit = set([])\n        self.res = 10 ** 10\n        \n    def findMinStep(self, board, hand):\n        hand = sorted(hand)\n        board = list(board)\n        st = [(board, hand, 0)]\n        while st:\n            board, hand, step = st.pop()\n            if step > self.res:\n                continue\n            \n            for i in xrange(len(hand)):\n                if i and hand[i - 1] == hand[i]:\n                    continue\n                for j in xrange(len(board)):\n                    if j and board[j - 1] == board[j]:\n                        continue\n                    if board[j] == hand[i]:\n                        nboard = board[:j] + [hand[i]] + board[j:]\n                        nhand = hand[:]\n                        del(nhand[i])\n                        nboard = self.eliminate(nboard)\n                        \n                        if nboard == []:\n                            self.res = min(self.res, step + 1)\n                        else:\n                            st.append((nboard, nhand, step + 1))\n                            \n        return -1 if self.res >= 10 ** 10 else self.res\n    \n    def eliminate(self, board):\n        board.append('X')\n        while True:\n            flag = False\n            l, r = 0, 0\n            n = len(board)\n            for i in xrange(len(board)):\n                if i and board[i] == board[i - 1]:\n                    r = i + 1\n                elif board[i] != board[i - 1]:\n                    if r - l >= 3:\n                        board = board[:l] + board[r:]\n                        flag = True\n                        break\n                    else:\n                        l, r = i, i + 1\n            if not flag:\n                break\n        return board[:-1]\n\n\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3130", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 3 function for\n\nYou are given two 0-indexed arrays nums1 and nums2 and a 2D array queries of queries. There are three types of queries:\n\nFor a query of type 1, queries[i]\u00a0= [1, l, r]. Flip the values from 0 to 1 and from 1 to 0 in nums1 from index l to index r. Both l and r are 0-indexed.\nFor a query of type 2, queries[i]\u00a0= [2, p, 0]. For every index 0 <= i < n, set\u00a0nums2[i] =\u00a0nums2[i]\u00a0+ nums1[i]\u00a0* p.\nFor a query of type 3, queries[i]\u00a0= [3, 0, 0]. Find the sum of the elements in nums2.\n\nReturn an array containing all the answers to the third type\u00a0queries.\n\u00a0\nExample 1:\nInput: nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]\nOutput: [3]\nExplanation: After the first query nums1 becomes [1,1,1]. After the second query, nums2 becomes [1,1,1], so the answer to the third query is 3. Thus, [3] is returned.\n\nExample 2:\nInput: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]\nOutput: [5]\nExplanation: After the first query, nums2 remains [5], so the answer to the second query is 5. Thus, [5] is returned.\n\n\u00a0\nConstraints:\n\n1 <= nums1.length,nums2.length <= 100000\nnums1.length = nums2.length\n1 <= queries.length <= 100000\nqueries[i].length = 3\n0 <= l <= r <= nums1.length - 1\n0 <= p <= 1000000\n0 <= nums1[i] <= 1\n0 <= nums2[i] <= 10^9\n\n"}, {"role": "assistant", "content": "class Solution:\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        ans = []\n        n = len(nums1)\n        seg = LazySegmentTree(nums1)\n        tot = sum(nums2)\n        for t, l, r in queries:\n            if t == 1: seg.update(l, r)\n            elif t == 2: tot += seg.query(0, n-1) * l\n            else: ans.append(tot)\n        return ans\n\nclass LazySegmentTree:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums\n        self.ones = [0] * (4 * self.n)\n        self.lazy = [True] * (4 * self.n)\n        self._build(0, 0, self.n-1)\n \n    def _build(self, tree_index, l, r):\n        if l == r:\n            self.ones[tree_index] = self.nums[l]\n            return\n        left, right = 2 * tree_index + 1, 2 * tree_index + 2\n        mid = (l + r) // 2\n        self._build(left, l, mid)\n        self._build(right, mid+1, r)\n        self.ones[tree_index] = self.ones[left] + self.ones[right]\n \n    def update(self, ql, qr):\n        self._update(0, 0, self.n-1, ql, qr)\n \n    def _update(self, tree_index, l, r, ql, qr):\n        if l == ql and r == qr:\n            self.lazy[tree_index] = not self.lazy[tree_index]\n            ones = self.ones[tree_index]\n            zeros = r - l + 1 - ones\n            self.ones[tree_index] = zeros\n            return\n        left, right = 2 * tree_index + 1, 2 * tree_index + 2\n        mid = (l + r) // 2\n        if not self.lazy[tree_index]:\n            self._update(left, l, mid, l, mid)\n            self._update(right, mid+1, r, mid+1, r)\n            self.lazy[tree_index] = True\n        if qr <= mid: self._update(left, l, mid, ql, qr)\n        elif ql > mid: self._update(right, mid+1, r, ql, qr)\n        else:\n            self._update(left, l, mid, ql, mid)\n            self._update(right, mid+1, r, mid+1, qr)\n        self.ones[tree_index] = self.ones[left] + self.ones[right]\n \n    def query(self, ql, qr):\n        return self._query(0, 0, self.n-1, ql, qr)\n \n    def _query(self, tree_index, l, r, ql, qr):\n        if l == ql and r == qr:\n            return self.ones[tree_index]\n        left, right = 2 * tree_index + 1, 2 * tree_index + 2\n        mid = (l + r) // 2\n        if not self.lazy[tree_index]:\n            self._update(left, l, mid, l, mid)\n            self._update(right, mid+1, r, mid+1, r)\n            self.lazy[tree_index] = True\n        if qr <= mid: return self._query(left, l, mid, ql, qr)\n        if ql > mid: return self._query(right, mid+1, r, ql, qr)\n        ones1 = self._query(left, l, mid, ql, mid)\n        ones2 = self._query(right, mid+1, r, mid+1, qr)\n        return ones1 + ones2"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3132", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 2 to\n\nYou are given two 0-indexed arrays nums1 and nums2 and a 2D array queries of queries. There are three types of queries:\n\nFor a query of type 1, queries[i]\u00a0= [1, l, r]. Flip the values from 0 to 1 and from 1 to 0 in nums1 from index l to index r. Both l and r are 0-indexed.\nFor a query of type 2, queries[i]\u00a0= [2, p, 0]. For every index 0 <= i < n, set\u00a0nums2[i] =\u00a0nums2[i]\u00a0+ nums1[i]\u00a0* p.\nFor a query of type 3, queries[i]\u00a0= [3, 0, 0]. Find the sum of the elements in nums2.\n\nReturn an array containing all the answers to the third type\u00a0queries.\n\u00a0\nExample 1:\nInput: nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]\nOutput: [3]\nExplanation: After the first query nums1 becomes [1,1,1]. After the second query, nums2 becomes [1,1,1], so the answer to the third query is 3. Thus, [3] is returned.\n\nExample 2:\nInput: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]\nOutput: [5]\nExplanation: After the first query, nums2 remains [5], so the answer to the second query is 5. Thus, [5] is returned.\n\n\u00a0\nConstraints:\n\n1 <= nums1.length,nums2.length <= 100000\nnums1.length = nums2.length\n1 <= queries.length <= 100000\nqueries[i].length = 3\n0 <= l <= r <= nums1.length - 1\n0 <= p <= 1000000\n0 <= nums1[i] <= 1\n0 <= nums2[i] <= 10^9\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def handleQuery(self, nums1, nums2, queries):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums1)\n        mx = 1\n        while mx<=n: mx<<=1\n        ix = [0]*(mx+mx)\n        ss = [0]*(mx+mx)\n        mk = [0]*(mx+mx)\n        def flip(k, d, s, e):\n            if s==0 and e==d-1:\n                mk[k]^=1\n                ix[k]=d-ix[k]\n                return\n            k1=k*2\n            k2=k1+1\n            d>>=1\n            if mk[k]:\n                mk[k1]^=1\n                ix[k1]=d-ix[k1]\n                mk[k2]^=1\n                ix[k2]=d-ix[k2]\n                mk[k]=0\n            if e<d:\n                flip(k1, d, s, e)\n            elif s>=d:\n                flip(k2, d, s-d, e-d)\n            else:\n                flip(k1, d, s, d-1)\n                flip(k2, d, 0, e-d)\n            ix[k]=ix[k1]+ix[k2]\n        for i in range(n): ix[i+mx]=nums1[i]\n        i=mx-1\n        while i>0:\n            ix[i]=ix[i*2]+ix[i*2+1]\n            i-=1\n            \n        r = []\n        s = sum(nums2)\n        for t, a, b in queries:\n            if t==1:\n                flip(1, mx, a, b)\n            elif t==2:\n                c = ix[1]\n                s+=c*a\n            else: r.append(s)\n        return r"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3137", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 2 function for\n\nThere is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.\n\u00a0\nExample 1:\n\nInput: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.\n\nExample 2:\nInput: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted.\n\n\u00a0\nConstraints:\n\n1 <= n <= 2 * 10000\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def componentValue(self, nums, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        s, m, g, a, j = 0, 0, [[] for _ in nums], 0, 1\n        def d(n, p, s):\n            a = nums[n]\n            for x in g[n]:\n                if x != p:\n                    h = d(x, n, s)\n                    if h == -1:\n                        return -1\n                    a += h\n            if a > s:\n                return -1\n            if a == s:\n                return 0\n            return a\n        for i in range(len(nums)):\n            s, m = s + nums[i], max(m, nums[i])\n        for e, f in edges:\n            g[e].append(f)\n            g[f].append(e)\n        while j * j <= s:\n            a, j = max(a, s / j - 1 if not s % j and j >= m and not d(0, -1, j) else 0, j - 1 if not s % j and s / j != j and s / j >= m and not d(0, -1, s / j) else 0), j + 1\n        return a"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3160", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 2 that\n\nThe variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.\nGiven a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.\nA substring is a contiguous sequence of characters within a string.\n\u00a0\nExample 1:\nInput: s = \"aababbb\"\nOutput: 3\nExplanation:\nAll possible variances along with their respective substrings are listed below:\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and \"babb\".\n- Variance 3 for substring \"babbb\".\nSince the largest possible variance is 3, we return it.\n\nExample 2:\nInput: s = \"abcde\"\nOutput: 0\nExplanation:\nNo letter occurs more than once in s, so the variance of every substring is 0.\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 10000\ns consists of lowercase English letters.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def largestVariance(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        r=0\n        s=[ord(c)-ord('a') for c in s]\n        mk = [0]*26\n        for c in s: mk[c]+=1\n        n = len(s)\n        vs = [0]*(n+1)\n        def calc(k1, k2):\n            i, m=0, 0\n            while i<n:\n                if s[i]==k1:\n                    vs[m]=1\n                    m+=1\n                elif s[i]==k2:\n                    vs[m]=-1\n                    m+=1\n                i+=1\n            c1, c2 = 0, 0\n            i, j = 0, 0\n            p = -1\n            mv = 0\n            rx=0\n            while i<m:\n                while i<m:\n                    c1+=vs[i]\n                    if vs[i]==-1:\n                        if c1+i+1>0:\n                            rx=max(rx, c1-mv)\n                        p=i\n                    elif p!=-1:\n                        i+=1\n                        break\n                    i+=1\n                if p==-1: break\n                while j<p:\n                    c2+=vs[j]\n                    mv = min(c2, mv)\n                    j+=1\n                rx=max(rx, c1-mv)\n            return rx \n            \n        for k1 in range(26):\n            if mk[k1]==0: continue\n            for k2 in range(26):\n                if mk[k2]==0: continue\n                if mk[k1]<=r: continue\n                if k1==k2: continue\n                t=calc(k1, k2)\n                r=max(r, t)\n        return r"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3183", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 script for\n\nYou are given an integer n. There is an undirected graph with n vertices, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting vertices ai and bi.\nReturn the number of complete connected components of the graph.\nA connected component is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.\nA connected component is said to be complete if there exists an edge between every pair of its vertices.\n\u00a0\nExample 1:\n\nInput: n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]\nOutput: 3\nExplanation: From the picture above, one can see that all of the components of this graph are complete.\n\nExample 2:\n\nInput: n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]\nOutput: 1\nExplanation: The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1.\n\n\u00a0\nConstraints:\n\n1 <= n <= 50\n0 <= edges.length <= n * (n - 1) / 2\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\nThere are no repeated edges.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def countCompleteComponents(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        class D:\n            def __init__(self, n):\n                self.p, self.c = [0] * n, [0] * n\n                for i in range(n):\n                    self.p[i], self.c[i] = i, 1\n            def f(self, a):\n                r = self.p[a]\n                while r != self.p[r]:\n                    r = self.p[r]\n                while a != self.p[a]:\n                    a, self.p[a] = self.p[a], r\n                return r\n            def u(self, a, b):\n                if self.f(a) != self.f(b):\n                    if self.c[self.f(a)] >= self.c[self.f(b)]:\n                        self.c[self.f(a)], self.p[self.f(b)] = self.c[self.f(a)] + self.c[self.f(b)], self.f(a)\n                    else:\n                        self.c[self.f(b)], self.p[self.f(a)] = self.c[self.f(b)] + self.c[self.f(a)], self.f(b)\n            def g(self, a):\n                return self.c[self.f(a)]\n        d, c, g, r = D(n), [0] * n, [0] * n, 0\n        for e, f in edges:\n            d.u(e, f)\n        for i in range(n):\n            c[d.f(i)] = d.g(d.f(i))\n        for e in edges:\n            g[d.f(e[0])] += 1\n        for i in range(n):\n            r += 1 if c[i] > 0 and g[i] == c[i] * (c[i] - 1) / 2 else 0\n        return r"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3187", "label": "code_high", "messages": [{"role": "user", "content": "Can you implement a function in Python 2 that\n\nThere are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. There exists a unique path between each pair of cities. In other words, the cities form a tree.\nA subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\nFor each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.\nReturn an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.\nNotice\u00a0that\u00a0the distance between the two cities is the number of edges in the path between them.\n\u00a0\nExample 1:\n\nInput: n = 4, edges = [[1,2],[2,3],[2,4]]\nOutput: [3,4,0]\nExplanation:\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\nExample 2:\nInput: n = 2, edges = [[1,2]]\nOutput: [1]\n\nExample 3:\nInput: n = 3, edges = [[1,2],[2,3]]\nOutput: [2,1]\n\n\u00a0\nConstraints:\n\n2 <= n <= 15\nedges.length == n-1\nedges[i].length == 2\n1 <= ui, vi <= n\nAll pairs (ui, vi) are distinct.\n"}, {"role": "assistant", "content": "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        return True\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\nclass Solution(object):\n    def countSubgraphsForEachDiameter(self, N, edges):\n        graph = [[] for _ in xrange(N)]\n        \n        for i,(u,v)  in enumerate(edges):\n            u-=1\n            v-=1\n            graph[u].append(v)\n            graph[v].append(u)\n            edges[i] = [u,v]\n        #dsu = DSU()\n        def bfs(source, mask):\n            queue = [[source, None, 0]]\n            \n            for node, par, d in queue:\n                for nei in graph[node]:\n                    if nei != par and mask[nei] == '1':\n                        queue.append([nei, node, d + 1])\n            return node, d\n\n        ans = [0] * N\n        for mask in xrange(1, 1 << N):\n            bmask = bin(mask)[2:][::-1]\n            if len(bmask) < N:\n                bmask = bmask + '0' * (N - len(bmask))\n            popcount = bmask.count('1')\n            root = bmask.index('1')\n            ecount = 0\n            for u,v  in edges:\n                if bmask[u]==bmask[v]=='1':\n                    ecount += 1\n            if ecount + 1 == popcount:\n                # find max distance\n                # print(\"mask\", bmask, mask)\n                v1, d1 = bfs(root, bmask)\n                v2, d2 = bfs(v1, bmask)\n                ans[d2] += 1\n                \n        # print('a', ans)\n        ans.pop(0)\n        return ans"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3190", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 3 function for\n\nThere are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. There exists a unique path between each pair of cities. In other words, the cities form a tree.\nA subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\nFor each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.\nReturn an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.\nNotice\u00a0that\u00a0the distance between the two cities is the number of edges in the path between them.\n\u00a0\nExample 1:\n\nInput: n = 4, edges = [[1,2],[2,3],[2,4]]\nOutput: [3,4,0]\nExplanation:\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\nExample 2:\nInput: n = 2, edges = [[1,2]]\nOutput: [1]\n\nExample 3:\nInput: n = 3, edges = [[1,2],[2,3]]\nOutput: [2,1]\n\n\u00a0\nConstraints:\n\n2 <= n <= 15\nedges.length == n-1\nedges[i].length == 2\n1 <= ui, vi <= n\nAll pairs (ui, vi) are distinct.\n"}, {"role": "assistant", "content": "class CGraph() :\n    def __init__(self, edges) :\n        # self.du_dict   = collections.defaultdict(lambda:0)\n        self.link_dict = collections.defaultdict(lambda:[])\n\n        for s, e in edges :\n            # self.du_dict[s] += 1\n            # self.du_dict[e] += 1\n            self.link_dict[s].append(e)\n            self.link_dict[e].append(s)\n\n    def bfs(self, source, end=None, ignore_set=set()) :\n        \"\"\"\n        \u5355\u6e90\u6700\u77ed\u8def\u5f84\uff0c\u53ef\u4ee5\u8bbe\u7f6e\u662f\u5426\u6709\u7ec8\u70b9\n        \"\"\"\n        visited = {source:0}\n        to_visit = [[0, source]]\n\n        while len(to_visit) > 0 :\n            cost, pnow = to_visit.pop(0)\n            if pnow == end :\n                return cost\n            for pnext in self.link_dict[pnow] :\n                if pnext in visited :\n                    continue\n                if pnext in ignore_set :\n                    continue\n                visited[pnext] = cost+1\n                to_visit.append([cost+1, pnext])\n        return visited\n    \nclass Solution:\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        graph = CGraph(edges)\n        distances = {i:graph.bfs(i) for i in range(1, n+1)}\n        \n        to_ret = [0] * (n-1)\n        for di in range((1<<n)) :\n            its = [i+1 for i in range(n) if (1<<i) & di > 0]\n            if len(its) < 2 :\n                continue\n                \n            ig_set = set(range(1, n+1))-set(its)\n            dtt  = graph.bfs(its[0], ignore_set=ig_set)\n            if len(dtt) < len(its) :\n                continue\n\n            max_dis = 0\n            for ia in range(len(its)) :\n                for ib in range(ia+1, len(its)) :\n                    a = its[ia]\n                    b = its[ib]\n                    max_dis = max(max_dis, distances[a][b])\n            to_ret[max_dis-1] += 1\n        \n        return to_ret\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3215", "label": "code_high", "messages": [{"role": "user", "content": "Can you write a program in Python 2 where\n\nA string can be abbreviated by replacing any number of non-adjacent substrings with their lengths. For example, a string such as \"substitution\" could be abbreviated as (but not limited to):\n\n\"s10n\" (\"s ubstitutio n\")\n\"sub4u4\" (\"sub stit u tion\")\n\"12\" (\"substitution\")\n\"su3i1u2on\" (\"su bst i t u ti on\")\n\"substitution\" (no substrings replaced)\n\nNote that \"s55n\" (\"s ubsti tutio n\") is not a valid abbreviation of \"substitution\" because the replaced substrings are adjacent.\n\nThe length of an abbreviation is the number of letters that were not replaced plus the number of substrings that were replaced. For example, the abbreviation \"s10n\" has a length of 3 (2 letters + 1 substring) and \"su3i1u2on\" has a length of 9 (6 letters + 3 substrings).\n\nGiven a target string target and an array of strings dictionary, return an abbreviation of target with the shortest possible length such that it is not an abbreviation of any string in dictionary. If there are multiple shortest abbreviations, return any of them.\n\n \n\nExample 1:\n\nInput: target = \"apple\", dictionary = [\"blade\"]\nOutput: \"a4\"\nExplanation: The shortest abbreviation of \"apple\" is \"5\", but this is also an abbreviation of \"blade\".\nThe next shortest abbreviations are \"a4\" and \"4e\". \"4e\" is an abbreviation of blade while \"a4\" is not.\nHence, return \"a4\".\n\nExample 2:\n\nInput: target = \"apple\", dictionary = [\"blade\",\"plain\",\"amber\"]\nOutput: \"1p3\"\nExplanation: \"5\" is an abbreviation of both \"apple\" but also every word in the dictionary.\n\"a4\" is an abbreviation of \"apple\" but also \"amber\".\n\"4e\" is an abbreviation of \"apple\" but also \"blade\".\n\"1p3\", \"2p2\", and \"3l1\" are the next shortest abbreviations of \"apple\".\nSince none of them are abbreviations of words in the dictionary, returning any of them is correct.\n\n \n\nConstraints:\n\nm == target.length\nn == dictionary.length\n1 <= m <= 21\n0 <= n <= 1000\n1 <= dictionary[i].length <= 100\nlog2(n) + m <= 21 if n > 0\ntarget and dictionary[i] consist of lowercase English letters.\ndictionary does not contain target.\n"}, {"role": "assistant", "content": "class Solution(object):\r\n    def minAbbreviation(self, target, dictionary):\r\n        \"\"\"\r\n        :type target: str\r\n        :type dictionary: List[str]\r\n        :rtype: str\r\n        \"\"\"\r\n        ans = {}\r\n        self.dfs(ans, target, [], 0)\r\n        for i in range(1, len(target) + 1):\r\n            if i in ans:\r\n                for abbr in ans[i]:\r\n                    found = False\r\n                    for d in dictionary:\r\n                        if self.check(abbr, d):\r\n                            found = True\r\n                            break\r\n                    if not found:\r\n                        return abbr\r\n        return \"\"\r\n        \r\n    def dfs(self, ans, word, cur, i):\r\n        if i == len(word):\r\n            l = len(cur)\r\n            s = \"\".join(cur)\r\n            if not l in ans:\r\n                ans[l] = [s]\r\n            else:\r\n                ans[l].append(s)\r\n            return\r\n        for j in range(i + 1, len(word)):\r\n            cur.append(str(j - i + 1))\r\n            if j + 1 < len(word):\r\n                cur.append(word[j + 1])\r\n                self.dfs(ans, word, cur, j + 2)\r\n                cur.pop()\r\n                cur.pop()\r\n            else:\r\n                self.dfs(ans, word, cur, j + 1)\r\n                cur.pop()\r\n        cur.append(word[i])\r\n        self.dfs(ans, word, cur, i + 1)\r\n        cur.pop()\r\n            \r\n    \r\n    def check(self, abbr, word):\r\n        i = 0\r\n        j = 0\r\n        while i < len(abbr) and j < len(word):\r\n            if not self.isdigit(abbr[i]):\r\n                if abbr[i] != word[j]:\r\n                    return False\r\n                i += 1\r\n                j += 1\r\n            else:\r\n                n = 0\r\n                while i < len(abbr) and self.isdigit(abbr[i]):\r\n                    n = n * 10 + (ord(abbr[i]) - 48)\r\n                    i += 1\r\n                j += n\r\n        return i == len(abbr) and j == len(word)\r\n    \r\n    def isdigit(self, c):\r\n        return 48 <= ord(c) <= 57"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3244", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 function for\n\nYou are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts.\nYou should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.\nThe happiness of each person is calculated as follows:\n\nIntroverts start with 120 happiness and lose 30 happiness for each neighbor (introvert or extrovert).\nExtroverts start with 40 happiness and gain 20 happiness for each neighbor (introvert or extrovert).\n\nNeighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\nThe grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.\n\u00a0\nExample 1:\n\nInput: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\nOutput: 240\nExplanation: Assume the grid is 1-indexed with coordinates (row, column).\nWe can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120\n- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\nThe grid happiness is 120 + 60 + 60 = 240.\nThe above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.\n\nExample 2:\nInput: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\nOutput: 260\nExplanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80\n- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\nThe grid happiness is 90 + 80 + 90 = 260.\n\nExample 3:\nInput: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\nOutput: 240\n\n\u00a0\nConstraints:\n\n1 <= m, n <= 5\n0 <= introvertsCount, extrovertsCount <= min(m * n, 6)\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type introvertsCount: int\n        :type extrovertsCount: int\n        :rtype: int\n        \"\"\"\n        p, q = introvertsCount, extrovertsCount\n        if m < n: m, n = n, m\n        # col + counts = 11907 sx, 243 tx\n        def _dec(x):\n            r = []\n            for _ in xrange(n):\n                r.append(x%3)\n                x//=3\n            return tuple(r)\n        configs = []\n        for x in xrange(3**n):\n            a = _dec(x)\n            b = [0]*n\n            for i in xrange(n):\n                if a[i] == 0: continue\n                if i > 0: b[i-1] += 1\n                if i+1 < n: b[i+1] += 1\n            score = intro = extro = 0\n            for i in xrange(n):\n                if a[i] == 1:\n                    score += 120 - 30 * b[i]\n                    intro += 1\n                elif a[i] == 2:\n                    score += 40 + 20 * b[i]\n                    extro += 1\n            configs.append((x, intro, extro, score))\n        cross = [[0]*(3**n) for _ in xrange(3**n)]\n        for x in xrange(3**n):\n            a = _dec(x)\n            for y in xrange(3**n):\n                b = _dec(y)\n                for i in xrange(n):\n                    if a[i] == 1 and b[i] == 1:\n                        cross[x][y] -= 60\n                    elif a[i] == 2 and b[i] == 2:\n                        cross[x][y] += 40\n                    elif a[i] + b[i] == 3:\n                        cross[x][y] -= 10\n        f = Counter()\n        f[(0, introvertsCount, extrovertsCount)] = 0\n        for _ in xrange(m):\n            ff = Counter()\n            for (x, i, e), s in f.iteritems():\n                for xx, ii, ee, ss in configs:\n                    if i-ii < 0 or e-ee < 0: continue\n                    kk = (xx, i-ii, e-ee)\n                    vv = s + ss + cross[x][xx]\n                    ff[kk] = max(ff[kk], vv)\n            f = ff\n        return max(f.itervalues())"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3245", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 program that can\n\nYou are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts.\nYou should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.\nThe happiness of each person is calculated as follows:\n\nIntroverts start with 120 happiness and lose 30 happiness for each neighbor (introvert or extrovert).\nExtroverts start with 40 happiness and gain 20 happiness for each neighbor (introvert or extrovert).\n\nNeighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\nThe grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.\n\u00a0\nExample 1:\n\nInput: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\nOutput: 240\nExplanation: Assume the grid is 1-indexed with coordinates (row, column).\nWe can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120\n- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\nThe grid happiness is 120 + 60 + 60 = 240.\nThe above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.\n\nExample 2:\nInput: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\nOutput: 260\nExplanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80\n- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\nThe grid happiness is 90 + 80 + 90 = 260.\n\nExample 3:\nInput: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\nOutput: 240\n\n\u00a0\nConstraints:\n\n1 <= m, n <= 5\n0 <= introvertsCount, extrovertsCount <= min(m * n, 6)\n\n"}, {"role": "assistant", "content": "class Solution:\n    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:\n        state = [[{} for _ in range(n + 1)] for _ in range(n + 1)]\n        all_state = {}\n\n        def make(now, k, a):\n            if k == n:\n                c = collections.Counter(a)\n                state[c[1]][c[2]][now] = a\n                all_state[now] = a\n                return\n            for i in range(3):\n                make(now + (3 ** k) * i, k + 1, a + [i])\n\n        make(0, 0, [])\n        cost = {}\n\n        def calc(s, t):\n            if (s, t) not in cost:\n                ret = 0\n                a, b = all_state[s], all_state[t]\n                for i in range(n):\n                    if a[i] == 1 and b[i] != 0:\n                        ret -= 30\n                    if a[i] == 2 and b[i] != 0:\n                        ret += 20\n                    if b[i] == 1:\n                        ret += 120\n                        if a[i] != 0:\n                            ret -= 30\n                        if i > 0 and b[i - 1] != 0:\n                            ret -= 30\n                        if i < n - 1 and b[i + 1] != 0:\n                            ret -= 30\n                    elif b[i] == 2:\n                        ret += 40\n                        if a[i] != 0:\n                            ret += 20\n                        if i > 0 and b[i - 1] != 0:\n                            ret += 20\n                        if i < n - 1 and b[i + 1] != 0:\n                            ret += 20\n                cost[(s, t)] = ret\n            return cost[(s, t)]\n\n        f = [[[{} for _ in range(extrovertsCount + 1)] for _ in range(introvertsCount + 1)] for _ in range(m + 1)]\n        f[0][0][0][0] = 0\n        ret = 0\n        for i in range(m):\n            for j in range(introvertsCount + 1):\n                for k in range(extrovertsCount + 1):\n                    for s in f[i][j][k]:\n                        for jj in range(j, introvertsCount + 1):\n                            if jj - j > n:\n                                continue\n                            for kk in range(k, extrovertsCount + 1):\n                                if kk - k > n:\n                                    continue\n                                for t in state[jj - j][kk - k]:\n                                    v = calc(s, t) + f[i][j][k][s]\n                                    if t not in f[i + 1][jj][kk] or f[i + 1][jj][kk][t] < v:\n                                        f[i + 1][jj][kk][t] = v\n                                        ret = max(v, ret)\n        return ret"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3281", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 3 function for\n\nYou are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.\nReturn the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.\n\u00a0\nExample 1:\nInput: nums = [1,1,4,2,3], x = 5\nOutput: 2\nExplanation: The optimal solution is to remove the last two elements to reduce x to zero.\n\nExample 2:\nInput: nums = [5,6,7,8,9], x = 4\nOutput: -1\n\nExample 3:\nInput: nums = [3,2,20,1,1,3], x = 10\nOutput: 5\nExplanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 100000\n1 <= nums[i] <= 10000\n1 <= x <= 10^9\n\n"}, {"role": "assistant", "content": "class Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        tot = sum(nums)\n        if tot < x:\n            return -1\n        if tot == x:\n            return len(nums)\n        n = len(nums)\n        ret = 10 ** 9\n        a = [nums[0]]\n        for i in range(1, n):\n            a.append(a[-1] + nums[i])\n        b = [nums[-1]] * n\n        for i in range(n - 2, -1, -1):\n            b[i] = b[i + 1] + nums[i]\n        for i in range(n):\n            if a[i] == x:\n                ret = min(ret, i + 1)\n            if b[i] == x:\n                ret = min(ret, n - i)\n        j = 0\n        while j < n and b[j] > x:\n            j += 1\n        if j < n and b[j] == x:\n            ret = min(ret, n - j)\n        for i in range(n):\n            while j < i:\n                j += 1\n            while j < n and a[i] + b[j] > x:\n                j += 1\n            if j < n and a[i] + b[j] == x:\n                ret = min(i + 1 + n - j, ret)\n        if ret > n:\n            return -1\n        return ret"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3376", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 function for\n\nYou are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. You should arrange the numbers on these cards in a mathematical expression using the operators ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.\nYou are restricted with the following rules:\n\nThe division operator '/' represents real division, not integer division.\n\n\t\nFor example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.\n\n\nEvery operation done is between two numbers. In particular, we cannot use '-' as a unary operator.\n\t\nFor example, if cards = [1, 1, 1, 1], the expression \"-1 - 1 - 1 - 1\" is not allowed.\n\n\nYou cannot concatenate numbers together\n\t\nFor example, if cards = [1, 2, 1, 2], the expression \"12 + 12\" is not valid.\n\n\n\nReturn true if you can get such expression that evaluates to 24, and false otherwise.\n\u00a0\nExample 1:\nInput: cards = [4,1,8,7]\nOutput: true\nExplanation: (8-4) * (7-1) = 24\n\nExample 2:\nInput: cards = [1,2,1,2]\nOutput: false\n\n\u00a0\nConstraints:\n\ncards.length == 4\n1 <= cards[i] <= 9\n\n"}, {"role": "assistant", "content": "class Solution:\n    def judgePoint24(self, nums):\n        for index1 in range (0,4):\n            one=nums[index1]\n            for index2 in range (0,4):\n                if index1==index2:\n                    continue\n                two=nums[index2]\n                for result1 in [one*two, one/two, one+two, one-two]:\n                    for index3 in range (0,4):\n                        if index1==index3 or index2==index3:\n                            continue\n                        three=nums[index3]\n                        possible2=[result1*three,result1+three,result1-three,three-result1]\n                        if(three!=0 and result1!=0):\n                            possible2.append(result1/three)\n                            possible2.append(three/result1)\n                        for result2 in possible2:\n                             for index4 in range (0,4):\n                                if index1==index4 or index2==index4 or index3==index4:\n                                    continue\n                                four=nums[index4]\n                                possible3=[result2*four,result2+four,result2-four,four-result2]\n                                if(four!=0 and result2!=0):\n                                    possible3.append(result2/four)\n                                    possible3.append(four/result2)\n                                for result3 in possible3:\n                                    if(result3==24):\n                                        return True\n                    for index3 in range (0,4):\n                        if index1==index3 or index2==index3:\n                            continue\n                        three=nums[index3]\n                        for index4 in range (0,4):\n                            if index1==index4 or index2==index4 or index3==index4:\n                                continue\n                            four=nums[index4]\n                            possible4=[three*four,three+four,three-four]\n                            if(four!=0):\n                                possible4.append(three/four)\n                            for result2 in possible4:\n                                if(result1*result2==24):\n                                    return True\n        return False"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3434", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 function for\n\nYou are given a string s (0-indexed)\u200b\u200b\u200b\u200b\u200b\u200b. You are asked to perform the following operation on s\u200b\u200b\u200b\u200b\u200b\u200b until you get a sorted string:\n\nFind the largest index i such that 1 <= i < s.length and s[i] < s[i - 1].\nFind the largest index j such that i <= j < s.length and s[k] < s[i - 1] for all the possible values of k in the range [i, j] inclusive.\nSwap the two characters at indices i - 1\u200b\u200b\u200b\u200b and j\u200b\u200b\u200b\u200b\u200b.\nReverse the suffix starting at index i\u200b\u200b\u200b\u200b\u200b\u200b.\n\nReturn the number of operations needed to make the string sorted. Since the answer can be too large, return it modulo 10^9 + 7.\n\u00a0\nExample 1:\nInput: s = \"cba\"\nOutput: 5\nExplanation: The simulation goes as follows:\nOperation 1: i=2, j=2. Swap s[1] and s[2] to get s=\"cab\", then reverse the suffix starting at 2. Now, s=\"cab\".\nOperation 2: i=1, j=2. Swap s[0] and s[2] to get s=\"bac\", then reverse the suffix starting at 1. Now, s=\"bca\".\nOperation 3: i=2, j=2. Swap s[1] and s[2] to get s=\"bac\", then reverse the suffix starting at 2. Now, s=\"bac\".\nOperation 4: i=1, j=1. Swap s[0] and s[1] to get s=\"abc\", then reverse the suffix starting at 1. Now, s=\"acb\".\nOperation 5: i=2, j=2. Swap s[1] and s[2] to get s=\"abc\", then reverse the suffix starting at 2. Now, s=\"abc\".\n\nExample 2:\nInput: s = \"aabaa\"\nOutput: 2\nExplanation: The simulation goes as follows:\nOperation 1: i=3, j=4. Swap s[2] and s[4] to get s=\"aaaab\", then reverse the substring starting at 3. Now, s=\"aaaba\".\nOperation 2: i=4, j=4. Swap s[3] and s[4] to get s=\"aaaab\", then reverse the substring starting at 4. Now, s=\"aaaab\".\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 3000\ns\u200b\u200b\u200b\u200b\u200b\u200b consists only of lowercase English letters.\n\n"}, {"role": "assistant", "content": "mod=10**9+7\nfarr=[1]\nifa=[]\n \ndef fact(x,mod=0):\n    if mod:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr)%mod)\n    else:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr))\n    return farr[x]\n \ndef ifact(x,mod):\n    global ifa\n    fact(x,mod)\n    ifa.append(pow(farr[-1],mod-2,mod))\n    for i in range(x,0,-1):\n        ifa.append(ifa[-1]*i%mod)\n    ifa.reverse()\n \ndef per(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return fact(i)//fact(i-j)\n    return farr[i]*ifa[i-j]%mod\n    \ndef com(i,j,mod=0):\n    if i<j: return 0\n    if not mod:        \n        return per(i,j)//fact(j)\n    return per(i,j,mod)*ifa[j]%mod\n\nclass Solution:\n    def makeStringSorted(self, s: str) -> int:\n        mod=int(1e9)+7\n        ifact(3000,mod)\n        c=Counter(s)\n        n=len(s)\n        ans=0\n        for i in range(n-1):\n            cur=ord(s[i])-97\n            rem=n-i-1\n            mul=fact(rem,mod)\n            for k in c:\n                mul=mul*ifa[c[k]]%mod\n            #print(i,rem,mul,c)\n            for j in range(cur):\n                if c[chr(j+97)]:\n                    ans+=mul*c[chr(j+97)]%mod\n                    ans%=mod\n            c[s[i]]-=1\n            if c[s[i]]==0:\n                del c[s[i]]\n            #print(i,ans)\n        return ans"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3443", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 2 that\n\nAs the ruler of a kingdom, you have an army of wizards at your command.\nYou are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:\n\nThe strength of the weakest wizard in the group.\nThe total of all the individual strengths of the wizards in the group.\n\nReturn the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 10^9 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nExample 1:\nInput: strength = [1,3,1,2]\nOutput: 44\nExplanation: The following are all the contiguous groups of wizards:\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [3] from [1,3,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [2] from [1,3,1,2] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4\n- [1,3] from [1,3,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [3,1] from [1,3,1,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,2] from [1,3,1,2] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [1,3,1] from [1,3,1,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [3,1,2] from [1,3,1,2] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [1,3,1,2] from [1,3,1,2] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\nThe sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.\n\nExample 2:\nInput: strength = [5,4,6]\nOutput: 213\nExplanation: The following are all the contiguous groups of wizards: \n- [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25\n- [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16\n- [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36\n- [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\nThe sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.\n\n\u00a0\nConstraints:\n\n1 <= strength.length <= 100000\n1 <= strength[i] <= 10^9\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def totalStrength(self, strength):\n        \"\"\"\n        :type strength: List[int]\n        :rtype: int\n        \"\"\"\n        d, i, p, v, w, s, t, q, n, r, u, x, y = [], [], [], len(strength) + 1, 2, 0, 0, 0, [len(strength)] * len(strength), [-1] * len(strength), [], [], 0\n        for j in strength:\n            s, q, v = (s + v * j) % 1000000007, (q + j) % 1000000007, v - 1\n            d.append([s, v + 1])\n            p.append(q)\n        for j in strength:\n            t, w = (t + w * j) % 1000000007, w + 1\n            i.append([t, w - 1])\n        for j in range(len(strength)):\n            while u and strength[u[-1]] > strength[j]:\n                n[u[-1]] = j\n                u.pop()\n            u.append(j)\n        for j in range(len(strength) - 1, -1, -1):\n            while x and strength[x[-1]] >= strength[j]:\n                r[x[-1]] = j\n                x.pop()\n            x.append(j)\n        for j in range(len(strength)):\n            y = (y + (((i[j][0] - (0 if r[j] < 0 else i[r[j]][0]) + 1000000007) % 1000000007 - (p[j] - (0 if r[j] < 0 else p[r[j]]) + 1000000007) % 1000000007 * (1 if r[j] < 0 else i[r[j]][1]) % 1000000007 + 1000000007) % 1000000007 + ((d[n[j] - 1][0] - (0 if j < 0 else d[j][0]) + 1000000007) % 1000000007 - (p[n[j] - 1] - (0 if j < 0 else p[j]) + 1000000007) % 1000000007 * (1 if n[j] == len(strength) else d[n[j]][1]) % 1000000007 + 1000000007) % 1000000007 * (j - r[j]) + ((i[j][0] - (0 if r[j] < 0 else i[r[j]][0]) + 1000000007) % 1000000007 - (p[j] - (0 if r[j] < 0 else p[r[j]]) + 1000000007) % 1000000007 * (1 if r[j] < 0 else i[r[j]][1]) % 1000000007 + 1000000007) % 1000000007 * (n[j] - j - 1)) % 1000000007 * strength[j]) % 1000000007\n        return y"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3564", "label": "code_high", "messages": [{"role": "user", "content": "Can you implement a function in Python 3 that\n\nYou are given a 0-indexed 2D integer array grid of size m x n which represents a field. Each cell has one of three values:\n\n0 represents grass,\n1 represents fire,\n2 represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, (0, 0), and you want to travel to the safehouse at the bottom-right cell, (m - 1, n - 1). Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.\nReturn the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse. If this is impossible, return -1. If you can always reach the safehouse regardless of the minutes stayed, return 10^9.\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\nA cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\u00a0\nExample 1:\n\nInput: grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\nOutput: 3\nExplanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\nExample 2:\n\nInput: grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\nOutput: -1\nExplanation: The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\nExample 3:\n\nInput: grid = [[0,0,0],[2,2,0],[1,2,0]]\nOutput: 1000000000\nExplanation: The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 10^9 is returned.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 300\n4 <= m * n <= 2 * 10000\ngrid[i][j] is either 0, 1, or 2.\ngrid[0][0] == grid[m - 1][n - 1] == 0\n\n"}, {"role": "assistant", "content": "class Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        left = 0\n        right = 1000000000\n\n        R = len(grid)\n        C = len(grid[0])\n        INF = 10 ** 20\n        \n        q = collections.deque()\n        dist = [[INF] * C for _ in range(R)]\n        \n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 1:\n                    dist[i][j] = 0\n                    q.append((0, i, j))\n        \n        while len(q) > 0:\n            d, x, y = q.popleft()\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < R and 0 <= ny < C and dist[nx][ny] == INF and grid[nx][ny] != 2:\n                    dist[nx][ny] = d + 1\n                    q.append((d + 1, nx, ny))\n        \n        def good(target):\n            q = collections.deque()\n            d2 = [[INF] * C for _ in range(R)]\n            \n            if dist[0][0] <= target:\n                return False\n            \n            q.append((target, 0, 0))\n            \n            while len(q) > 0:\n                d, x, y = q.popleft()\n                #print(target, x, y, d)\n                \n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    \n                    if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] != 2 and d2[nx][ny] == INF and d + 1 < dist[nx][ny]:\n                        d2[nx][ny] = d + 1\n                        q.append((d + 1, nx, ny))\n\n                        if nx == R - 1 and ny == C - 1:\n                            return True\n                        \n                    if nx == R - 1 and ny == C - 1 and grid[nx][ny] != 2 and d2[nx][ny] == INF and d + 1 <= dist[nx][ny]:\n                        return True\n            return False\n        \n        while left < right:\n            mid = (left + right + 1) // 2\n            \n            if good(mid):\n                left = mid\n            else:\n                right = mid - 1\n            \n        if left == 0:\n            if good(0):\n                return 0\n            else:\n                return -1\n        return left\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3565", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 2 program that\n\nYou are given a 0-indexed 2D integer array grid of size m x n which represents a field. Each cell has one of three values:\n\n0 represents grass,\n1 represents fire,\n2 represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, (0, 0), and you want to travel to the safehouse at the bottom-right cell, (m - 1, n - 1). Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.\nReturn the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse. If this is impossible, return -1. If you can always reach the safehouse regardless of the minutes stayed, return 10^9.\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\nA cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\u00a0\nExample 1:\n\nInput: grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\nOutput: 3\nExplanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\nExample 2:\n\nInput: grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\nOutput: -1\nExplanation: The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\nExample 3:\n\nInput: grid = [[0,0,0],[2,2,0],[1,2,0]]\nOutput: 1000000000\nExplanation: The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 10^9 is returned.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 300\n4 <= m * n <= 2 * 10000\ngrid[i][j] is either 0, 1, or 2.\ngrid[0][0] == grid[m - 1][n - 1] == 0\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def maximumMinutes(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m=len(grid)\n        n=len(grid[0])\n        time=[[float('inf')]*n for i in range(m)]\n        now=[]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]==1:\n                    now.append([i,j])\n                    time[i][j]=0\n        next=[]\n        t=1\n        while now!=[]:\n            for k in now:\n                i=k[0]\n                j=k[1]\n                if i<m-1 and grid[i+1][j]!=2 and time[i+1][j]==float('inf'):\n                    next.append([i+1,j])\n                    time[i+1][j]=t\n                if i>0 and grid[i-1][j]!=2 and time[i-1][j]==float('inf'):\n                    next.append([i-1,j])\n                    time[i-1][j]=t\n                if j<n-1 and grid[i][j+1]!=2 and time[i][j+1]==float('inf'):\n                    next.append([i,j+1])\n                    time[i][j+1]=t\n                if j>0 and grid[i][j-1]!=2 and time[i][j-1]==float('inf'):\n                    next.append([i,j-1])\n                    time[i][j-1]=t\n            now=next[:]\n            next=[]\n            t+=1\n        step=1\n        max_wait=-1\n        now=[[0,0,float('inf')]]\n        check=[[0]*n for i in range(m)]\n        check[0][0]=1\n        while now!=[]:\n            for k in now:\n                i=k[0]\n                j=k[1]\n                wait=k[2]\n                if i<m-1 and grid[i+1][j]!=2 and check[i+1][j]==0:\n                    if i+1==m-1 and j==n-1:\n                        wait=min(wait,time[i+1][j]-step)\n                        max_wait=max(max_wait,wait)\n                    else:\n                        check[i+1][j]=1\n                        wait=min(wait,time[i+1][j]-1-step)\n                        if wait>=0:\n                            next.append([i+1,j,wait])\n                wait=k[2]\n                if i>0 and grid[i-1][j]!=2 and check[i-1][j]==0:\n                    check[i-1][j]=1\n                    wait=min(wait,time[i-1][j]-1-step)\n                    if wait>=0:\n                        next.append([i-1,j,wait])\n                wait=k[2]\n                if j<n-1 and grid[i][j+1]!=2 and check[i][j+1]==0:\n                    if i==m-1 and j+1==n-1:\n                        wait=min(wait,time[i][j+1]-step)\n                        max_wait=max(max_wait,wait)\n                    else:\n                        check[i][j+1]=1\n                        wait=min(wait,time[i][j+1]-1-step)\n                        if wait>=0:\n                            next.append([i,j+1,wait])\n                wait=k[2]\n                if j>0 and grid[i][j-1]!=2 and check[i][j-1]==0:\n                    check[i][j-1]=1\n                    wait=min(wait,time[i][j-1]-1-step)\n                    if wait>=0:\n                        next.append([i,j-1,wait])\n            now=next[:]\n            next=[]\n            step+=1\n        print(check)\n        if max_wait==float('inf'):\n            return 1000000000\n        else:\n            return max_wait"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3570", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 2 to\n\nGiven two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.\n\u00a0\nExample 1:\nInput: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"\n\nExample 2:\nInput: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"\n\nExample 3:\nInput: s = \"12345\", t = \"12435\"\nOutput: false\n\n\u00a0\nConstraints:\n\ns.length == t.length\n1 <= s.length <= 100000\ns and t consist of only digits.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def isTransformable(self, S, T):\n        A = map(int, S)\n        B = map(int, T)\n        \n        prev = -1\n        count = [0] * 10\n        anchor = 0\n        for i, x in enumerate(B):\n            count[x] += 1\n            if i == len(B) - 1 or not(B[i + 1] >= B[i]):\n                # catchup A[anchor..i]\n                # print(\"catch\", anchor, i)\n                countA = [0] * 10\n                countA2 = [0] * 10\n                first_loss = None\n                for j in xrange(anchor, i + 1):\n                    y = A[j]\n                    if countA[y] + 1 <= count[y]:\n                        countA[y] += 1\n                    else:\n                        countA2[y] += 1\n                        if first_loss is None:\n                            first_loss = j\n                # print(\"FL\", first_loss)\n                if first_loss is not None:\n                    # continue to catch up\n                    todo = sum(countA[k] < count[k] for k in xrange(10))\n                    for j in xrange(i + 1, len(A)):\n                        y = A[j]\n                        countA[y] += 1\n                        if countA[y] == count[y]:\n                            todo -= 1\n                        if todo == 0:\n                            # know we have to sort first_loss to j\n                            vals = sorted(A[k] for k in xrange(first_loss, j + 1))\n                            for k, v in enumerate(vals):\n                                A[first_loss + k] = v\n                            \n                            # now count again\n                            countA = [0] * 10\n                            for k in xrange(anchor, i + 1):\n                                y = A[k]\n                                countA[y] += 1\n                            if countA != count:\n                                return False\n                            \n                            break\n                    else:\n                        return False\n                    \n                anchor = i + 1\n                for k in xrange(10): count[k] = 0\n\n        if anchor != len(A):\n            # catch up anchor..len(A) - 1\n            i = len(A) - 1\n            # catchup A[anchor..i]\n            # print(\"catch\", anchor, i)\n            countA = [0] * 10\n            countA2 = [0] * 10\n            first_loss = None\n            for j in xrange(anchor, i + 1):\n                y = A[j]\n                if countA[y] + 1 <= count[y]:\n                    countA[y] += 1\n                else:\n                    countA2[y] += 1\n                    if first_loss is None:\n                        first_loss = j\n            # print(\"FL\", first_loss)\n            if first_loss is not None:\n                # continue to catch up\n                todo = sum(countA[k] < count[k] for k in xrange(10))\n                for j in xrange(i + 1, len(A)):\n                    y = A[j]\n                    countA[y] += 1\n                    if countA[y] == count[y]:\n                        todo -= 1\n                    if todo == 0:\n                        # know we have to sort first_loss to j\n                        vals = sorted(A[k] for k in xrange(first_loss, j + 1))\n                        for k, v in enumerate(vals):\n                            A[first_loss + k] = v\n\n                        # now count again\n                        countA = [0] * 10\n                        for k in xrange(anchor, i + 1):\n                            y = A[k]\n                            countA[y] += 1\n                        if countA != count:\n                            return False\n\n                        break\n                else:\n                    return False\n        return True"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3607", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 script for\n\nYou are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls where guards[i] = [rowi, coli] and walls[j] = [rowj, colj] represent the positions of the ith guard and jth wall respectively.\nA guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.\nReturn the number of unoccupied cells that are not guarded.\n\u00a0\nExample 1:\n\nInput: m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\nOutput: 7\nExplanation: The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n\nExample 2:\n\nInput: m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\nOutput: 4\nExplanation: The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n\n\u00a0\nConstraints:\n\n1 <= m, n <= 100000\n2 <= m * n <= 100000\n1 <= guards.length, walls.length <= 5 * 10000\n2 <= guards.length + walls.length <= m * n\nguards[i].length == walls[j].length == 2\n0 <= rowi, rowj < m\n0 <= coli, colj < n\nAll the positions in guards and walls are unique.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def countUnguarded(self, R: int, C: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n        state = [[0] * C for _ in range(R)]\n        \n        GUARD = 1\n        WALL = 2\n        USED = 3\n        for x, y in guards:\n            state[x][y] = GUARD\n            \n        for x, y in walls:\n            state[x][y] = WALL\n\n        for i in range(R):\n            current = 0\n            for j in range(C):\n                if state[i][j] == GUARD:\n                    current = USED\n                elif state[i][j] == WALL:\n                    current = 0\n                elif state[i][j] == 0:\n                    if current == USED:\n                        state[i][j] = USED\n        \n        for i in range(R):\n            current = 0\n            for j in range(C - 1, -1, -1):\n                if state[i][j] == GUARD:\n                    current = USED\n                elif state[i][j] == WALL:\n                    current = 0\n                elif state[i][j] == 0:\n                    if current == USED:\n                        state[i][j] = USED\n                \n        for j in range(C):\n            current = 0\n            for i in range(R):\n                if state[i][j] == GUARD:\n                    current = USED\n                elif state[i][j] == WALL:\n                    current = 0\n                elif state[i][j] == 0:\n                    if current == USED:\n                        state[i][j] = USED\n\n        for j in range(C):\n            current = 0\n            for i in range(R - 1, -1, -1):\n                if state[i][j] == GUARD:\n                    current = USED\n                elif state[i][j] == WALL:\n                    current = 0\n                elif state[i][j] == 0:\n                    if current == USED:\n                        state[i][j] = USED\n\n        count = 0\n        for i in range(R):\n            for j in range(C):\n                if state[i][j] == 0:\n                    count += 1\n        return count\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3608", "label": "code_high", "messages": [{"role": "user", "content": "Can you implement a function in Python 2 that\n\nYou are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls where guards[i] = [rowi, coli] and walls[j] = [rowj, colj] represent the positions of the ith guard and jth wall respectively.\nA guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.\nReturn the number of unoccupied cells that are not guarded.\n\u00a0\nExample 1:\n\nInput: m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\nOutput: 7\nExplanation: The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n\nExample 2:\n\nInput: m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\nOutput: 4\nExplanation: The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n\n\u00a0\nConstraints:\n\n1 <= m, n <= 100000\n2 <= m * n <= 100000\n1 <= guards.length, walls.length <= 5 * 10000\n2 <= guards.length + walls.length <= m * n\nguards[i].length == walls[j].length == 2\n0 <= rowi, rowj < m\n0 <= coli, colj < n\nAll the positions in guards and walls are unique.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def countUnguarded(self, m, n, guards, walls):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type guards: List[List[int]]\n        :type walls: List[List[int]]\n        :rtype: int\n        \"\"\"\n        grid=[[0]*n for i in range(m)]\n        for k in walls:\n            grid[k[0]][k[1]]=1\n        for k in guards:\n            grid[k[0]][k[1]]=2\n        for i in range(m):\n            flag=0\n            for j in range(n):\n                if grid[i][j]==2:\n                    flag=3\n                elif grid[i][j]==1:\n                    flag=0\n                else:\n                    grid[i][j]=flag\n            flag=0\n            for j in range(n-1,-1,-1):\n                if grid[i][j]==2:\n                    flag=3\n                elif grid[i][j]==1:\n                    flag=0\n                elif grid[i][j]==3:\n                    continue\n                else:\n                    grid[i][j]=flag\n        count=0\n        for j in range(n):\n            flag=0\n            for i in range(m):\n                if grid[i][j]==2:\n                    flag=3\n                elif grid[i][j]==1:\n                    flag=0\n                elif grid[i][j]==3:\n                    continue\n                else:\n                    grid[i][j]=flag\n            flag=0\n            for i in range(m-1,-1,-1):\n                if grid[i][j]==2:\n                    flag=3\n                elif grid[i][j]==1:\n                    flag=0\n                elif grid[i][j]==0:\n                    grid[i][j]=flag\n                if grid[i][j]==0:\n                    count+=1\n        return count"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3615", "label": "code_high", "messages": [{"role": "user", "content": "Can you write a program in Python 3 where\n\nA city is represented as a bi-directional connected graph with n vertices where each vertex is labeled from 1 to n (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is time minutes.\nEach vertex has a traffic signal which changes its color from green to red and vice versa every\u00a0change minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green.\nThe second minimum value is defined as the smallest value strictly larger than the minimum value.\n\nFor example the second minimum value of [2, 3, 4] is 3, and the second minimum value of [2, 2, 4] is 4.\n\nGiven n, edges, time, and change, return the second minimum time it will take to go from vertex 1 to vertex n.\nNotes:\n\nYou can go through any vertex any number of times, including 1 and n.\nYou can assume that when the journey starts, all signals have just turned green.\n\n\u00a0\nExample 1:\n \u2003 \u2003 \u2003 \u2003\nInput: n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5\nOutput: 13\nExplanation:\nThe figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -> 4: 3 minutes, time elapsed=3\n- 4 -> 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -> 3: 3 minutes, time elapsed=3\n- 3 -> 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -> 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes.      \n\nExample 2:\n\nInput: n = 2, edges = [[1,2]], time = 3, change = 2\nOutput: 11\nExplanation:\nThe minimum time path is 1 -> 2 with time = 3 minutes.\nThe second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n\u00a0\nConstraints:\n\n2 <= n <= 10000\nn - 1 <= edges.length <= min(2 * 10000, n * (n - 1) / 2)\nedges[i].length == 2\n1 <= ui, vi <= n\nui != vi\nThere are no duplicate edges.\nEach vertex can be reached directly or indirectly from every other vertex.\n1 <= time, change <= 103\n\n"}, {"role": "assistant", "content": "class Solution:\n    def secondMinimum(self, n: int, adj: List[List[int]], time: int, change: int) -> int:\n        edges = [[] for i in range(n)]\n        for i, j in adj:\n            edges[i-1].append(j-1)\n            edges[j-1].append(i-1)\n        dist = [-1]*n\n        dist2 = [-1]*n\n        q = deque()\n        q.append(0)\n        dist[0] = 0\n        while len(q):\n            cur = q.popleft()\n            for i in edges[cur]:\n                if dist[i] == -1:\n                    dist[i] = dist[cur]+1\n                    q.append(i)\n        q = deque()\n        q.append(n-1)\n        dist2[n-1] = 0\n        while len(q):\n            cur = q.popleft()\n            for i in edges[cur]:\n                if dist2[i] == -1:\n                    dist2[i] = dist2[cur]+1\n                    q.append(i)\n        res = 10**18\n        for i, j in adj:\n            x, y = i-1, j-1\n            if dist[x]+dist2[y]+1 > dist[n-1]:\n                res = min(res, dist[x]+dist2[y]+1)\n            if dist2[x]+dist[y]+1 > dist[n-1]:\n                res = min(res, dist2[x]+dist[y]+1)\n        cur = 0\n        for i in range(res):\n            if cur%(2*change) >= change:\n                cur = (cur//(2*change)+1)*(2*change)\n            cur += time\n        return cur\n\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3653", "label": "code_high", "messages": [{"role": "user", "content": "Can you write a program in Python 3 where\n\nYou are given an integer array nums, and you can perform the following operation any number of times on nums:\n\nSwap the positions of two elements nums[i] and nums[j] if gcd(nums[i], nums[j]) > 1 where gcd(nums[i], nums[j]) is the greatest common divisor of nums[i] and nums[j].\n\nReturn true if it is possible to sort nums in non-decreasing order using the above swap method, or false otherwise.\n\u00a0\nExample 1:\nInput: nums = [7,21,3]\nOutput: true\nExplanation: We can sort [7,21,3] by performing the following operations:\n- Swap 7 and 21 because gcd(7,21) = 7. nums = [21,7,3]\n- Swap 21 and 3 because gcd(21,3) = 3. nums = [3,7,21]\n\nExample 2:\nInput: nums = [5,2,6,2]\nOutput: false\nExplanation: It is impossible to sort the array because 5 cannot be swapped with any other element.\n\nExample 3:\nInput: nums = [10,5,9,3,15]\nOutput: true\nWe can sort [10,5,9,3,15] by performing the following operations:\n- Swap 10 and 15 because gcd(10,15) = 5. nums = [15,5,9,3,10]\n- Swap 15 and 3 because gcd(15,3) = 3. nums = [3,5,9,15,10]\n- Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,10,15]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 3 * 10000\n2 <= nums[i] <= 100000\n\n"}, {"role": "assistant", "content": "P = []\nN = 10 ** 5 + 5\n# N = 32\nseen = [0] * N\nfor i in range(2, N):\n    if not seen[i]:\n        P.append(i)\n        seen[i] = 1\n        for j in range(i * i, N, i):\n            seen[j] = 1\n            \nclass DSU:\n    def __init__(self, n):\n        self.uf = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, x):\n        if self.uf[x] != x:\n            self.uf[x] = self.find(self.uf[x])\n        return self.uf[x]\n\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px != py:\n            if self.rank[px] > self.rank[py]:\n                px, py = py, px\n            self.rank[py] += self.rank[px]\n            self.uf[px] = py\n            return True\n        return False\n\nclass Solution:\n    def gcdSort(self, nums: List[int]) -> bool:\n        n = len(nums)\n        dsu = DSU(n)\n        dic = defaultdict(list)\n        \n        def fac(x):\n            ans = []\n            if not x % 2:\n                ans.append(2)\n                while not x % 2: x //= 2\n            for i in range(3, int(math.sqrt(x)) + 1, 2):\n                if not x % i:\n                    ans.append(i)\n                    while not x % i: x //= i\n            if x > 1: ans.append(x)\n            return ans\n        \n        \n        for i, a in enumerate(nums):\n            cur = fac(a)\n            for p in cur:\n                dic[p].append(i)\n        for k, v in dic.items():\n            for a, b in zip(v, v[1:]):\n                dsu.union(a, b)\n        A = sorted(range(n), key=lambda x: nums[x])\n        B = list(range(n))\n        for i in range(n):\n            if A[i] == B[i]: continue\n            if dsu.find(A[i]) == dsu.find(B[i]):\n                B[i], A[i] = A[i], B[i]\n            else: return False\n        return True\n        \n        \n        \n        \n        \n        \n        \n        \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3654", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 2 that\n\nYou are given an integer array nums, and you can perform the following operation any number of times on nums:\n\nSwap the positions of two elements nums[i] and nums[j] if gcd(nums[i], nums[j]) > 1 where gcd(nums[i], nums[j]) is the greatest common divisor of nums[i] and nums[j].\n\nReturn true if it is possible to sort nums in non-decreasing order using the above swap method, or false otherwise.\n\u00a0\nExample 1:\nInput: nums = [7,21,3]\nOutput: true\nExplanation: We can sort [7,21,3] by performing the following operations:\n- Swap 7 and 21 because gcd(7,21) = 7. nums = [21,7,3]\n- Swap 21 and 3 because gcd(21,3) = 3. nums = [3,7,21]\n\nExample 2:\nInput: nums = [5,2,6,2]\nOutput: false\nExplanation: It is impossible to sort the array because 5 cannot be swapped with any other element.\n\nExample 3:\nInput: nums = [10,5,9,3,15]\nOutput: true\nWe can sort [10,5,9,3,15] by performing the following operations:\n- Swap 10 and 15 because gcd(10,15) = 5. nums = [15,5,9,3,10]\n- Swap 15 and 3 because gcd(15,3) = 3. nums = [3,5,9,15,10]\n- Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,10,15]\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 3 * 10000\n2 <= nums[i] <= 100000\n\n"}, {"role": "assistant", "content": "from collections import defaultdict\nclass Solution(object):\n    def gcdSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        m = max(nums) + 1\n        fs = range(m)\n        for i in xrange(2, m):\n            if fs[i] < i:\n                continue\n            ii = i * i\n            if ii > m:\n                break\n            for j in xrange(ii, m, i):\n                if fs[j] == j:\n                    fs[j] = i\n\n        def _pf(x):\n            r = []\n            while x > 1:\n                p = fs[x]\n                x //= p\n                if not r or p > r[-1]:\n                    r.append(p)\n            return r\n\n        par = [-1] * m\n        rnk = [0] * m\n\n        def _find(u):\n            s = []\n            while par[u] >= 0:\n                s.append(u)\n                u = par[u]\n            for v in s:\n                par[v] = u\n            return u\n\n        def _union(u, v):\n            u = _find(u)\n            v = _find(v)\n            if u == v:\n                return\n            if rnk[u] > rnk[v]:\n                u, v = v, u\n            par[u] = v\n            if rnk[u] == rnk[v]:\n                rnk[v] += 1\n\n        a = nums[:]\n        n = len(a)\n        for x in a:\n            pf = _pf(x)\n            for p in pf:\n                _union(p, pf[0])\n        d = defaultdict(list)\n        for i, x in enumerate(a):\n            d[_find(fs[x])].append(i)\n        for gr in d.itervalues():\n            vals = [a[i] for i in gr]\n            vals.sort()\n            for j, i in enumerate(gr):\n                a[i] = vals[j]\n        return all(a[i] <= a[i+1] for i in xrange(n-1))"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3704", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 program that can\n\nYou are given a 0-indexed string s. You are also given a 0-indexed string queryCharacters of length k and a 0-indexed array of integer indices queryIndices of length k, both of which are used to describe k queries.\nThe ith query updates the character in s at index queryIndices[i] to the character queryCharacters[i].\nReturn an array lengths of length k where lengths[i] is the length of the longest substring of s consisting of only one repeating character after the ith query is performed.\n\u00a0\nExample 1:\nInput: s = \"babacc\", queryCharacters = \"bcb\", queryIndices = [1,3,3]\nOutput: [3,3,4]\nExplanation: \n- 1st query updates s = \"bbbacc\". The longest substring consisting of one repeating character is \"bbb\" with length 3.\n- 2nd query updates s = \"bbbccc\". \n  The longest substring consisting of one repeating character can be \"bbb\" or \"ccc\" with length 3.\n- 3rd query updates s = \"bbbbcc\". The longest substring consisting of one repeating character is \"bbbb\" with length 4.\nThus, we return [3,3,4].\n\nExample 2:\nInput: s = \"abyzz\", queryCharacters = \"aa\", queryIndices = [2,1]\nOutput: [2,3]\nExplanation:\n- 1st query updates s = \"abazz\". The longest substring consisting of one repeating character is \"zz\" with length 2.\n- 2nd query updates s = \"aaazz\". The longest substring consisting of one repeating character is \"aaa\" with length 3.\nThus, we return [2,3].\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 100000\ns consists of lowercase English letters.\nk == queryCharacters.length == queryIndices.length\n1 <= k <= 100000\nqueryCharacters consists of lowercase English letters.\n0 <= queryIndices[i] < s.length\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def longestRepeating(self, s, queryCharacters, queryIndices):\n        \"\"\"\n        :type s: str\n        :type queryCharacters: str\n        :type queryIndices: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        mx=1\n        while mx<=n: mx<<=1\n        xx = [0]*(mx+mx)\n        lx = [0]*(mx+mx)\n        rx = [0]*(mx+mx)\n        ll = [0]*(mx+mx)\n        rr = [0]*(mx+mx)\n        def setc(k, d, i, c):\n            if d==1:\n                lx[k]=c\n                rx[k]=c\n                xx[k]=1\n                ll[k]=1\n                rr[k]=1\n                return\n            d>>=1\n            k1, k2 = k*2+1, k*2+2\n            if i>=d:\n                setc(k2, d, i-d, c)\n            else:\n                setc(k1, d, i, c)\n            ll[k]=ll[k1]\n            lx[k]=lx[k1]\n            rx[k]=rx[k2]\n            if ll[k]==d and lx[k2]==rx[k1]: ll[k]+=ll[k2]\n            rr[k]=rr[k2]\n            if rr[k]==d and lx[k2]==rx[k1]: rr[k]+=rr[k1]\n            xx[k]=max(xx[k1], xx[k2])\n            if lx[k2]==rx[k1]:\n                v=ll[k2]+rr[k1]\n                xx[k]=max(xx[k], v)\n        ss = list(s)\n        i = 0\n        while i<n:\n            setc(0, mx, i, ss[i])\n            i+=1\n        m = len(queryIndices)\n        rs = [0]*m\n        i=0\n        while i<m:\n            j = queryIndices[i]\n            c = queryCharacters[i]\n            if c!=ss[j]:\n                setc(0, mx, j, c)\n                ss[j]=c\n            rs[i]=xx[0]\n            i+=1\n        return rs\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3732", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 function for\n\nA message containing letters from A-Z can be encoded into numbers using the following mapping:\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n\nTo decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n\n\"AAJF\" with the grouping (1 1 10 6)\n\"KJF\" with the grouping (11 10 6)\n\nNote that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\nIn addition to the mapping above, an encoded message may contain the '*' character, which can represent any digit from '1' to '9' ('0' is excluded). For example, the encoded message \"1*\" may represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\". Decoding \"1*\" is equivalent to decoding any of the encoded messages it can represent.\nGiven a string s consisting of digits and '*' characters, return the number of ways to decode it.\nSince the answer may be very large, return it modulo 10^9 + 7.\n\u00a0\nExample 1:\nInput: s = \"*\"\nOutput: 9\nExplanation: The encoded message can represent any of the encoded messages \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", or \"9\".\nEach of these can be decoded to the strings \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", and \"I\" respectively.\nHence, there are a total of 9 ways to decode \"*\".\n\nExample 2:\nInput: s = \"1*\"\nOutput: 18\nExplanation: The encoded message can represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\".\nEach of these encoded messages have 2 ways to be decoded (e.g. \"11\" can be decoded to \"AA\" or \"K\").\nHence, there are a total of 9 * 2 = 18 ways to decode \"1*\".\n\nExample 3:\nInput: s = \"2*\"\nOutput: 15\nExplanation: The encoded message can represent any of the encoded messages \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", or \"29\".\n\"21\", \"22\", \"23\", \"24\", \"25\", and \"26\" have 2 ways of being decoded, but \"27\", \"28\", and \"29\" only have 1 way.\nHence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode \"2*\".\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 100000\ns[i] is a digit or '*'.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if s[0] == '0': return 0\n        mm = (10**9) + 7\n        D = [1]\n        if s[0] == '*':\n            D.append(9)\n        elif s[0] == '0':\n            D.append(0)\n        else:\n            D.append(1)\n        for i in xrange(1, len(s)):\n            if s[i] == '0':\n                cur = 0\n            else:\n                cur = D[-1] * (9 if s[i] == '*' else 1)\n            if s[i-1] == '*' and s[i] == '*':\n                cur += D[-2] * (9 + 6)\n            elif s[i] == '*':\n                if s[i-1] == '1':\n                    cur += D[-2] * 9\n                elif s[i-1] == '2':\n                    cur += D[-2] * 6\n                else:\n                    pass\n            elif s[i-1] == '*':\n                if ord('0') <= ord(s[i]) <= ord('6'):\n                    cur += D[-2] * 2\n                else:\n                    cur += D[-2]\n            elif s[i-1] == '0':\n                pass\n            elif ord('3') <= ord(s[i-1]) <= ord('9'):\n                pass\n            elif s[i-1] == '2':\n                if ord('7') <= ord(s[i]) <= ord('9'):\n                    pass\n                else:\n                    cur += D[-2]\n            elif s[i-1] == '1':\n                cur += D[-2]\n            else:\n                pass\n            cur %= mm\n            D.append(cur)\n            D.pop(0)\n        return D[-1]\n\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3759", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 3 to\n\nYou are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.\nYou are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected.\nDivide the nodes of the graph into m groups (1-indexed) such that:\n\nEach node in the graph belongs to exactly one group.\nFor every pair of nodes in the graph that are connected by an edge [ai, bi], if ai belongs to the group with index x, and bi belongs to the group with index y, then |y - x| = 1.\n\nReturn the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.\n\u00a0\nExample 1:\n\nInput: n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]\nOutput: 4\nExplanation: As shown in the image we:\n- Add node 5 to the first group.\n- Add node 1 to the second group.\n- Add nodes 2 and 4 to the third group.\n- Add nodes 3 and 6 to the fourth group.\nWe can see that every edge is satisfied.\nIt can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.\n\nExample 2:\nInput: n = 3, edges = [[1,2],[2,3],[3,1]]\nOutput: -1\nExplanation: If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.\nIt can be shown that no grouping is possible.\n\n\u00a0\nConstraints:\n\n1 <= n <= 500\n1 <= edges.length <= 10000\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere is at most one edge between any pair of vertices.\n\n"}, {"role": "assistant", "content": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n\n    def find(self, a):\n        acopy = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while acopy != a:\n            self.parent[acopy], acopy = a, self.parent[acopy]\n        return a\n\n    def merge(self, a, b):\n        self.parent[self.find(b)] = self.find(a)\n\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        path = defaultdict(list)\n        union = UnionFind(n+1)\n        for x, y in edges:\n            union.merge(x, y)\n            path[x].append(y)\n            path[y].append(x)\n        ans = [-1] *(n+1)\n        for i in range(1, n+1):\n            if ans[i] == -1:\n                ans[i] = 0\n                q = deque([i])\n                while q:\n                    p = q.popleft()\n                    for newp in path[p]:\n                        if ans[newp] == -1:\n                            ans[newp] = 1 - ans[p]\n                            q.append(newp)\n                        elif ans[newp] + ans[p] != 1: return -1\n        visited = defaultdict(int)\n        for i in range(1, n+1):\n            ans[i] = 0\n            q = deque([i])\n            v = {i}\n            cnt = 0\n            while q:\n                cnt += 1\n                for _ in range(len(q)):\n                    p = q.popleft()\n                    for newp in path[p]:\n                        if newp not in v:\n                            v.add(newp)\n                            q.append(newp)\n            visited[union.find(i)] = max(visited[union.find(i)], cnt)\n        return sum(visited.values())"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3773", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 function for\n\nYou are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\nReturn the size of the largest island in grid after applying this operation.\nAn island is a 4-directionally connected group of 1s.\n\u00a0\nExample 1:\nInput: grid = [[1,0],[0,1]]\nOutput: 3\nExplanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\n\nExample 2:\nInput: grid = [[1,1],[1,0]]\nOutput: 4\nExplanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.\nExample 3:\nInput: grid = [[1,1],[1,1]]\nOutput: 4\nExplanation: Can't change any 0 to 1, only one island with area = 4.\n\n\u00a0\nConstraints:\n\nn == grid.length\nn == grid[i].length\n1 <= n <= 500\ngrid[i][j] is either 0 or 1.\n"}, {"role": "assistant", "content": "class Solution(object):\n    def dfs(self, i, j, col, grid):\n        grid[i][j] = col\n        stack = [(i, j)]\n        sz = 1\n        while stack:\n            i, j = stack.pop()\n            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ni = i + di\n                nj = j + dj\n                if ni >= 0 and ni < len(grid) and nj >= 0 and nj < len(grid[0]) and grid[ni][nj] == 1:\n                    grid[ni][nj] = col\n                    sz += 1\n                    stack.append((ni, nj))\n        return sz\n    \n    def largestIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        N = len(grid)\n        M = len(grid[0])\n        col = 1\n        mp = {}\n        mxsz = 0\n        for i in xrange(N):\n            for j in xrange(M):\n                if grid[i][j] == 1:\n                    col += 1\n                    mp[col] = self.dfs(i, j, col, grid)\n                    mxsz = max(mp[col], mxsz)\n        for i in xrange(N):\n            for j in xrange(M):\n                newset = set([])\n                if grid[i][j] == 0:\n                    for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        ni = i + di\n                        nj = j + dj\n                        if ni >= 0 and ni < len(grid) and nj >= 0 and nj < len(grid[0]) and grid[ni][nj] != 0:\n                            newset.add(grid[ni][nj])\n                newsize = 1 + sum([mp[s] for s in newset])\n                mxsz = max(mxsz, newsize)\n        return mxsz\n                        \n        \n                \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3774", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 3 to\n\nYou are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\nReturn the size of the largest island in grid after applying this operation.\nAn island is a 4-directionally connected group of 1s.\n\u00a0\nExample 1:\nInput: grid = [[1,0],[0,1]]\nOutput: 3\nExplanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\n\nExample 2:\nInput: grid = [[1,1],[1,0]]\nOutput: 4\nExplanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.\nExample 3:\nInput: grid = [[1,1],[1,1]]\nOutput: 4\nExplanation: Can't change any 0 to 1, only one island with area = 4.\n\n\u00a0\nConstraints:\n\nn == grid.length\nn == grid[i].length\n1 <= n <= 500\ngrid[i][j] is either 0 or 1.\n"}, {"role": "assistant", "content": "class Solution:\n\tdef largestIsland(self, grid):\n\t\t\"\"\"\n\t\t:type grid: List[List[int]]\n\t\t:rtype: int\n\t\t\"\"\"\n\t\tdef root(f, a):\n\t\t\tif f[a] != a:\n\t\t\t\tf[a] = root(f, f[a])\n\t\t\treturn f[a]\n\n\t\tdef merge(f, a, b):\n\t\t\tif root(f, a) == root(f, b):\n\t\t\t\treturn\n\t\t\tf[root(f, a)] = root(f, b)\n\n\t\tdef idx(r, c, x, y):\n\t\t\treturn x * c + y\n\n\t\tr = len(grid)\n\t\tc = len(grid[0])\n\t\tn = r * c\n\t\tfather = [i for i in range(n)]\n\n\t\tfor i in range(r):\n\t\t\tfor j in range(c):\n\t\t\t\tfor (s, t) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n\t\t\t\t\tif not 0 <= i + s < r or not 0 <= j + t < c:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tif grid[i][j] == 1 and grid[i + s][j + t] == 1:\n\t\t\t\t\t\t# print(i, j, i + s, j + t)\n\t\t\t\t\t\tmerge(father, idx(r, c, i, j), idx(r, c, i + s, j + t))\n\t\t# print([root(father, i) for i in range(n)])\n\n\t\tcnt = [0 for _ in range(n)]\n\t\tfor i in range(r):\n\t\t\tfor j in range(c):\n\t\t\t\tcnt[root(father, idx(r, c, i, j))] += 1\n\t\t# print(cnt)\n\n\t\tans = max(cnt)\n\t\tfor i in range(r):\n\t\t\tfor j in range(c):\n\t\t\t\tif grid[i][j] != 0:\n\t\t\t\t\tcontinue\n\t\t\t\tpool = set([])\n\t\t\t\tif i > 0 and grid[i - 1][j] == 1:\n\t\t\t\t\tpool.add(root(father, idx(r, c, i - 1, j)))\n\t\t\t\tif i < r - 1 and grid[i + 1][j] == 1:\n\t\t\t\t\tpool.add(root(father, idx(r, c, i + 1, j)))\n\t\t\t\tif j > 0 and grid[i][j - 1] == 1:\n\t\t\t\t\tpool.add(root(father, idx(r, c, i, j - 1)))\n\t\t\t\tif j < c - 1 and grid[i][j + 1] == 1:\n\t\t\t\t\tpool.add(root(father, idx(r, c, i, j + 1)))\n\n\t\t\t\tcur = sum(cnt[e] for e in pool) + 1\n\t\t\t\t# print(i, j, cur, pool)\n\t\t\t\tans = max(ans, cur)\n\t\treturn ans\n\n\n\n\n\n\n\n\n\n\n\n\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3798", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 2 function for\n\nAn original string, consisting of lowercase English letters, can be encoded by the following steps:\n\nArbitrarily split it into a sequence of some number of non-empty substrings.\nArbitrarily choose some elements (possibly none) of the sequence, and replace each with its length (as a numeric string).\nConcatenate the sequence as the encoded string.\n\nFor example, one way to encode an original string \"abcdefghijklmnop\" might be:\n\nSplit it as a sequence: [\"ab\", \"cdefghijklmn\", \"o\", \"p\"].\nChoose the second and third elements to be replaced by their lengths, respectively. The sequence becomes [\"ab\", \"12\", \"1\", \"p\"].\nConcatenate the elements of the sequence to get the encoded string: \"ab121p\".\n\nGiven two encoded strings s1 and s2, consisting of lowercase English letters and digits 1-9 (inclusive), return true if there exists an original string that could be encoded as both s1 and s2. Otherwise, return false.\nNote: The test cases are generated such that the number of consecutive digits in s1 and s2 does not exceed 3.\n\u00a0\nExample 1:\nInput: s1 = \"internationalization\", s2 = \"i18n\"\nOutput: true\nExplanation: It is possible that \"internationalization\" was the original string.\n- \"internationalization\" \n  -> Split:       [\"internationalization\"]\n  -> Do not replace any element\n  -> Concatenate:  \"internationalization\", which is s1.\n- \"internationalization\"\n  -> Split:       [\"i\", \"nternationalizatio\", \"n\"]\n  -> Replace:     [\"i\", \"18\",                 \"n\"]\n  -> Concatenate:  \"i18n\", which is s2\n\nExample 2:\nInput: s1 = \"l123e\", s2 = \"44\"\nOutput: true\nExplanation: It is possible that \"leetcode\" was the original string.\n- \"leetcode\" \n  -> Split:      [\"l\", \"e\", \"et\", \"cod\", \"e\"]\n  -> Replace:    [\"l\", \"1\", \"2\",  \"3\",   \"e\"]\n  -> Concatenate: \"l123e\", which is s1.\n- \"leetcode\" \n  -> Split:      [\"leet\", \"code\"]\n  -> Replace:    [\"4\",    \"4\"]\n  -> Concatenate: \"44\", which is s2.\n\nExample 3:\nInput: s1 = \"a5b\", s2 = \"c5b\"\nOutput: false\nExplanation: It is impossible.\n- The original string encoded as s1 must start with the letter 'a'.\n- The original string encoded as s2 must start with the letter 'c'.\n\n\u00a0\nConstraints:\n\n1 <= s1.length, s2.length <= 40\ns1 and s2 consist of digits 1-9 (inclusive), and lowercase English letters only.\nThe number of consecutive digits in s1 and s2 does not exceed 3.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def possiblyEquals(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        n1, n2 = len(s1), len(s2)\n        bal = [[set() for _ in xrange(n2+1)] for _ in xrange(n1+1)]\n        bal[0][0].add(0)\n        for i1 in xrange(n1+1):\n            for i2 in xrange(n2+1):\n                if i1 < n1 and s1[i1].isalpha() and i2 < n2 and s1[i1] == s2[i2]:\n                    if 0 in bal[i1][i2]:\n                        bal[i1+1][i2+1].add(0)\n                if i1 < n1:\n                    if s1[i1].isalpha():\n                        for b in bal[i1][i2]:\n                            if b < 0:\n                                bal[i1+1][i2].add(b+1)\n                    else:\n                        v = 0\n                        for j1 in xrange(i1, n1):\n                            if s1[j1].isalpha():\n                                break\n                            v = 10*v + int(s1[j1])\n                            for b in bal[i1][i2]:\n                                bal[j1+1][i2].add(b+v)\n                if i2 < n2:\n                    if s2[i2].isalpha():\n                        for b in bal[i1][i2]:\n                            if b > 0:\n                                bal[i1][i2+1].add(b-1)\n                    else:\n                        v = 0\n                        for j2 in xrange(i2, n2):\n                            if s2[j2].isalpha():\n                                break\n                            v = 10*v + int(s2[j2])\n                            for b in bal[i1][i2]:\n                                bal[i1][j2+1].add(b-v)\n        return 0 in bal[n1][n2]"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3799", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 3 that\n\nAn original string, consisting of lowercase English letters, can be encoded by the following steps:\n\nArbitrarily split it into a sequence of some number of non-empty substrings.\nArbitrarily choose some elements (possibly none) of the sequence, and replace each with its length (as a numeric string).\nConcatenate the sequence as the encoded string.\n\nFor example, one way to encode an original string \"abcdefghijklmnop\" might be:\n\nSplit it as a sequence: [\"ab\", \"cdefghijklmn\", \"o\", \"p\"].\nChoose the second and third elements to be replaced by their lengths, respectively. The sequence becomes [\"ab\", \"12\", \"1\", \"p\"].\nConcatenate the elements of the sequence to get the encoded string: \"ab121p\".\n\nGiven two encoded strings s1 and s2, consisting of lowercase English letters and digits 1-9 (inclusive), return true if there exists an original string that could be encoded as both s1 and s2. Otherwise, return false.\nNote: The test cases are generated such that the number of consecutive digits in s1 and s2 does not exceed 3.\n\u00a0\nExample 1:\nInput: s1 = \"internationalization\", s2 = \"i18n\"\nOutput: true\nExplanation: It is possible that \"internationalization\" was the original string.\n- \"internationalization\" \n  -> Split:       [\"internationalization\"]\n  -> Do not replace any element\n  -> Concatenate:  \"internationalization\", which is s1.\n- \"internationalization\"\n  -> Split:       [\"i\", \"nternationalizatio\", \"n\"]\n  -> Replace:     [\"i\", \"18\",                 \"n\"]\n  -> Concatenate:  \"i18n\", which is s2\n\nExample 2:\nInput: s1 = \"l123e\", s2 = \"44\"\nOutput: true\nExplanation: It is possible that \"leetcode\" was the original string.\n- \"leetcode\" \n  -> Split:      [\"l\", \"e\", \"et\", \"cod\", \"e\"]\n  -> Replace:    [\"l\", \"1\", \"2\",  \"3\",   \"e\"]\n  -> Concatenate: \"l123e\", which is s1.\n- \"leetcode\" \n  -> Split:      [\"leet\", \"code\"]\n  -> Replace:    [\"4\",    \"4\"]\n  -> Concatenate: \"44\", which is s2.\n\nExample 3:\nInput: s1 = \"a5b\", s2 = \"c5b\"\nOutput: false\nExplanation: It is impossible.\n- The original string encoded as s1 must start with the letter 'a'.\n- The original string encoded as s2 must start with the letter 'c'.\n\n\u00a0\nConstraints:\n\n1 <= s1.length, s2.length <= 40\ns1 and s2 consist of digits 1-9 (inclusive), and lowercase English letters only.\nThe number of consecutive digits in s1 and s2 does not exceed 3.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\n        \n        def decompose(s):\n            lst = []\n            for i in range(3):\n                if i < len(s) and s[i].isdigit():\n                    lst.append((int(s[:i+1]), s[i+1:]))\n                else:\n                    break\n            if not lst:\n                lst.append((0, s))\n            return lst\n        \n        # print(decompose(s1))\n        # print(decompose(s2))\n        \n        @lru_cache(None)\n        def search(s1, s2, diff):\n            if diff < 0:\n                return search(s2, s1, -diff)\n            \n            if diff == 0:\n                if s1 == s2:\n                    return True\n                if not s1 or not s2:\n                    return False\n                \n                if s1[0].isdigit() or s2[0].isdigit():\n                    for n1, sb1 in decompose(s1):\n                        for n2, sb2 in decompose(s2):\n                            if search(sb1, sb2, n1 - n2):\n                                return True\n                else:\n                    if s1[0] == s2[0]:\n                        return search(s1[1:], s2[1:], diff)\n                    else:\n                        return False\n                    \n            else:\n                if not s2:\n                    return False\n                if s2[0].isdigit():\n                    for n2, sb2 in decompose(s2):\n                        if search(s1, sb2, diff - n2):\n                            return True\n                else:\n                    return search(s1, s2[1:], diff-1)\n        \n        return search(s1, s2, 0)\n        \n#         @lru_cache(None)\n#         def search(s1, s2, diff):\n#             if diff == 0 and s1 == s2:\n#                 return True\n            "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3801", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 2 that\n\nAlice and Bob have an undirected graph of n nodes and three types of edges:\n\nType 1: Can be traversed by Alice only.\nType 2: Can be traversed by Bob only.\nType 3: Can be traversed by both Alice and Bob.\n\nGiven an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.\nReturn the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph.\n\u00a0\nExample 1:\n\nInput: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]\nOutput: 2\nExplanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.\n\nExample 2:\n\nInput: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]\nOutput: 0\nExplanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.\n\nExample 3:\n\nInput: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]\nOutput: -1\nExplanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.\n\u00a0\n\u00a0\nConstraints:\n\n1 <= n <= 100000\n1 <= edges.length <= min(100000, 3 * n * (n - 1) / 2)\nedges[i].length == 3\n1 <= typei <= 3\n1 <= ui < vi <= n\nAll tuples (typei, ui, vi) are distinct.\n\n"}, {"role": "assistant", "content": "\nclass DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        self.sz[yr] = self.sz[xr]\n        return True\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\nclass Solution(object):\n    def maxNumEdgesToRemove(self, N, edges):\n        for row in edges:\n            # row[0] -= 1\n            row[1] -= 1\n            row[2] -= 1\n        alice = []\n        bob = []\n        both = []\n        \n        for t, u, v in edges:\n            if t == 1:\n                alice.append([u,v])\n            elif t==2:\n                bob.append([u,v])\n            else:\n                both.append([u,v])\n        dsu1 = DSU(N)\n        dsu2 = DSU(N)\n        ans = 0\n        for u,v  in both:\n            dsu2.union(u,v)\n            if not dsu1.union(u, v):\n                ans += 1\n        for u,v  in alice:\n            if not dsu1.union(u,v): ans += 1\n        for u,v in bob:\n            if not dsu2.union(u,v): ans += 1\n        \n        if dsu1.size(0) != N:\n            return -1\n        if dsu2.size(0) != N:\n            return -1\n        return ans"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3836", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 2 that\n\nWe are given n different types of stickers. Each sticker has a lowercase English word on it.\nYou would like to spell out the given string target by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.\nReturn the minimum number of stickers that you need to spell out target. If the task is impossible, return -1.\nNote: In all test cases, all words were chosen randomly from the 1000 most common US English words, and target was chosen as a concatenation of two random words.\n\u00a0\nExample 1:\nInput: stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\nOutput: 3\nExplanation:\nWe can use 2 \"with\" stickers, and 1 \"example\" sticker.\nAfter cutting and rearrange the letters of those stickers, we can form the target \"thehat\".\nAlso, this is the minimum number of stickers necessary to form the target string.\n\nExample 2:\nInput: stickers = [\"notice\",\"possible\"], target = \"basicbasic\"\nOutput: -1\nExplanation:\nWe cannot form the target \"basicbasic\" from cutting letters from the given stickers.\n\n\u00a0\nConstraints:\n\nn == stickers.length\n1 <= n <= 50\n1 <= stickers[i].length <= 10\n1 <= target.length <= 15\nstickers[i] and target consist of lowercase English letters.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        c2i = dict()\n        t_tar = list()\n        for c in target:\n            if c not in c2i:\n                c2i[c] = len(t_tar)\n                t_tar.append(1)\n            else:\n                t_tar[c2i[c]] += 1\n        n = len(t_tar)\n        l_stickers = list()\n        n_found = set()\n        for sticker in stickers:\n            t = [0] * n\n            for c in sticker:\n                if c in c2i:\n                    n_found.add(c)\n                    t[c2i[c]] += 1\n            l_stickers.append(t)\n        if len(n_found) < n:\n            return -1\n        n_stickers = len(l_stickers)\n        deleted = [False] * n_stickers\n        for i in xrange(n_stickers):\n            if deleted[i]:\n                continue\n            for j in xrange(i+1, n_stickers):\n                if deleted[j]:\n                    continue\n                if self.le(l_stickers[i], l_stickers[j]):\n                    deleted[i] = True\n                elif self.le(l_stickers[j], l_stickers[i]):\n                    deleted[j] = True\n        stickers = list()\n        for i in xrange(n_stickers):\n            if not deleted[i]:\n                stickers.append(l_stickers[i])\n        #print stickers, t_tar\n        q = collections.deque()\n        q.append(t_tar)\n        level = 0\n        while q:\n            n_temp = len(q)\n            level += 1\n            for i in xrange(n_temp):\n                t = q.popleft()\n                for s in stickers:\n                    if self.le(t, s):\n                        return level\n                for s in stickers:\n                    new_t = self.sub(t, s)\n                    q.append(new_t)\n        return -1\n\n    def sub(self, t, s):\n        n = len(t)\n        ret = [0] * n\n        for i in xrange(n):\n            ret[i] = t[i] - s[i]\n        return ret\n        \n        \n        \n                \n    def le(self, s1, s2):\n        n = len(s1)\n        for i in xrange(n):\n            if s1[i] > s2[i]:\n                return False\n        return True\n                \n        \n        \n        \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3895", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 3 that\n\nYou are given an m x n matrix board, representing the current state of a crossword puzzle. The crossword contains lowercase English letters (from solved words), ' ' to represent any empty cells, and '#' to represent any blocked cells.\nA word can be placed horizontally (left to right or right to left) or vertically (top to bottom or bottom to top) in the board if:\n\nIt does not occupy a cell containing the character '#'.\nThe cell each letter is placed in must either be ' ' (empty) or match the letter already on the board.\nThere must not be any empty cells ' ' or other lowercase letters directly left or right of the word if the word was placed horizontally.\nThere must not be any empty cells ' ' or other lowercase letters directly above or below the word if the word was placed vertically.\n\nGiven a string word, return true if word can be placed in board, or false otherwise.\n\u00a0\nExample 1:\n\nInput: board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \"c\", \" \"]], word = \"abc\"\nOutput: true\nExplanation: The word \"abc\" can be placed as shown above (top to bottom).\n\nExample 2:\n\nInput: board = [[\" \", \"#\", \"a\"], [\" \", \"#\", \"c\"], [\" \", \"#\", \"a\"]], word = \"ac\"\nOutput: false\nExplanation: It is impossible to place the word because there will always be a space/letter above or below it.\nExample 3:\n\nInput: board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \" \", \"c\"]], word = \"ca\"\nOutput: true\nExplanation: The word \"ca\" can be placed as shown above (right to left). \n\n\u00a0\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m * n <= 2 * 100000\nboard[i][j] will be ' ', '#', or a lowercase English letter.\n1 <= word.length <= max(m, n)\nword will contain only lowercase English letters.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:\n        m, n = len(board), len(board[0])\n        for i in range(m) :\n            temp = []\n            for j in range(-1, n) :\n                if j == n-1 or board[i][j+1] == '#' :\n                    if len(temp) == len(word) :\n                        mark = True\n                        for k in range(len(word)) :\n                            if not temp[k] == word[k] and not temp[k] == ' ' :\n                                mark = False\n                                break\n                        if mark :\n                            return True\n                        mark = True\n                        for k in range(len(word)) :\n                            if not temp[k] == word[-k-1] and not temp[k] == ' ' :\n                                mark = False\n                                break\n                        if mark :\n                            return True\n                        \n                    temp = []\n                    continue\n                if not j == n-1 :\n                    temp.append(board[i][j+1])\n\n\n        for i in range(n) :\n            temp = []\n            for j in range(-1, m) :\n                if j == m-1 or board[j+1][i] == '#' :\n                    if len(temp) == len(word) :\n                        mark = True\n                        for k in range(len(word)) :\n                            if not temp[k] == word[k] and not temp[k] == ' ' :\n                                mark = False\n                                break\n                        if mark :\n                            return True\n                        mark = True\n                        for k in range(len(word)) :\n                            if not temp[k] == word[-k-1] and not temp[k] == ' ' :\n                                mark = False\n                                break\n                        if mark :\n                            return True\n                    temp = []\n                    continue\n                if not j == m-1 :\n                    temp.append(board[j+1][i])\n        return False"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3905", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 3 program that\n\nA concert hall has n rows numbered from 0 to n - 1, each with m seats, numbered from 0 to m - 1. You need to design a ticketing system that can allocate seats in the following cases:\n\nIf a group of k spectators can sit together in a row.\nIf every member of a group of k spectators can get a seat. They may or may not sit together.\n\nNote that the spectators are very picky. Hence:\n\nThey will book seats only if each member of their group can get a seat with row number less than or equal to maxRow. maxRow can vary from group to group.\nIn case there are multiple rows to choose from, the row with the smallest number is chosen. If there are multiple seats to choose in the same row, the seat with the smallest number is chosen.\n\nImplement the BookMyShow class:\n\nBookMyShow(int n, int m) Initializes the object with n as number of rows and m as number of seats per row.\nint[] gather(int k, int maxRow) Returns an array of length 2 denoting the row and seat number (respectively) of the first seat being allocated to the k members of the group, who must sit together. In other words, it returns the smallest possible r and c such that all [c, c + k - 1] seats are valid and empty in row r, and r <= maxRow. Returns [] in case it is not possible to allocate seats to the group.\nboolean scatter(int k, int maxRow) Returns true if all k members of the group can be allocated seats in rows 0 to maxRow, who may or may not sit together. If the seats can be allocated, it allocates k seats to the group with the smallest row numbers, and the smallest possible seat numbers in each row. Otherwise, returns false.\n\n\u00a0\nExample 1:\nInput\n[\"BookMyShow\", \"gather\", \"gather\", \"scatter\", \"scatter\"]\n[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]\nOutput\n[null, [0, 0], [], true, false]\n\nExplanation\nBookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each \nbms.gather(4, 0); // return [0, 0]\n                  // The group books seats [0, 3] of row 0. \nbms.gather(2, 0); // return []\n                  // There is only 1 seat left in row 0,\n                  // so it is not possible to book 2 consecutive seats. \nbms.scatter(5, 1); // return True\n                   // The group books seat 4 of row 0 and seats [0, 3] of row 1. \nbms.scatter(5, 1); // return False\n                   // There is only one seat left in the hall.\n\n\u00a0\nConstraints:\n\n1 <= n <= 5 * 10000\n1 <= m, k <= 10^9\n0 <= maxRow <= n - 1\nAt most 5 * 10000 calls in total will be made to gather and scatter.\n\n"}, {"role": "assistant", "content": "class Fenwick:\n    def __init__(self, n):\n        self.A = [0] * (n + 2)\n        self.n = n\n    def query(self, k):\n        n = self.n\n        if k < 0: return 0\n        # assert 0 <= k\n        if k >= n: k = n - 1\n        r = 0\n        k += 1\n        while k > 0:\n            r += self.A[k]\n            k -= k & -k\n        return r\n    def update(self, k, v):\n        assert 0 <= k < self.n\n        k += 1\n        while k < len(self.A):\n            self.A[k] += v\n            k += k & -k\n\nclass Segment:\n    def __init__(self, l, r, A):\n        self.l, self.r = l, r\n        if l == r:\n            self.left, self.right = None, None\n            self.val = A[l]\n        else:\n            mid = (self.l + self.r) // 2\n            self.left, self.right = Segment(l, mid, A), Segment(mid + 1, r, A)\n            self.val = max(self.left.val, self.right.val)\n\n    def query(self, l, r):\n        if l < self.l: l = self.l\n        if r > self.r: r = self.r\n        if l > r: return 0\n        if l == self.l and r == self.r: return self.val\n        # mid = (self.l + self.r) // 2\n\n        return max(self.left.query(l, r), self.right.query(l, r))\n\n    def update(self, k, v):\n        if k < self.l or k > self.r: return\n        if k == self.l == self.r:\n            self.val += v\n            # print(\"update\",k,v,self.val)\n        else:\n            self.left.update(k, v)\n            self.right.update(k, v)\n            self.val = max(self.left.val, self.right.val)\n\n\nclass Link:\n    def __init__(self, n):\n        self.n = n\n        self.L, self.R = [i-1 for i in range(n+2)], [i+1 for i in range(n+2)]\n        self.L[0] = 0\n        self.R[n+1] = n+1\n\n    def remove(self, k):\n        l, r = self.L[k+1], self.R[k+1]\n        self.L[r] = l\n        self.R[l] = r\n        # print(\"update\", k, l, r)\n        self.L[k+1] = self.R[k+1] = -1\n\n    def forward(self, k):\n        index = self.R[k + 1]\n        if index-1 < self.n:\n            return index - 1\n        else:\n            return None\n\n\nclass BookMyShow:\n\n    def __init__(self, n: int, m: int):\n        self.n, self.m = n, m\n        self.A = [m] * n\n        self.F = Fenwick(n)\n        self.S = Segment(0, n - 1, self.A)\n        self.L = Link(n)\n        for i in range(n):\n            self.F.update(i, m)\n\n    def find(self, k, maxRow):\n        lo, hi = 0, maxRow\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if self.S.query(0, mid) >= k:\n                hi = mid\n            else:\n                lo = mid + 1\n\n        if self.S.query(0, lo) < k:\n            index = None\n        else:\n            index = lo\n\n        return index\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        index = self.find(k, maxRow)\n\n        # print(\">\",[self.S.query(0, i) for i in range(self.n)])\n\n        # index_brute = min((i for i in range(maxRow + 1) if self.A[i] >= k), default=None)\n        # assert index == index_brute, (index, index_brute, lo ,hi)\n\n        if index is None: return []\n\n        p = self.m - self.A[index]\n\n        self.A[index] -= k\n        if self.A[index] == 0:\n            self.L.remove(index)\n        self.S.update(index, -k)\n        self.F.update(index, -k)\n\n        return [index, p]\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        s = self.F.query(maxRow)\n\n        # s_brute = sum(self.A[:maxRow + 1])\n        # assert s == s_brute\n\n        if s < k: return False\n\n        # index = self.find(1, maxRow)\n        index = self.L.forward(-1)\n        # print(index, self.L.L, self.L.R)\n        # for i in range(index, maxRow + 1):\n\n        i = index\n        while i <= maxRow:\n            if k == 0: break\n            u = min(self.A[i], k)\n            self.A[i] -= u\n            ni = self.L.forward(i)\n            if self.A[i] == 0:\n                self.L.remove(i)\n            self.S.update(i, -u)\n            self.F.update(i, -u)\n            k -= u\n            if k == 0: break\n\n            i = ni\n            # print('now', i)\n\n        return True\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3906", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 2 to\n\nA concert hall has n rows numbered from 0 to n - 1, each with m seats, numbered from 0 to m - 1. You need to design a ticketing system that can allocate seats in the following cases:\n\nIf a group of k spectators can sit together in a row.\nIf every member of a group of k spectators can get a seat. They may or may not sit together.\n\nNote that the spectators are very picky. Hence:\n\nThey will book seats only if each member of their group can get a seat with row number less than or equal to maxRow. maxRow can vary from group to group.\nIn case there are multiple rows to choose from, the row with the smallest number is chosen. If there are multiple seats to choose in the same row, the seat with the smallest number is chosen.\n\nImplement the BookMyShow class:\n\nBookMyShow(int n, int m) Initializes the object with n as number of rows and m as number of seats per row.\nint[] gather(int k, int maxRow) Returns an array of length 2 denoting the row and seat number (respectively) of the first seat being allocated to the k members of the group, who must sit together. In other words, it returns the smallest possible r and c such that all [c, c + k - 1] seats are valid and empty in row r, and r <= maxRow. Returns [] in case it is not possible to allocate seats to the group.\nboolean scatter(int k, int maxRow) Returns true if all k members of the group can be allocated seats in rows 0 to maxRow, who may or may not sit together. If the seats can be allocated, it allocates k seats to the group with the smallest row numbers, and the smallest possible seat numbers in each row. Otherwise, returns false.\n\n\u00a0\nExample 1:\nInput\n[\"BookMyShow\", \"gather\", \"gather\", \"scatter\", \"scatter\"]\n[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]\nOutput\n[null, [0, 0], [], true, false]\n\nExplanation\nBookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each \nbms.gather(4, 0); // return [0, 0]\n                  // The group books seats [0, 3] of row 0. \nbms.gather(2, 0); // return []\n                  // There is only 1 seat left in row 0,\n                  // so it is not possible to book 2 consecutive seats. \nbms.scatter(5, 1); // return True\n                   // The group books seat 4 of row 0 and seats [0, 3] of row 1. \nbms.scatter(5, 1); // return False\n                   // There is only one seat left in the hall.\n\n\u00a0\nConstraints:\n\n1 <= n <= 5 * 10000\n1 <= m, k <= 10^9\n0 <= maxRow <= n - 1\nAt most 5 * 10000 calls in total will be made to gather and scatter.\n\n"}, {"role": "assistant", "content": "class segment_tree(object):\n\n\n    # minimum value \n    def merge(self,num,minimum):\n        return max(minimum,num)\n\n\n    def __init__(self,n,initial):\n        self.n = n\n        self.arr = [0]*(2*n)\n        for i in range(2*n-1,0,-1):\n            if i>=n:  self.arr[i] = initial[i-n]\n            else:     self.arr[i] = self.merge(self.arr[2*i],self.arr[2*i+1])\n\n\n\n\n    def update(self,index,target):\n\n        self.arr[index] = target\n        if index & 1:\n            nexttarget = self.merge( self.arr[index], self.arr[index-1])\n        else:\n            nexttarget = self.merge( self.arr[index], self.arr[index+1])\n        if index>0:  self.update(index>>1,nexttarget )\n\n\n    def addnum(self,index,diff):\n        self.update(index+self.n, self.arr[index+self.n] + diff)\n\n\n    def query(self,left,right):\n        i,j = self.n+left,  self.n+right+1\n        output = 0  # initial output should be changed if you want to change the merge function\n\n        while i<j:\n            if i&1:\n                output = self.merge(self.arr[i],output)\n                i += 1\n            if j&1:\n                j -= 1\n                output = self.merge(self.arr[j],output)\n            i = i >> 1\n            j = j >> 1\n        return output\n    \n    \nclass fenwick(object):\n    def __init__(self, n):\n        self.n = n\n        self.cul = [0]*n\n\n    def update(self,index,diff):\n        i = index\n        while i<self.n:\n            self.cul[i] += diff\n            i += (i+1)&(-i-1)\n\n\n    def getaccu(self,index):\n        output = 0\n        i = index\n        while i>=0:\n            output += self.cul[i]\n            i -= (i+1)&(-i-1)\n        return output\n\n    \n    \n    \n    \n\nclass BookMyShow(object):\n\n    def __init__(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        \"\"\"\n        self.avail = segment_tree(n,[m]*n)\n        self.accu = fenwick(n)\n        self.m = m\n        \n        for i in range(n):\n            self.accu.update(i,m)\n    \n        self.nonzero_index = 0\n        \n        \n        \n        \n        \n        \n        \n\n    def gather(self, k, maxRow):\n        \"\"\"\n        :type k: int\n        :type maxRow: int\n        :rtype: List[int]\n        \"\"\"\n        front = 0\n        rear = maxRow\n        \n       # print self.avail.query(0,maxRow)\n        \n        if self.avail.query(0,maxRow) < k:\n            return []\n        \n        while front<rear:\n            mid = (front+rear)//2\n            if self.avail.query(0,mid) < k:\n                front = mid + 1\n            else:\n                rear = mid \n        \n        output = [front,self.m - self.avail.query(front,front)]\n        self.avail.addnum(front,-k)\n        self.accu.update(front,-k)\n        \n        \n        \n        \n        \n        return output \n\n        \n        \n        \n\n    def scatter(self, k, maxRow):\n        \"\"\"\n        :type k: int\n        :type maxRow: int\n        :rtype: bool\n        \"\"\"\n        totrest = self.accu.getaccu(maxRow)\n        \n      #  print totrest,k,\"--\"\n        \n        if totrest < k:  \n            return False\n        \n        \n        \n     #   print \"ha\"\n        \n        rest = k\n        while self.nonzero_index <= maxRow:\n            num = self.avail.query(self.nonzero_index,self.nonzero_index)\n         #   print self.nonzero_index,num\n            if num >= rest:\n                self.avail.addnum(self.nonzero_index,-rest)\n                self.accu.update(self.nonzero_index,-rest)\n                return True\n            else:\n                rest -= num\n                self.avail.addnum(self.nonzero_index,-num)\n                self.accu.update(self.nonzero_index,-num)                \n\n                self.nonzero_index += 1\n                \n                \n                \n    \n        return True\n    \n            \n        \n            \n                \n            \n        \n\n\n# Your BookMyShow object will be instantiated and called as such:\n# obj = BookMyShow(n, m)\n# param_1 = obj.gather(k,maxRow)\n# param_2 = obj.scatter(k,maxRow)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3915", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 2 to\n\nWe define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\u00a0\nExample 1:\nInput: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2\nExample 2:\nInput: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 1000000\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def getMaxRepetitions(self, s1, n1, s2, n2):\n        D1 = {}\n        D2 = {}\n        for i,x in enumerate(s1):\n            if x not in D1:\n                D1[x] = [i]\n            else:\n                D1[x].append(i)\n        for i,x in enumerate(s2):\n            if x not in D2:\n                D2[x] = [i]\n            else:\n                D2[x].append(i)\n        for x in D2:\n            if x not in D1:\n                return 0\n        L = [{} for i in range(len(s1))]\n        for i,x in enumerate(s1):\n            if x not in D2:\n                continue\n            for j in D2[x]:\n                poss = D1[s2[j+1]] if j+1 <len(s2) else D1[s2[0]]\n                if i >= poss[-1]:\n                    L[i][j] = [poss[0], 1]\n                else:\n                    for k in poss:\n                        if k > i:\n                            break\n                    L[i][j] = [k, 0]\n        p2 = 0\n        p1 = D1[s2[0]][0]\n        useds1 = 0\n        useds2 = 0\n        \n        roundandpos = {p1:[0,0]}\n        \n        sign = 0\n        while useds1 < n1:\n            v = L[p1][p2]\n            p1 = v[0]\n            useds1 += v[1]\n            p2 += 1\n            if p2 == len(s2):\n                useds2 +=1\n                p2 = 0\n                if sign == 0:\n                    if p1 in roundandpos:\n                        sign = 1\n                        [l1, k1] = roundandpos[p1]\n                        l2, k2 = useds1, useds2\n                        s1left = n1 - l2\n                        roundsleft = s1left/(l2-l1) - 1\n                        useds1 += roundsleft * (l2-l1)\n                        useds2 += roundsleft * (k2-k1)\n                    else:\n                        roundandpos[p1] = [useds1, useds2]\n        return useds2/n2\n            \n                    \n        \n        \n        \n        \"\"\"\n        :type s1: str\n        :type n1: int\n        :type s2: str\n        :type n2: int\n        :rtype: int\n        \"\"\"\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3941", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 2 function for\n\nYou are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer.\nThe second greater integer of nums[i] is nums[j] such that:\n\nj > i\nnums[j] > nums[i]\nThere exists exactly one index k such that nums[k] > nums[i] and i < k < j.\n\nIf there is no such nums[j], the second greater integer is considered to be -1.\n\nFor example, in the array [1, 2, 4, 3], the second greater integer of 1 is 4, 2 is 3,\u00a0and that of 3 and 4 is -1.\n\nReturn an integer array answer, where answer[i] is the second greater integer of nums[i].\n\u00a0\nExample 1:\nInput: nums = [2,4,0,9,6]\nOutput: [9,6,6,-1,-1]\nExplanation:\n0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.\n1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.\n2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.\n3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.\n4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.\nThus, we return [9,6,6,-1,-1].\n\nExample 2:\nInput: nums = [3,3]\nOutput: [-1,-1]\nExplanation:\nWe return [-1,-1] since neither integer has any integer greater than it.\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 100000\n0 <= nums[i] <= 10^9\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def secondGreaterElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        mx=1\n        while mx<=n: mx<<=1\n        ix = [0]*(mx+mx)\n        r =[-1]*n\n        i = n-1\n        def addv(i, v):\n            i+=mx\n            ix[i]=v\n            i>>=1\n            while i:\n                ix[i]=max(ix[i*2], ix[i*2+1])\n                i>>=1\n        def findx(i, v):\n            s=i+mx\n            e=mx+mx-1\n            while s<=e:\n                if ix[s]>=v: break\n                if s&1: s+=1\n                if (e&1)==0: e-=1\n                s>>=1\n                e>>=1\n            if s>e: return n+1\n            while s<mx:\n                if ix[s*2]>=v: s=s*2\n                else: s=s*2+1\n            return s-mx\n        while i>=0:\n            j = findx(i+1, nums[i]+1)\n            if j<n:\n                j=findx(j+1, nums[i]+1)\n                if j<n: r[i]=nums[j]\n            addv(i, nums[i])\n            i-=1\n        return r"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3990", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 3 to\n\nThere are\u00a0n\u00a0items each\u00a0belonging to zero or one of\u00a0m\u00a0groups where group[i]\u00a0is the group that the i-th item belongs to and it's equal to -1\u00a0if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\nReturn a sorted list of the items such that:\n\nThe items that belong to the same group are next to each other in the sorted list.\nThere are some\u00a0relations\u00a0between these items where\u00a0beforeItems[i]\u00a0is a list containing all the items that should come before the\u00a0i-th item in the sorted array (to the left of the\u00a0i-th item).\n\nReturn any solution if there is more than one solution and return an empty list\u00a0if there is no solution.\n\u00a0\nExample 1:\n\nInput: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\nOutput: [6,3,4,1,5,2,0,7]\n\nExample 2:\nInput: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\nOutput: []\nExplanation:\u00a0This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n\n\u00a0\nConstraints:\n\n1 <= m <= n <= 3 * 10000\ngroup.length == beforeItems.length == n\n-1 <= group[i] <= m - 1\n0 <= beforeItems[i].length <= n - 1\n0 <= beforeItems[i][j] <= n - 1\ni != beforeItems[i][j]\nbeforeItems[i]\u00a0does not contain\u00a0duplicates elements.\n\n"}, {"role": "assistant", "content": "class Solution:\n    \n    def topoSort(self, nodes, edges):\n        # if fail: return -1\n        if not edges:\n            return nodes\n        inDegree = {i:0 for i in nodes}\n        to = {i:[] for i in nodes}\n        for s, t in edges:\n            inDegree[t] += 1\n            to[s].append(t)\n        finishCount = 0\n        targetCount = len(nodes)\n        q = []\n        qHead = 0\n        for i in nodes:\n            if inDegree[i] == 0:\n                q.append(i)\n                finishCount += 1\n        while qHead < len(q):\n            cur = q[qHead]\n            for t in to[cur]:\n                inDegree[t] -= 1\n                if inDegree[t] == 0:\n                    q.append(t)\n                    finishCount += 1\n            qHead += 1\n            \n        if finishCount < targetCount:\n            return -1\n        return q\n            \n        \n    def sortItems(self, n: int, m: int, group, beforeItems):\n        for i in range(len(group)):\n            if group[i] == -1:\n                group[i] = m\n                m += 1\n        itemInGroup = [[] for _ in range(m)]\n        \n        for i in range(len(group)):\n            itemInGroup[group[i]].append(i)\n        \n        edgeInGroup = [set() for _ in range(m)]\n        \n        edgeBetweenGroup = set()\n        for i in range(len(beforeItems)):\n            for pre in beforeItems[i]:\n                if group[i] == group[pre]:\n                    edgeInGroup[group[i]].add((pre, i))\n                else:\n                    edgeBetweenGroup.add((group[pre], group[i]))\n        for i in range(m):\n            if edgeInGroup[i]:\n                res = self.topoSort(itemInGroup[i], edgeInGroup[i])\n                if res == -1:\n                    return []\n                itemInGroup[i] = res\n        groupOrder = list(range(m))\n        res = self.topoSort(groupOrder, edgeBetweenGroup)\n        if res == -1:\n            return []\n        groupOrder = res\n        ans = []\n        for g in groupOrder:\n            for i in itemInGroup[g]:\n                ans.append(i)\n        return ans\n           "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_3992", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 2 to\n\nThere are\u00a0n\u00a0items each\u00a0belonging to zero or one of\u00a0m\u00a0groups where group[i]\u00a0is the group that the i-th item belongs to and it's equal to -1\u00a0if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\nReturn a sorted list of the items such that:\n\nThe items that belong to the same group are next to each other in the sorted list.\nThere are some\u00a0relations\u00a0between these items where\u00a0beforeItems[i]\u00a0is a list containing all the items that should come before the\u00a0i-th item in the sorted array (to the left of the\u00a0i-th item).\n\nReturn any solution if there is more than one solution and return an empty list\u00a0if there is no solution.\n\u00a0\nExample 1:\n\nInput: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\nOutput: [6,3,4,1,5,2,0,7]\n\nExample 2:\nInput: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\nOutput: []\nExplanation:\u00a0This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n\n\u00a0\nConstraints:\n\n1 <= m <= n <= 3 * 10000\ngroup.length == beforeItems.length == n\n-1 <= group[i] <= m - 1\n0 <= beforeItems[i].length <= n - 1\n0 <= beforeItems[i][j] <= n - 1\ni != beforeItems[i][j]\nbeforeItems[i]\u00a0does not contain\u00a0duplicates elements.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def sortItems(self, n, m, group, beforeItems):\n        items = list(enumerate(group))\n        items.sort(key = lambda z: z[1])\n        groups = []\n        groupsets = []\n        setsindex = [None] * n\n        \n        GRAY, BLACK = 0, 1\n\n        def topological(graph, enter=None):\n            ans,state = [], {}\n            if enter is None: enter = set(graph)\n            else: enter = set(range(n))\n\n            def dfs(node):\n                state[node] = GRAY\n                for k in graph.get(node, ()):\n                    sk = state.get(k, None)\n                    if sk == GRAY:\n                        raise ValueError(\"cycle\")\n                    if sk == BLACK: continue\n                    enter.discard(k)\n                    dfs(k)\n                ans.append(node)\n                state[node] = BLACK\n\n            while enter: dfs(enter.pop())\n            return ans[::-1]\n\n        def topological_list(graph):\n            ans,state = [], {}\n            enter = set(range(len(graph)))\n\n            def dfs(node):\n                state[node] = GRAY\n                for k in graph[node]:\n                    sk = state.get(k, None)\n                    if sk == GRAY:\n                        raise ValueError(\"cycle\")\n                    if sk == BLACK: continue\n                    enter.discard(k)\n                    dfs(k)\n                ans.append(node)\n                state[node] = BLACK\n\n            while enter: dfs(enter.pop())\n            return ans[::-1]\n        \n        def internalsort(aset):\n            graph = collections.defaultdict(list)\n            for u in aset:\n                graph[u]\n                for v in beforeItems[u]:\n                    if v in aset:\n                        graph[v].append(u)\n            try:\n                return topological(graph)\n            except:\n                #print 'isort err', aset, [beforeItems[u] for u in aset]\n                return None\n        \n        \n        index = 0\n        for k, grp in itertools.groupby(items, key = lambda z: z[1]):\n            grp = list(grp)\n            rowset = {x for x, y in grp}\n            groupsets.append(rowset)\n            for x in rowset:\n                setsindex[x] = index\n            row = internalsort(rowset)\n            groups.append(row)\n            if row is None: return []\n            index += 1\n        \n        # Merge before requirements\n        graph2 = [set() for _ in xrange(len(groups))]\n        for gx, group in enumerate(groups):\n            beforeset = set()\n            for y in group:\n                for x in beforeItems[y]:\n                    hx = setsindex[x]\n                    if hx != gx:\n                        graph2[hx].add(gx)\n\n        try:\n            ans = topological_list(graph2)\n            fans = []\n            for gx in ans:\n                fans.extend(groups[gx])\n            return fans\n        except:\n            return []"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4001", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 program that can\n\nYou are given an integer array nums\u200b\u200b\u200b and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset.\nA subset's incompatibility is the difference between the maximum and minimum elements in that array.\nReturn the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible.\nA subset is a group integers that appear in the array with no particular order.\n\u00a0\nExample 1:\nInput: nums = [1,2,1,4], k = 2\nOutput: 4\nExplanation: The optimal distribution of subsets is [1,2] and [1,4].\nThe incompatibility is (2-1) + (4-1) = 4.\nNote that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements.\nExample 2:\nInput: nums = [6,3,8,1,3,1,2,2], k = 4\nOutput: 6\nExplanation: The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].\nThe incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6.\n\nExample 3:\nInput: nums = [5,3,3,6,3,3], k = 3\nOutput: -1\nExplanation: It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset.\n\n\u00a0\nConstraints:\n\n1 <= k <= nums.length <= 16\nnums.length is divisible by k\n1 <= nums[i] <= nums.length\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def minimumIncompatibility(self, nums, k):\n        g = k\n        k = len(nums)/g\n        p = [i for i in xrange(k)]\n        N = [1<<i for i in xrange(len(nums))]\n        M = []\n        def S(p):\n            r = 0\n            for u in p: r += N[u]\n            return r\n        M.append(S(p))\n        while 1:\n            if p[-1]<len(nums)-1:\n                p[-1]+=1\n                M.append(S(p))\n            else:\n                inc = 0\n                for u in xrange(len(p)-2, -1, -1):\n                    if p[u]<p[u+1]-1:\n                        inc = 1\n                        p[u]+=1\n                        for d in xrange(u+1, len(p)):\n                            p[d]=p[d-1]+1\n                        break\n                if not inc: break\n                M.append(S(p))\n        IN = {}\n        ValidM = []\n        for mask in M:\n            s = set()\n            b = 0\n            MAX, MIN = 0, float('inf')\n            for i in xrange(len(N)):\n                if mask | N[i] == mask:\n                    if nums[i] in s:\n                        b = 1\n                        break\n                    s.add(nums[i])\n                    MAX = max(MAX, nums[i])\n                    MIN = min(MIN, nums[i])\n            if not b:\n                IN[mask] = MAX-MIN\n                ValidM.append(mask)\n        M = ValidM\n        memo = {}\n        def sol(mask, g):\n            if (mask, g) in memo: return memo[(mask, g)]\n            res = -1\n            if g == 1:\n                for m in M:\n                    if m & mask == 0:\n                        res = IN[m]\n                        break\n            else:\n                for m in M:\n                    if m & mask == 0:\n                        r = sol(mask|m, g-1)\n                        if r != -1:\n                            if res == -1: res = IN[m]+sol(mask|m, g-1)\n                            else:\n                                res = min(res,IN[m]+sol(mask|m, g-1))\n            memo[(mask, g)]=res\n            return res\n        return sol(0, g)\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4016", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 program that can\n\nYou are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized.\nMore formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive.\nReturn the maximum possible product of the lengths of the two non-intersecting palindromic substrings.\nA palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\n\u00a0\nExample 1:\nInput: s = \"ababbb\"\nOutput: 9\nExplanation: Substrings \"aba\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9.\n\nExample 2:\nInput: s = \"zaaaxbbby\"\nOutput: 9\nExplanation: Substrings \"aaa\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9.\n\n\u00a0\nConstraints:\n\n2 <= s.length <= 100000\ns consists of lowercase English letters.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def maxProduct(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        T = '$#' + '#'.join(s) + '#@'\n\n        l = len(T)\n        P = [0] * l\n        R, C = 0, 0\n        # print(T,P)\n        for i in range(1,l-1):\n            if i < R:\n                P[i] = min(P[2 * C - i], R - i)\n\n            while T[i+(P[i]+1)] == T[i-(P[i]+1)]:\n                P[i] += 1\n\n            if P[i] + i > R:\n                R = P[i] + i\n                C = i\n        arr = []\n        for i in range(len(T)):\n            if T[i].isalpha():\n                arr.append(P[i])\n        presum = [1 for _ in range(len(s))]\n        for i in range(len(s)):\n            presum[i+(arr[i]-1)//2] = max(presum[i+(arr[i]-1)//2],arr[i])\n    #     print(presum)\n        for i in range(len(s)-2,-1,-1):\n            presum[i] = max(presum[i],presum[i+1]-2)\n\n    #     print(presum)\n        for i in range(len(presum)-1):\n            presum[i+1] = max(presum[i],presum[i+1])\n\n        post = [1 for _ in range(len(s))]\n        for i in range(len(s)-1,-1,-1):\n            post[i-(arr[i]-1)//2] = max(post[i-(arr[i]-1)//2],arr[i])\n    #     print(post)\n        for i in range(1,len(s)):\n            post[i] = max(post[i],post[i-1]-2)    \n    #     print(post)\n        post = post[1:]+[0]\n    #     print(post)\n        for i in range(len(s)-1,0,-1):\n            post[i-1] = max(post[i-1],post[i])\n\n    #     print(presum,post)\n        res = 0\n        for i in range(len(presum)):\n            res = max(res,presum[i]*post[i])\n\n        return res\n\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4058", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 2 program that\n\nGiven an integer n, return the smallest prime palindrome greater than or equal to n.\nAn integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number.\n\nFor example, 2, 3, 5, 7, 11, and 13 are all primes.\n\nAn integer is a palindrome if it reads the same from left to right as it does from right to left.\n\nFor example, 101 and 12321 are palindromes.\n\nThe test cases are generated so that the answer always exists and is in the range [2, 2 * 10^8].\n\u00a0\nExample 1:\nInput: n = 6\nOutput: 7\nExample 2:\nInput: n = 8\nOutput: 11\nExample 3:\nInput: n = 13\nOutput: 101\n\n\u00a0\nConstraints:\n\n1 <= n <= 10^8\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def ndigs(self, N):\n        d = 0\n        while N > 0:\n            d += 1\n            N /= 10\n        return d\n    \n    def is_prime(self, v):\n        if v == 1:\n            return False\n        i = 2\n        while i*i <= v:\n            if v%i == 0:\n                return False\n            i += 1\n        return True\n    \n    def get_pals(self, ndigs, n):\n        if ndigs % 2 == 0:\n            nd = ndigs/2\n            if ndigs > len(str(n)):\n                start = 10**(nd-1)\n            else:\n                start = int(str(n)[:nd])\n            for i in xrange(start, 10**nd):\n                si = str(i)\n                v = int(si + si[::-1])\n                if v < n:\n                    continue\n                if self.is_prime(v):\n                    return v\n        else:\n            nd = ndigs/2 + 1\n            if ndigs > len(str(n)):\n                start = 10**(nd-1)\n            else:\n                start = int(str(n)[:nd])\n            for i in xrange(start, 10**nd):\n                si = str(i)\n                v = int(si[:-1] + si[::-1])\n                if v < n:\n                    continue\n                if self.is_prime(v):\n                    return v\n        return None\n    \n    def primePalindrome(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        nd = self.ndigs(N)\n        while True:\n            ret = self.get_pals(nd, N)\n            if ret is not None:\n                return ret\n            nd += 1\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4059", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 script for\n\nGiven an integer n, return the smallest prime palindrome greater than or equal to n.\nAn integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number.\n\nFor example, 2, 3, 5, 7, 11, and 13 are all primes.\n\nAn integer is a palindrome if it reads the same from left to right as it does from right to left.\n\nFor example, 101 and 12321 are palindromes.\n\nThe test cases are generated so that the answer always exists and is in the range [2, 2 * 10^8].\n\u00a0\nExample 1:\nInput: n = 6\nOutput: 7\nExample 2:\nInput: n = 8\nOutput: 11\nExample 3:\nInput: n = 13\nOutput: 101\n\n\u00a0\nConstraints:\n\n1 <= n <= 10^8\n\n"}, {"role": "assistant", "content": "class Solution:\n    PRIMES = []\n    MAXPRIME = 65535\n    def gen_primes():\n        a = [True] * (Solution.MAXPRIME + 1)\n        a[0] = a[1] = False\n        for i in range(2, int(Solution.MAXPRIME ** 0.5)+1):\n            for j in range(i * i, Solution.MAXPRIME + 1, i):\n                a[j] = False\n        Solution.PRIMES = [i for i in range(2, Solution.MAXPRIME + 1) if a[i]]\n    \n    def primePalindrome(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        if not Solution.PRIMES:\n            Solution.gen_primes()\n        primes = Solution.PRIMES\n        def isPrime(n):\n            for p in primes:\n                if p * p > n: break\n                if n % p == 0: return False\n            return True\n        \n        if N <= 11:\n            for p in primes:\n                if p >= N: return p\n        elif N <= 101:\n            return 101\n        \n        def get_p(n):\n            sn = str(n)\n            s = sn + sn[-2::-1]\n            return int(s)\n        \n        sN = str(N)\n        if len(sN) % 2:\n            st = int(sN[:(len(sN)+1)//2])\n            if get_p(st) < N: st += 1\n        else:\n            st = 10 ** (len(sN)//2)\n        while True:\n            n = get_p(st)\n            if isPrime(n): return n\n            st += 1\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4110", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 3 that\n\nThere is a country of n cities numbered from 0 to n - 1. In this country, there is a road connecting every pair of cities.\nThere are m friends numbered from 0 to m - 1 who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city more than once, but the same city will not be listed consecutively.\nGiven an integer n and a 2D integer array paths where paths[i] is an integer array representing the path of the ith friend, return the length of the longest common subpath that is shared by every friend's path, or 0 if there is no common subpath at all.\nA subpath of a path is a contiguous sequence of cities within that path.\n\u00a0\nExample 1:\nInput: n = 5, paths = [[0,1,2,3,4],\n                       [2,3,4],\n                       [4,0,1,2,3]]\nOutput: 2\nExplanation: The longest common subpath is [2,3].\n\nExample 2:\nInput: n = 3, paths = [[0],[1],[2]]\nOutput: 0\nExplanation: There is no common subpath shared by the three paths.\n\nExample 3:\nInput: n = 5, paths = [[0,1,2,3,4],\n                       [4,3,2,1,0]]\nOutput: 1\nExplanation: The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1.\n\u00a0\nConstraints:\n\n1 <= n <= 100000\nm == paths.length\n2 <= m <= 100000\nsum(paths[i].length) <= 100000\n0 <= paths[i][j] < n\nThe same city is not listed multiple times consecutively in paths[i].\n\n"}, {"role": "assistant", "content": "class Rabin_Karp:\n    \n    def single_rolling_hash_nums(self, arr, k, p = 113, MOD = 10**9+7):\n        \"\"\"Compute the rolling-hash on len-k subarrays of original integer array arr\n        \n        Inputs:\n            arr: the input array of integers\n            k: substring length\n            p: the prime number for power, default as 113\n            MOD: the prime number for mod, default at 10**9 + 7\n        Returns:\n            an array of integers, each value at res[i] is the rolling hash value of the k-sized \n            subarray arr[i:i+k]\n        \"\"\"\n        \n        if len(arr) < k:\n            return []\n\n        exp = 1\n        for i in range(k-1): # one place for easy-to-make mistakes: here exp only goes to p^(k-1), not p^k!\n            exp = (exp * p) % MOD\n        \n        h = 0\n        for i in range(k):\n            h = (h * p + arr[i]) % MOD\n                    \n        res = [h]\n        for i in range(k, len(arr)):\n            h = (((h - arr[i-k] * exp) % MOD) * p + arr[i]) % MOD # in python, % always return non-negative numbers\n            res.append(h)\n        \n        return res\n    \n    def single_rolling_hash_str(self, s, k, p = 113, MOD = 10**9+7):\n        \"\"\"Compute the rolling-hash on len-k substrings of original string s, everything else the same as self.single_rolling_hash_nums()\n        \"\"\"\n        arr = [ord(c) for c in s]\n        return self.single_rolling_hash_nums(arr, k, p, MOD)\n    \n\n    def rolling_hash_nums(self, arr, k, p = 113, MOD = 10**9+7, p2 = 101, MOD2 = 99991):\n        \"\"\"Compute the rolling-hash on len-k subarrays of original integer array arr, using two pairs of (mod, power)\n        The new rolling hash value is equal to hash1 * 100000 + hash2.\n        \"\"\"\n        hash1 = self.single_rolling_hash_nums(arr, k, p, MOD)\n        hash2 = self.single_rolling_hash_nums(arr, k, p2, MOD2)\n        return set((hash1[i], hash2[i]) for i in range(len(hash1)))\n    \n    def rolling_hash_str(self, s, k, p = 113, MOD = 10**9+7, p2 = 101, MOD2 = 99991):\n        \"\"\"Compute the rolling-hash on len-k substrings of original string s, with two pairs of prime numbers, everything else the same as self.rolling_hash_nums()\n        \"\"\"\n        arr = [ord(c) for c in s]\n        return self.rolling_hash_nums(arr, k, p, MOD, p2, MOD2)\n\nclass Solution:\n    def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n        hasher = Rabin_Karp()\n        \n        L = min([len(path) for path in paths])\n        \n        def can(lenn):\n            cnt = collections.Counter()\n            for path in paths:\n                uniq = hasher.rolling_hash_nums(path, lenn)\n                for key in uniq:\n                    cnt[key] += 1\n            maxx = max(cnt.values())\n            return maxx == len(paths)\n        \n        low, high = 0, L\n        while low < high:\n            mid = (low + high + 1) // 2\n            if can(mid):\n                low = mid\n            else:\n                high = mid - 1\n        return low"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4200", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 script for\n\nGiven an expression such as expression = \"e + 8 - a + 5\" and an evaluation map such as {\"e\": 1} (given in terms of evalvars = [\"e\"] and evalints = [1]), return a list of tokens representing the simplified expression, such as [\"-1*a\",\"14\"]\n\nAn expression alternates chunks and symbols, with a space separating each chunk and symbol.\nA chunk is either an expression in parentheses, a variable, or a non-negative integer.\nA variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like \"2x\" or \"-x\".\n\nExpressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.\n\nFor example, expression = \"1 + 2 * 3\" has an answer of [\"7\"].\n\nThe format of the output is as follows:\n\nFor each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.\n\t\nFor example, we would never write a term like \"b*a*c\", only \"a*b*c\".\n\n\nTerms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.\n\t\nFor example, \"a*a*b*c\" has degree 4.\n\n\nThe leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.\nAn example of a well-formatted answer is [\"-2*a*a*a\", \"3*a*a*b\", \"3*b*b\", \"4*a\", \"5*c\", \"-6\"].\nTerms (including constant terms) with coefficient 0 are not included.\n\t\nFor example, an expression of \"0\" has an output of [].\n\n\n\nNote: You may assume that the given expression is always valid. All intermediate results will be in the range of [-2^31, 2^31 - 1].\n\u00a0\nExample 1:\nInput: expression = \"e + 8 - a + 5\", evalvars = [\"e\"], evalints = [1]\nOutput: [\"-1*a\",\"14\"]\n\nExample 2:\nInput: expression = \"e - 8 + temperature - pressure\", evalvars = [\"e\", \"temperature\"], evalints = [1, 12]\nOutput: [\"-1*pressure\",\"5\"]\n\nExample 3:\nInput: expression = \"(e + 8) * (e - 8)\", evalvars = [], evalints = []\nOutput: [\"1*e*e\",\"-64\"]\n\n\u00a0\nConstraints:\n\n1 <= expression.length <= 250\nexpression consists of lowercase English letters, digits, '+', '-', '*', '(', ')', ' '.\nexpression does not contain any leading or trailing spaces.\nAll the tokens in expression are separated by a single space.\n0 <= evalvars.length <= 100\n1 <= evalvars[i].length <= 20\nevalvars[i] consists of lowercase English letters.\nevalints.length == evalvars.length\n-100 <= evalints[i] <= 100\n\n"}, {"role": "assistant", "content": "class term(object):\n    def __init__(self, coef):\n        self.coef = coef\n        self.var = []\n    def __neg__(self):\n        rt = term(-self.coef)\n        rt.var = self.var[:]\n        return rt\n\n    def compareTuple(self):\n        self.var.sort()\n        return (-len(self.var), \"*\".join(self.var))\n    def compareStr(self):\n        self.var.sort()\n        return \"*\".join(self.var)\n    def __str__(self):\n        if not self.var:\n            return str(self.coef)\n        return \"\".join([str(self.coef), \"*\", self.compareStr()])\n\nclass manyTerms(object):\n    def __init__(self, term):\n        self.terms = [term]\n    # def pt(self):\n    #     for t in self.terms:\n    #         print t\n    def result(self):\n        self.terms = [t for t in self.terms if t.coef != 0]\n        self.terms.sort(key = term.compareTuple)\n        return map(str, self.terms)\n\n    def add(self, other):\n        for j in range(len(other.terms)):\n            for i in range(len(self.terms)):\n                if self.terms[i].compareStr() == other.terms[j].compareStr():\n                    self.terms[i].coef += other.terms[j].coef\n                    other.terms[j].coef = 0\n                    break\n        for j in range(len(other.terms)):\n            if other.terms[j].coef != 0:\n                self.terms.append(other.terms[j])\n\n    def minus(self, other):\n        for j in range(len(other.terms)):\n            for i in range(len(self.terms)):\n                if self.terms[i].compareStr() == other.terms[j].compareStr():\n                    self.terms[i].coef -= other.terms[j].coef\n                    other.terms[j].coef = 0\n                    break\n\n        for j in range(len(other.terms)):\n            if other.terms[j].coef != 0:\n                self.terms.append(-other.terms[j])\n    def mul(self, other):\n        ans = manyTerms(term(0))\n        for j in range(len(other.terms)):\n            for i in range(len(self.terms)):\n                newTerm = term(self.terms[i].coef * other.terms[j].coef)\n                newTerm.var = self.terms[i].var + other.terms[j].var\n                ans.add(manyTerms(newTerm))\n        return ans\n\n\n\nclass Solution(object):\n    def basicCalculatorIV(self, expression, evalvars, evalints):\n        \"\"\"\n        :type expression: str\n        :type evalvars: List[str]\n        :type evalints: List[int]\n        :rtype: List[str]\n        \"\"\"\n        self.d = {}\n        for i in range(len(evalvars)):\n            self.d[evalvars[i]] = evalints[i]\n        return self.calcExp(expression).result()\n    def calcExp(self, s):\n        # first deal with ( and ) with stack\n        s = s.strip()\n        # iPlus = s.rfind(\"+\")\n        # iMinus = s.rfind(\"-\")\n        # iMul = s.rfind(\"*\")\n        iPlus = iMinus = iMul = -1\n        level = 0\n        for i in reversed(range(len(s))):\n            if level == 0:\n                if s[i] == \"+\" and iPlus == -1:\n                    iPlus = i\n                if s[i] == \"-\" and iMinus == -1:\n                    iMinus = i\n                if s[i] == \"*\" and iMul == -1:\n                    iMul = i\n            if s[i] == \")\":\n                level += 1\n            if s[i] == \"(\":\n                level -= 1\n\n        if iPlus == -1 and iMinus == -1 and iMul == -1:\n            if s[0] == \"(\":\n                return self.calcExp(s[1:-1])\n            if s in self.d:\n                return manyTerms(term(self.d[s]))\n            if ord(\"a\")<=ord(s[0])<=ord(\"z\"):\n                tempTerm = term(1)\n                tempTerm.var.append(s)\n                return manyTerms(tempTerm)\n            else:\n                return manyTerms(term(int(s)))\n        if iPlus == -1 and iMinus == -1:\n            mx = iMul\n        else:\n            mx = max(iPlus, iMinus)\n        left = self.calcExp(s[:mx])\n        right = self.calcExp(s[mx+1:])\n        if mx == iPlus:\n            left.add(right)\n            return left\n        if mx == iMinus:\n            left.minus(right)\n            return left\n        if mx == iMul:\n            return left.mul(right)\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4252", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 3 that\n\nGiven a string formula representing a chemical formula, return the count of each atom.\nThe atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\nOne or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.\n\nFor example, \"H2O\" and \"H2O2\" are possible, but \"H1O2\" is impossible.\n\nTwo formulas are concatenated together to produce another formula.\n\nFor example, \"H2O2He3Mg4\" is also a formula.\n\nA formula placed in parentheses, and a count (optionally added) is also a formula.\n\nFor example, \"(H2O2)\" and \"(H2O2)3\" are formulas.\n\nReturn the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\nThe test cases are generated so that all the values in the output fit in a 32-bit integer.\n\u00a0\nExample 1:\nInput: formula = \"H2O\"\nOutput: \"H2O\"\nExplanation: The count of elements are {'H': 2, 'O': 1}.\n\nExample 2:\nInput: formula = \"Mg(OH)2\"\nOutput: \"H2MgO2\"\nExplanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\n\nExample 3:\nInput: formula = \"K4(ON(SO3)2)2\"\nOutput: \"K4N2O14S4\"\nExplanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\n\n\u00a0\nConstraints:\n\n1 <= formula.length <= 1000\nformula consists of English letters, digits, '(', and ')'.\nformula is always valid.\n\n"}, {"role": "assistant", "content": "import re\n\n\nclass Solution:\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n\n        def add(a, b):\n            c = {}\n            keys = set(a.keys()) | set(b.keys())\n            for k in keys:\n                c[k] = a.get(k, 0) + b.get(k, 0)\n            return c\n\n        def mul(a, t):\n            return {k: t * v for k, v in a.items()}\n\n        def count(f):\n            if not f:\n                return dict()\n            p = f.find('(')\n            if p == -1:\n                fs = []\n                for s in re.split('([A-Z][a-z]?)', f):\n                    if s:\n                        fs.append(s)\n                ans = {}\n                for i, s in enumerate(fs):\n                    if s[0] in '1234567890':\n                        continue\n                    c = 1\n                    if i + 1 < len(fs) and fs[i + 1][0] in '1234567890':\n                        c = int(fs[i + 1])\n                    ans[s] = ans.get(s, 0) + c\n                return ans\n            c = 1\n            q = p + 1\n            while q < len(f) and c != 0:\n                if f[q] == '(':\n                    c += 1\n                elif f[q] == ')':\n                    c -= 1\n                q += 1\n            f1 = f[:p]\n            f2 = f[p + 1:q - 1]\n            t = 1\n            if q < len(f) and f[q] in '1234567890':\n                c = ''\n                while q < len(f) and f[q] in '1234567890':\n                    c += f[q]\n                    q += 1\n                t = int(c)\n            f3 = f[q:]\n            ans = mul(count(f2), t)\n            ans = add(count(f1), ans)\n            ans = add(count(f3), ans)\n            return ans\n\n        atoms = count(formula)\n        atoms = sorted(atoms.items())\n        ans = ''\n        for k, v in atoms:\n            ans += k\n            if v > 1:\n                ans += str(v)\n        return ans"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4339", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 program that can\n\nYou are given an integer array of unique positive integers nums. Consider the following graph:\n\nThere are nums.length nodes, labeled nums[0] to nums[nums.length - 1],\nThere is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1.\n\nReturn the size of the largest connected component in the graph.\n\u00a0\nExample 1:\n\nInput: nums = [4,6,15,35]\nOutput: 4\n\nExample 2:\n\nInput: nums = [20,50,9,63]\nOutput: 2\n\nExample 3:\n\nInput: nums = [2,3,6,7,4,12,21,39]\nOutput: 8\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 2 * 10000\n1 <= nums[i] <= 100000\nAll the values of nums are unique.\n\n"}, {"role": "assistant", "content": "class UF(object):\n    def __init__(self, nodes):\n        self.idx = {v:i for i,v in enumerate(nodes)}\n        self.parent = range(len(nodes))\n        self.rank = [0] * len(nodes)\n        self.size = [1] * len(nodes)\n    def union(self, node1, node2):\n        i1, i2 = self._find(self.idx[node1]), self._find(self.idx[node2])\n        if i1 == i2: return\n        if self.rank[i1] < self.rank[i2]: i1, i2 = i2, i1\n        # self.rank[i1] >= self.rank[i2]\n        self.parent[i2] = i1\n        self.size[i1] += self.size[i2]\n        if self.rank[i1] == self.rank[i2]:\n            self.rank[i1] += 1\n    def groupsize(self, node):\n        return self.size[self.idx[node]]\n    def _find(self, i):\n        path = []\n        while self.parent[i] != i:\n            path.append(i)\n            i = self.parent[i]\n        for j in path: self.parent[j] = i\n        return i\n        \n        \n\nclass Solution(object):\n    def largestComponentSize(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        m = max(A)\n        primes = [2]\n        def is_prime(x):\n            for p in primes:\n                if p * p > x: return True\n                if x % p == 0: return False\n        for x in xrange(3, m+1, 2):\n            if is_prime(x):\n                primes.append(x)\n            if x * x > m: break\n        def prime_factors(x):\n            r = []\n            for p in primes:\n                if p * p > x: break\n                if x % p == 0:\n                    r.append(p)\n                    while x % p == 0: x //= p\n            if x > 1: r.append(x)\n            return r\n        d = {}\n        uf = UF(A)\n        for v in A:\n            for p in prime_factors(v):\n                d.setdefault(p, []).append(v)\n        for vv in d.itervalues():\n            for i in xrange(len(vv)-1):\n                uf.union(vv[i], vv[i+1])\n        return max(uf.groupsize(node) for node in A)\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4371", "label": "code_high", "messages": [{"role": "user", "content": "Can you write a program in Python 2 where\n\nYou are given an m x n integer array grid where grid[i][j] could be:\n\n1 representing the starting square. There is exactly one starting square.\n2 representing the ending square. There is exactly one ending square.\n0 representing empty squares we can walk over.\n-1 representing obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n\u00a0\nExample 1:\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\nOutput: 2\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\nExample 2:\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\nOutput: 4\nExplanation: We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\nExample 3:\n\nInput: grid = [[0,1],[2,0]]\nOutput: 0\nExplanation: There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 20\n1 <= m * n <= 20\n-1 <= grid[i][j] <= 2\nThere is exactly one starting cell and one ending cell.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def uniquePathsIII(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n, m = len(grid), len(grid[0])\n        start = end = bad = good = s = 0\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                x = m*i + j\n                if v < 0: bad |= 1<<x\n                else: good |= 1<<x; s += 1\n                if v == 1: start = x\n                elif v == 2: end = x\n\n        def neighbors(i, j):\n            if i > 0: yield m*(i-1) + j\n            if i < n-1: yield m*(i+1) + j\n            if j > 0: yield m*i + j-1\n            if j < m-1: yield m*i + j+1\n        t = [[x for x in neighbors(i,j) if not bad & (1<<x)]\n             for i in xrange(n) for j in xrange(m)]\n\n        cache = {}\n        def ways(path, l, x):\n            k = (path,x)\n            if k in cache: return cache[k]\n            if l == 1: return 1 if x == start else 0\n            r = 0\n            path ^= (1<<x)\n            for y in t[x]:\n                if not (1<<y) & path: continue\n                r += ways(path, l-1, y)\n            cache[k] = r\n            return r\n            \n\n        return ways(good, s, end)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4399", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 2 function for\n\nGiven an integer n, find a sequence that satisfies all of the following:\n\nThe integer 1 occurs once in the sequence.\nEach integer between 2 and n occurs twice in the sequence.\nFor every integer i between 2 and n, the distance between the two occurrences of i is exactly i.\n\nThe distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|.\nReturn the lexicographically largest sequence. It is guaranteed that under the given constraints, there is always a solution. \nA sequence a is lexicographically larger than a sequence b (of the same length) if in the first position where a and b differ, sequence a has a number greater than the corresponding number in b. For example, [0,1,9,0] is lexicographically larger than [0,1,5,6] because the first position they differ is at the third number, and 9 is greater than 5.\n\u00a0\nExample 1:\nInput: n = 3\nOutput: [3,1,2,3,2]\nExplanation: [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence.\n\nExample 2:\nInput: n = 5\nOutput: [5,3,1,4,3,5,2,4,2]\n\n\u00a0\nConstraints:\n\n1 <= n <= 20\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def rec(self, a, v, i):\n        # print((a, v, i))\n        if i == len(a):\n            return a\n        if a[i] != 0:\n            while a[i] != 0:\n                i += 1\n                if i == len(a):\n                    return a\n            return self.rec(a, v, i)\n        for j in range(len(v)-1, 0, -1):\n            if not v[j]:\n                if j == 1 or i + j < len(a) and a[i + j] == 0:\n                    v[j] = True\n                    a[i] = j\n                    if j != 1:\n                        a[i + j] = j\n                    rc = self.rec(a, v, i + 1)\n                    if rc != None:\n                        return rc\n                    v[j] = False\n                    a[i] = 0\n                    if j != 1:\n                        a[i + j] = 0\n        return None\n                    \n        \n    def constructDistancedSequence(self, n):\n        v = [False for i in range(n+1)]\n        a = [0 for i in range(2*n-1)]\n        for i in range(n, 0, -1):\n            v[i] = True\n            a[0] = i\n            if i != 1:\n                a[i] = i\n            rc = self.rec(a, v, 1)\n            if rc != None:\n                return rc\n            v[i] = False\n            a[0] = 0\n            a[i] = 0\n        return []"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4429", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 function for\n\nOn an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.\nThe state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].\nGiven the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.\n\u00a0\nExample 1:\n\nInput: board = [[1,2,3],[4,0,5]]\nOutput: 1\nExplanation: Swap the 0 and the 5 in one move.\n\nExample 2:\n\nInput: board = [[1,2,3],[5,4,0]]\nOutput: -1\nExplanation: No number of moves will make the board solved.\n\nExample 3:\n\nInput: board = [[4,1,2],[5,0,3]]\nOutput: 5\nExplanation: 5 is the smallest number of moves that solves the board.\nAn example path:\nAfter move 0: [[4,1,2],[5,0,3]]\nAfter move 1: [[4,1,2],[0,5,3]]\nAfter move 2: [[0,1,2],[4,5,3]]\nAfter move 3: [[1,0,2],[4,5,3]]\nAfter move 4: [[1,2,0],[4,5,3]]\nAfter move 5: [[1,2,3],[4,5,0]]\n\n\u00a0\nConstraints:\n\nboard.length == 2\nboard[i].length == 3\n0 <= board[i][j] <= 5\nEach value board[i][j] is unique.\n\n"}, {"role": "assistant", "content": "class Solution:\n\tdef encode(self, a):\n\t\tret = ''\n\t\tfor i in range(2):\n\t\t\tfor j in range(3):\n\t\t\t\tret += '{}'.format(a[i][j])\n\t\treturn ret\n\n\tdef decode(self, val):\n\t\ta = [[None, None, None], [None, None, None]]\n\t\tt = 0\n\t\tfor i in range(2):\n\t\t\tfor j in range(3):\n\t\t\t\ta[i][j] = int(val[t])\n\t\t\t\tt += 1\n\t\treturn a\n\n\tdef copy(self, val):\n\t\ta = [[None, None, None], [None, None, None]]\n\t\tfor i in range(2):\n\t\t\tfor j in range(3):\n\t\t\t\ta[i][j] = val[i][j]\n\t\treturn a\n\n\tdef slidingPuzzle(self, board):\n\t\t\"\"\"\n\t\t:type board: List[List[int]]\n\t\t:rtype: int\n\t\t\"\"\"\n\t\tstart = self.encode(board)\n\n\t\tdist = {}\n\t\tdist[start] = 0\n\t\timport collections\n\t\tq = collections.deque()\n\t\tq.append(start)\n\t\twhile '123450' not in dist:\n\t\t\tif len(q) == 0:\n\t\t\t\treturn -1\n\t\t\t\t\n\t\t\tidx = q.popleft()\n\t\t\tcur = self.decode(idx)\n\t\t\t\n\t\t\tfor i in range(2):\n\t\t\t\tfor j in range(3):\n\t\t\t\t\tif cur[i][j] == 0:\n\t\t\t\t\t\tx, y = i, j\n\n\t\t\t# print(cur, cur)\n\t\t\tif x > 0:\n\t\t\t\ttmp = self.copy(cur)\n\t\t\t\ttmp[x][y], tmp[x - 1][y] = tmp[x - 1][y], tmp[x][y]\n\t\t\t\t# print(cur, '1', tmp)\n\t\t\t\ttmp = self.encode(tmp)\n\t\t\t\tif tmp not in dist:\n\t\t\t\t\tdist[tmp] = dist[idx] + 1\n\t\t\t\t\tq.append(tmp)\n\t\t\tif x < 1:\n\t\t\t\ttmp = self.copy(cur)\n\t\t\t\ttmp[x][y], tmp[x + 1][y] = tmp[x + 1][y], tmp[x][y]\n\t\t\t\t# print(cur, '2', tmp)\n\t\t\t\ttmp = self.encode(tmp)\n\t\t\t\tif tmp not in dist:\n\t\t\t\t\tdist[tmp] = dist[idx] + 1\n\t\t\t\t\tq.append(tmp)\n\t\t\tif y > 0:\n\t\t\t\ttmp = self.copy(cur)\n\t\t\t\ttmp[x][y], tmp[x][y - 1] = tmp[x][y - 1], tmp[x][y]\n\t\t\t\t# print(cur, '3', tmp)\n\t\t\t\ttmp = self.encode(tmp)\n\t\t\t\tif tmp not in dist:\n\t\t\t\t\tdist[tmp] = dist[idx] + 1\n\t\t\t\t\tq.append(tmp)\n\t\t\tif y < 2:\n\t\t\t\ttmp = self.copy(cur)\n\t\t\t\ttmp[x][y], tmp[x][y + 1] = tmp[x][y + 1], tmp[x][y]\n\t\t\t\t# print(cur, '4', tmp)\n\t\t\t\ttmp = self.encode(tmp)\n\t\t\t\tif tmp not in dist:\n\t\t\t\t\tdist[tmp] = dist[idx] + 1\n\t\t\t\t\tq.append(tmp)\n\n\t\t\t\n\n\n\t\t\t\n\n\t\treturn dist['123450']\n\n\n\n\n\n\n\n\n\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4430", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 2 to\n\nOn an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.\nThe state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].\nGiven the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.\n\u00a0\nExample 1:\n\nInput: board = [[1,2,3],[4,0,5]]\nOutput: 1\nExplanation: Swap the 0 and the 5 in one move.\n\nExample 2:\n\nInput: board = [[1,2,3],[5,4,0]]\nOutput: -1\nExplanation: No number of moves will make the board solved.\n\nExample 3:\n\nInput: board = [[4,1,2],[5,0,3]]\nOutput: 5\nExplanation: 5 is the smallest number of moves that solves the board.\nAn example path:\nAfter move 0: [[4,1,2],[5,0,3]]\nAfter move 1: [[4,1,2],[0,5,3]]\nAfter move 2: [[0,1,2],[4,5,3]]\nAfter move 3: [[1,0,2],[4,5,3]]\nAfter move 4: [[1,2,0],[4,5,3]]\nAfter move 5: [[1,2,3],[4,5,0]]\n\n\u00a0\nConstraints:\n\nboard.length == 2\nboard[i].length == 3\n0 <= board[i][j] <= 5\nEach value board[i][j] is unique.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        start = tuple(i for j in board for i in j)\n        end = (1,2,3,4,5,0)\n        if start == end:\n            return 0\n        visited = set()\n        visited.add(start)\n        toDo = [start]\n        result = 1\n        \n        while toDo:\n            newTo = []\n            for td in toDo:\n                id0 = td.index(0)\n                if id0 == 0:\n                    temp = (td[3],td[1],td[2],td[0],td[4],td[5])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                    temp = (td[1],td[0],td[2],td[3],td[4],td[5])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                elif id0 == 1:\n                    temp = (td[0],td[4],td[2],td[3],td[1],td[5])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                    temp = (td[1],td[0],td[2],td[3],td[4],td[5])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                    temp = (td[0],td[2],td[1],td[3],td[4],td[5])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                elif id0 == 2:\n                    temp = (td[0],td[1],td[5],td[3],td[4],td[2])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                    temp = (td[0],td[2],td[1],td[3],td[4],td[5])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                elif id0 == 3:\n                    temp = (td[3],td[1],td[2],td[0],td[4],td[5])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                    temp = (td[0],td[1],td[2],td[4],td[3],td[5])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                elif id0 == 4:\n                    temp = (td[0],td[4],td[2],td[3],td[1],td[5])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                    temp = (td[0],td[1],td[2],td[4],td[3],td[5])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                    temp = (td[0],td[1],td[2],td[3],td[5],td[4])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                else:\n                    temp = (td[0],td[1],td[5],td[3],td[4],td[2])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n                    temp = (td[0],td[1],td[2],td[3],td[5],td[4])\n                    if temp not in visited:\n                        if temp == end:\n                            return result\n                        visited.add(temp)\n                        newTo.append(temp)\n            toDo = newTo\n            result += 1          \n            \n        return -1"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4454", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 script for\n\nYou are given several boxes with different colors represented by different positive numbers.\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k >= 1), remove them and get k * k points.\nReturn the maximum points you can get.\n\u00a0\nExample 1:\nInput: boxes = [1,3,2,2,2,3,4,3,1]\nOutput: 23\nExplanation:\n[1, 3, 2, 2, 2, 3, 4, 3, 1] \n----> [1, 3, 3, 4, 3, 1] (3*3=9 points) \n----> [1, 3, 3, 3, 1] (1*1=1 points) \n----> [1, 1] (3*3=9 points) \n----> [] (2*2=4 points)\n\nExample 2:\nInput: boxes = [1,1,1]\nOutput: 9\n\nExample 3:\nInput: boxes = [1]\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= boxes.length <= 100\n1 <= boxes[i]\u00a0<= 100\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def removeBoxes(self, A):\n        \n        sqmemo = {}\n        def sq(x):\n            #best way to have a_i sum to x maximizing a_i ** 2\n            if x < 2: return x\n            if x == 2: return 4\n            if x in sqmemo: return sqmemo[x]\n            ans = x*x\n            for y in xrange(1, x):\n                ans = max(ans, y*y + sq(x-y) )\n            sqmemo[x] = ans\n            return ans\n            \n        from itertools import groupby, combinations\n        N = len(A)\n        memo = {(i,i): 1 for i in xrange(N)}\n        for i in xrange(N):\n            memo[i+1,i] = 0\n            if i < N-1:\n                memo[i,i+1] = 2 if A[i] != A[i+1] else 4\n                \n        def dp(i, j):\n            if i>j: return 0\n            if (i,j) in memo:\n                return memo[i,j]\n            #value of A[i:j+1]\n            \n            \"\"\"\n            ans = max(dp(i,m) + dp(m+1,j) for m in xrange(i, j))\n            buf = []\n            sumup = count = 0\n            if A[i] == A[j]:\n                #develop answer involving removing all non A[i]'s\n                for m in xrange(i, j+1):\n                    if A[i] == A[m]: \n                        count += 1\n                        if buf:\n                            sumup += dp(buf[0], buf[-1])\n                            buf =[]\n                    else:\n                        buf.append(m)\n            if buf:\n                sumup += dp(buf[0], buf[-1])\n            ans = max(ans, sumup + sq(count))\n            \"\"\"\n                        \n            \"\"\"\n            k = i\n            while k+1 <= j and A[k+1] == A[i]: k += 1\n            ans = (k-i+1)**2 + dp(k+1, j)\n            \"\"\"\n            #What is last m so that i-m get popped together?\n            \"\"\"\n            ans = 0\n            count = 1\n            buf = []\n            sumup = 0\n            for m in xrange(i+1, j+1):\n                if A[m] == A[i]:\n                    count += 1\n                    if buf:\n                        sumup += dp(buf[0], buf[-1])\n                        buf = []\n                    ans = max(ans, sq(count) + sumup + dp(m+1, j))\n                else:\n                    buf.append(m)\n                    ans = max(ans, sq(count) + sumup + dp(buf[0], buf[-1]) + dp(m+1, j))\n            \"\"\"\n            \n            def outranges(grps, i, j):\n                prev = i\n                for gr in grps:\n                    g0, g1 = gr[0], gr[-1]\n                    yield prev, g0 - 1\n                    prev = g1 + 1\n                yield prev, j\n            good = []\n            bad = []\n            for k,v in groupby(range(i, j+1), key=lambda x: A[x] == A[i]):\n                if k:\n                    good.append(list(v))\n                else:\n                    bad.append(list(v))\n                    \n            #Let's choose a subset of good groups\n            G = len(good)\n            ans = 0\n            for size in xrange(1, G+1):\n                for cand in combinations(good, size):\n                    candsum = 0\n                    for l, r in outranges(cand, i, j):\n                        candsum += dp(l, r)\n                    ans = max(ans, sum( g[-1] - g[0] + 1 for g in cand )**2 + candsum )\n                    \n            \"\"\"\n            good = good[::-1]\n            bad = bad[::-1]\n            ans = -1\n            count = sumup = 0\n            while good and bad:\n                goodn = good.pop()\n                badn = bad.pop()\n                g0,g1 = goodn[0], goodn[-1]\n                b0,b1 = badn[0], badn[-1]\n                for i in xrange(1, g1-g0+2):\n                    count += 1\n                    ans = max(ans, sq(count) + sumup + dp(g0 + i, j))\n                #count += g1 - g0 + 1\n                \n                sumup += dp(b0, b1)\n                ans = max(ans, sq(count) + sumup + dp(b1 + 1, j))\n            if good:\n                goodn = good.pop()\n                #badn = bad.pop()\n                g0,g1 = goodn[0], goodn[-1]\n                #b0,b1 = badn[0], badn[-1]\n                for i in xrange(1, g1-g0+2):\n                    count += 1\n                    ans = max(ans, sq(count) + sumup + dp(g0 + i, j))\n            \"\"\"\n            #assert(not good and not bad)\n            \"\"\"\n            count = k-i+1\n            bad = []\n            buf = []\n            sumup = 0\n            for m in xrange(k+1, j+1):\n                if A[i] == A[m]:\n                    count += 1\n                    if buf:\n                        bad.append([buf[0], buf[-1]])\n                        sumup += dp(buf[0], buf[-1])\n                        buf = []\n                    \n                else:\n                    buf.append(m)\n                ans = max(ans, count**2 + sumup + dp(m+1, j) )\n            \"\"\"\n            memo[i,j] = ans\n            return ans\n        for z in xrange(N):\n            for i in xrange(N-z):\n                _ = dp(i, i+z)\n        return dp(0, len(A)-1)"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4457", "label": "code_high", "messages": [{"role": "user", "content": "Can you create a Python 3 program that\n\nA confusing number is a number that when rotated 180 degrees becomes a different number with each digit valid.\n\nWe can rotate digits of a number by 180 degrees to form new digits.\n\nWhen 0, 1, 6, 8, and 9 are rotated 180 degrees, they become 0, 1, 9, 8, and 6 respectively.\nWhen 2, 3, 4, 5, and 7 are rotated 180 degrees, they become invalid.\n\nNote that after rotating a number, we can ignore leading zeros.\n\nFor example, after rotating 8000, we have 0008 which is considered as just 8.\n\nGiven an integer n, return the number of confusing numbers in the inclusive range [1, n].\n\n \n\nExample 1:\n\nInput: n = 20\nOutput: 6\nExplanation: The confusing numbers are [6,9,10,16,18,19].\n6 converts to 9.\n9 converts to 6.\n10 converts to 01 which is just 1.\n16 converts to 91.\n18 converts to 81.\n19 converts to 61.\n\nExample 2:\n\nInput: n = 100\nOutput: 19\nExplanation: The confusing numbers are [6,9,10,16,18,19,60,61,66,68,80,81,86,89,90,91,98,99,100].\n\n \n\nConstraints:\n\n1 <= n <= 10^9\n\n"}, {"role": "assistant", "content": "class Solution:\n    def countReversableForLength(self, length: int) -> int:\n        return 4 * 5**(length - 1);\n    \n    def foobar(self, i: int, c: str) -> int:\n        res = 1 if i > 0 else 0\n        if c == '7':\n            return res + 2\n        return res + 1\n    \n    def skidiki(self, i: int, c: str) -> int:\n        if c == '0':\n            return 0\n        res = 1 if i > 0 else 0\n        if c == '1':\n            return res\n        if c == '6':\n            return res + 1\n        if c == '8':\n            return res + 2\n        if c == '9':\n            return res + 3\n        \n    def check(self, s: int) -> bool:\n        for c in str(s):\n            if c in '23457':\n                return False\n        return True\n    \n    def countReversable(self, N: int) -> int:\n        s = str(N)\n        ans = 0\n        for i in range(1, len(s)):\n            ans += self.countReversableForLength(i)\n        for i, c in enumerate(s):\n            if c in '23457':\n                ans += self.foobar(i, c) * 5**(len(s) - i - 1)\n                return ans\n            else:\n                ans += self.skidiki(i, c) * 5**(len(s) - i - 1)\n        return ans + 1\n    \n    def inverse(self, c: str) -> str:\n        if c == '0':\n            return '0'\n        if c == '1':\n            return '1'\n        if c == '6':\n            return '9'\n        if c == '8':\n            return '8'\n        if c == '9':\n            return '6'\n    \n    def reverse(self, x: int) -> str:\n        s = str(x)\n        for c in s:\n            if c not in \"01689\":\n                return None\n        s = s[::-1]\n        return ''.join([self.inverse(c) for c in s])\n    \n    def confusingNumberII(self, N: int) -> int:\n        ans = self.countReversable(N)\n        \n        if N >= 1:\n            ans -= 1\n        \n        if N >= 8:\n            ans -= 1\n            \n        i = 1\n        while True:\n            s = self.reverse(i)\n            if not s:\n                i += 1\n                continue\n            x = int(str(i) + s)\n            if x <= N:\n                ans -= 1\n            else:\n                break\n            i += 1\n        \n        i = 1\n        while True:\n            s = self.reverse(i)\n            if not s:\n                i += 1\n                continue\n            x = int(str(i) + '0' + self.reverse(i))\n            y = int(str(i) + '1' + self.reverse(i))\n            z = int(str(i) + '8' + self.reverse(i))\n            if x <= N:\n                ans -= 1\n            if y <= N:\n                ans -= 1\n            if z <= N:\n                ans -= 1\n            if x > N and y > N and x > N:\n                break\n            i += 1\n            \n        return ans\n        \n        \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4464", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 3 program that can\n\nGiven a m x n matrix mat and an integer threshold, return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square.\n\u00a0\nExample 1:\n\nInput: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\nOutput: 2\nExplanation: The maximum side length of square with sum less than 4 is 2 as shown.\n\nExample 2:\nInput: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\nOutput: 0\n\n\u00a0\nConstraints:\n\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 300\n0 <= mat[i][j] <= 10000\n0 <= threshold <= 100000\n\n"}, {"role": "assistant", "content": "class Solution:\n    def maxSideLength(self, matrix: List[List[int]], threshold: int) -> int:\n        n = len(matrix)\n        m = len(matrix[0])\n        mat = [[0] * (m + 1) for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                mat[i][j] = matrix[i - 1][j - 1]\n                if i > 0:\n                    mat[i][j] += mat[i - 1][j]\n                if j > 0:\n                    mat[i][j] += mat[i][j - 1]\n                if i > 0 and j > 0:\n                    mat[i][j] -= mat[i - 1][j - 1]\n        \n        def check(i, j, l):\n            if i + l - 1 > n:\n                return False\n            if j + l - 1 > m:\n                return False\n            return mat[i + l - 1][j + l - 1] - mat[i - 1][j + l - 1] - mat[i + l - 1][j - 1] + mat[i - 1][j - 1] <= threshold\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        res = 0\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if matrix[i - 1][j - 1] > threshold:\n                    dp[i][j] = 0\n                    continue\n                l = max(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1], 3) - 1\n                while check(i, j, l):\n                    l += 1\n                dp[i][j] = l - 1\n                res = max(res, dp[i][j])\n        \n        return res\n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4494", "label": "code_high", "messages": [{"role": "user", "content": "Create a Python 2 function for\n\nYou are given an array nums consisting of positive integers and an integer k.\nPartition the array into two ordered groups such that each element is in exactly one group. A partition is called great if the sum of elements of each group is greater than or equal to k.\nReturn the number of distinct great partitions. Since the answer may be too large, return it modulo 10^9 + 7.\nTwo partitions are considered distinct if some element nums[i] is in different groups in the two partitions.\n\u00a0\nExample 1:\nInput: nums = [1,2,3,4], k = 4\nOutput: 6\nExplanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]).\n\nExample 2:\nInput: nums = [3,3,3], k = 4\nOutput: 0\nExplanation: There are no great partitions for this array.\n\nExample 3:\nInput: nums = [6,6], k = 2\nOutput: 2\nExplanation: We can either put nums[0] in the first partition or in the second partition.\nThe great partitions will be ([6], [6]) and ([6], [6]).\n\n\u00a0\nConstraints:\n\n1 <= nums.length, k <= 1000\n1 <= nums[i] <= 10^9\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def countPartitions(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def i():\n            c, s, t = 0, 0, 0\n            for i in nums:\n                c, s, t = c if i < k else c + 1, s + i if i < k else s, t + i\n            if c or min(3 * k, t - k) < k:\n                return c < 2 and s < k or not c\n            d = [[True] + [False] * min(3 * k, t - k) for _ in range(len(nums) + 1)]\n            for i in range(1, len(nums) + 1):\n                for j in range(1, min(3 * k, t - k) + 1):\n                    d[i][j] = j - nums[i - 1] >= 0 and d[i - 1][j - nums[i - 1]] or d[i - 1][j]\n            for i in range(k, min(3 * k, t - k) + 1):\n                if d[len(nums)][i]:\n                    return False\n            return True\n        if i():\n            return 0\n        d, a = [[1] + [0] * k for _ in range(len(nums) + 1)], 0\n        for i in range(1, len(nums) + 1):\n            for j in range(1, k + 1):\n                d[i][j] = ((d[i - 1][j - nums[i - 1]] if j - nums[i - 1] >= 0 else 0) + d[i - 1][j]) % 1000000007\n            for j in range(max(0, k - nums[i - 1] + 1), k + 1):\n                d[i][k] = (d[i][k] + d[i - 1][j]) % 1000000007\n        for i in range(k):\n            a = (a + d[len(nums)][i]) % 1000000007\n        return (d[len(nums)][k] - a + 1000000007) % 1000000007"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4508", "label": "code_high", "messages": [{"role": "user", "content": "Can you write a program in Python 2 where\n\nYou are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to numSlots.\nYou have to place all n integers into the slots such that each slot contains at most two numbers. The AND sum of a given placement is the sum of the bitwise AND of every number with its respective slot number.\n\nFor example, the AND sum of placing the numbers [1, 3] into slot 1 and [4, 6] into slot 2 is equal to (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4.\n\nReturn the maximum possible AND sum of nums given numSlots slots.\n\u00a0\nExample 1:\nInput: nums = [1,2,3,4,5,6], numSlots = 3\nOutput: 9\nExplanation: One possible placement is [1, 4] into slot 1, [2, 6] into slot 2, and [3, 5] into slot 3. \nThis gives the maximum AND sum of (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9.\n\nExample 2:\nInput: nums = [1,3,10,4,7,1], numSlots = 9\nOutput: 24\nExplanation: One possible placement is [1, 1] into slot 1, [3] into slot 3, [4] into slot 4, [7] into slot 7, and [10] into slot 9.\nThis gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24.\nNote that slots 2, 5, 6, and 8 are empty which is permitted.\n\n\u00a0\nConstraints:\n\nn == nums.length\n1 <= numSlots <= 9\n1 <= n <= 2 * numSlots\n1 <= nums[i] <= 15\n\n"}, {"role": "assistant", "content": "from collections import Counter\nfrom itertools import combinations\nclass Solution(object):\n    def maximumANDSum(self, nums, numSlots):\n        \"\"\"\n        :type nums: List[int]\n        :type numSlots: int\n        :rtype: int\n        \"\"\"\n        slots = range(1, numSlots+1) * 2\n        nums += [0]*(len(slots)-len(nums))\n        cost = [[-(x&y) for y in slots] for x in nums]\n        return -hungarian(cost)[0]\n\n\ndef hungarian(orig_cost):\n    n = len(orig_cost)\n    assert all(len(row) == n for row in orig_cost)\n    cost = map(list, orig_cost)\n    for x in xrange(n):\n        min_cost = min(cost[x])\n        for y in xrange(n):\n            cost[x][y] -= min_cost\n    for y in xrange(n):\n        min_cost = min(cost[x][y] for x in xrange(n))\n        for x in xrange(n):\n            cost[x][y] -= min_cost\n\n    match_x = [-1]*n\n    match_y = [-1]*n\n    label_x = [0]*n\n    label_y = [0]*n\n    minx_slack_y = [0]*n\n    min_slack_y = [0]*n\n    seen_x = [False]*n\n    prev_y = [0]*n\n\n    def _augment(x):\n        for i in xrange(n):\n            seen_x[i] = False\n            prev_y[i] = -1\n        seen_x[x] = True\n        for y in xrange(n):\n            min_slack_y[y] = cost[x][y] - label_x[x] - label_y[y]\n            minx_slack_y[y] = x\n        while True:\n            min_slack = float('inf')\n            min_x = -1\n            min_y = -1\n            for y in xrange(n):\n                if prev_y[y] == -1 and min_slack_y[y] < min_slack:\n                    min_slack = min_slack_y[y]\n                    min_x = minx_slack_y[y]\n                    min_y = y\n            if min_slack > 0:\n                for x in xrange(n):\n                    if seen_x[x]:\n                        label_x[x] += min_slack\n                for y in xrange(n):\n                    if prev_y[y] == -1:\n                        min_slack_y[y] -= min_slack\n                    else:\n                        label_y[y] -= min_slack\n            prev_y[min_y] = min_x\n            if match_y[min_y] == -1:\n                y = min_y\n                while True:\n                    x = prev_y[y]\n                    nxt = match_x[x]\n                    match_x[x] = y\n                    match_y[y] = x\n                    y = nxt\n                    if y == -1:\n                        break\n                return\n            x = match_y[min_y]\n            seen_x[x] = True\n            for y in xrange(n):\n                if prev_y[y] == -1:\n                    slack = cost[x][y] - label_x[x] - label_y[y]\n                    if min_slack_y[y] > slack:\n                        min_slack_y[y] = slack\n                        minx_slack_y[y] = x\n\n    # greedy initial match\n    for x in xrange(n):\n        for y in xrange(n):\n            if match_x[x] == -1 and match_y[y] == -1 and cost[x][y] == label_x[x] + label_y[y]:\n                match_x[x] = y\n                match_y[y] = x\n\n    # augment loop\n    while True:\n        for x in xrange(n):\n            if match_x[x] == -1:\n                _augment(x)\n                break\n        else:\n            break\n\n    # compute best cost\n    best_cost = sum(orig_cost[x][match_x[x]] for x in xrange(n))\n    return best_cost, match_x\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4548", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 3 to\n\nYou are given an array pairs, where pairs[i] = [xi, yi], and:\n\nThere are no duplicates.\nxi < yi\n\nLet ways be the number of rooted trees that satisfy the following conditions:\n\nThe tree consists of nodes whose values appeared in pairs.\nA pair [xi, yi] exists in pairs if and only if xi is an ancestor of yi or yi is an ancestor of xi.\nNote: the tree does not have to be a binary tree.\n\nTwo ways are considered to be different if there is at least one node that has different parents in both ways.\nReturn:\n\n0 if ways == 0\n1 if ways == 1\n2 if ways > 1\n\nA rooted tree is a tree that has a single root node, and all edges are oriented to be outgoing from the root.\nAn ancestor of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.\n\u00a0\nExample 1:\n\nInput: pairs = [[1,2],[2,3]]\nOutput: 1\nExplanation: There is exactly one valid rooted tree, which is shown in the above figure.\n\nExample 2:\n\nInput: pairs = [[1,2],[2,3],[1,3]]\nOutput: 2\nExplanation: There are multiple valid rooted trees. Three of them are shown in the above figures.\n\nExample 3:\nInput: pairs = [[1,2],[2,3],[2,4],[1,5]]\nOutput: 0\nExplanation: There are no valid rooted trees.\n\u00a0\nConstraints:\n\n1 <= pairs.length <= 100000\n1 <= xi < yi <= 500\nThe elements in pairs are unique.\n\n"}, {"role": "assistant", "content": "class Solution:\n    def checkWays(self, pairs: List[List[int]]) -> int:\n        n = 0\n        a = set()\n        for x in pairs:\n            n = max(n, x[0], x[1])\n            a.add(x[0])\n            a.add(x[1])\n        d = [0] * (n + 1)\n        e = [[] for _ in range(n + 1)]\n        for x in pairs:\n            d[x[0]] += 1\n            d[x[1]] += 1\n            e[x[0]].append(x[1])\n            e[x[1]].append(x[0])\n\n        roots = set()\n        a = list(a)\n\n        def work(a):\n            if len(a) == 1:\n                return 1\n            c = 0\n            o = -1\n            for x in a:\n                if d[x] == len(a) - 1 + len(roots):\n                    c += 1\n                    o = x\n            if c == 0:\n                return 0\n            roots.add(o)\n            f = set()\n            aa = []\n            for x in a:\n                if x not in roots and x not in f:\n                    q = [x]\n                    f.add(x)\n                    t = 0\n                    while t < len(q):\n                        y = q[t]\n                        t += 1\n                        for z in e[y]:\n                            if z not in roots and z not in f:\n                                q.append(z)\n                                f.add(z)\n                    aa.append(q)\n            for b in aa:\n                r = work(b)\n                if r == 0:\n                    return 0\n                c = max(r, c)\n            roots.remove(o)\n            return c\n\n        r = work(a)\n        if r > 1:\n            return 2\n        return r"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4586", "label": "code_high", "messages": [{"role": "user", "content": "How would you code a program in Python 3 to\n\nAlice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAlice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:\n\nChooses two distinct integers u and v such that there exists an edge [u, v] in the tree.\nHe tells Alice that u is the parent of v in the tree.\n\nBob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.\nAlice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.\nGiven the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.\n\u00a0\nExample 1:\n\nInput: edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3\nOutput: 3\nExplanation: \nRoot = 0, correct guesses = [1,3], [0,1], [2,4]\nRoot = 1, correct guesses = [1,3], [1,0], [2,4]\nRoot = 2, correct guesses = [1,3], [1,0], [2,4]\nRoot = 3, correct guesses = [1,0], [2,4]\nRoot = 4, correct guesses = [1,3], [1,0]\nConsidering 0, 1, or 2 as root node leads to 3 correct guesses.\n\n\nExample 2:\n\nInput: edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1\nOutput: 5\nExplanation: \nRoot = 0, correct guesses = [3,4]\nRoot = 1, correct guesses = [1,0], [3,4]\nRoot = 2, correct guesses = [1,0], [2,1], [3,4]\nRoot = 3, correct guesses = [1,0], [2,1], [3,2], [3,4]\nRoot = 4, correct guesses = [1,0], [2,1], [3,2]\nConsidering any node as root will give at least 1 correct guess. \n\n\n\u00a0\nConstraints:\n\nedges.length == n - 1\n2 <= n <= 100000\n1 <= guesses.length <= 100000\n0 <= ai, bi, uj, vj <= n - 1\nai != bi\nuj != vj\nedges represents a valid tree.\nguesses[j] is an edge of the tree.\nguesses is unique.\n0 <= k <= guesses.length\n\n"}, {"role": "assistant", "content": "from typing import Callable, Generic, List, TypeVar, Optional\n\n\nMOD = int(1e9 + 7)\nINF = int(1e20)\n\n# Alice \u6709\u4e00\u68f5 n \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u8282\u70b9\u7f16\u53f7\u4e3a 0 \u5230 n - 1 \u3002\u6811\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a n - 1 \u7684\u4e8c\u7ef4\u6574\u6570\u6570\u7ec4 edges \u8868\u793a\uff0c\u5176\u4e2d edges[i] = [ai, bi] \uff0c\u8868\u793a\u6811\u4e2d\u8282\u70b9 ai \u548c bi \u4e4b\u95f4\u6709\u4e00\u6761\u8fb9\u3002\n\n# Alice \u60f3\u8981 Bob \u627e\u5230\u8fd9\u68f5\u6811\u7684\u6839\u3002\u5979\u5141\u8bb8 Bob \u5bf9\u8fd9\u68f5\u6811\u8fdb\u884c\u82e5\u5e72\u6b21 \u731c\u6d4b \u3002\u6bcf\u4e00\u6b21\u731c\u6d4b\uff0cBob \u505a\u5982\u4e0b\u4e8b\u60c5\uff1a\n\n# \u9009\u62e9\u4e24\u4e2a \u4e0d\u76f8\u7b49 \u7684\u6574\u6570 u \u548c v \uff0c\u4e14\u6811\u4e2d\u5fc5\u987b\u5b58\u5728\u8fb9 [u, v] \u3002\n# Bob \u731c\u6d4b\u6811\u4e2d u \u662f v \u7684 \u7236\u8282\u70b9 \u3002\n# Bob \u7684\u731c\u6d4b\u7528\u4e8c\u7ef4\u6574\u6570\u6570\u7ec4 guesses \u8868\u793a\uff0c\u5176\u4e2d guesses[j] = [uj, vj] \u8868\u793a Bob \u731c uj \u662f vj \u7684\u7236\u8282\u70b9\u3002\n\n# Alice \u975e\u5e38\u61d2\uff0c\u5979\u4e0d\u60f3\u9010\u4e2a\u56de\u7b54 Bob \u7684\u731c\u6d4b\uff0c\u53ea\u544a\u8bc9 Bob \u8fd9\u4e9b\u731c\u6d4b\u91cc\u9762 \u81f3\u5c11 \u6709 k \u4e2a\u731c\u6d4b\u7684\u7ed3\u679c\u4e3a true \u3002\n\n# \u7ed9\u4f60\u4e8c\u7ef4\u6574\u6570\u6570\u7ec4 edges \uff0cBob \u7684\u6240\u6709\u731c\u6d4b\u548c\u6574\u6570 k \uff0c\u8bf7\u4f60\u8fd4\u56de\u53ef\u80fd\u6210\u4e3a\u6811\u6839\u7684 \u8282\u70b9\u6570\u76ee \u3002\u5982\u679c\u6ca1\u6709\u8fd9\u6837\u7684\u6811\uff0c\u5219\u8fd4\u56de 0\u3002\n\n\nT = TypeVar(\"T\")\n\n\nclass Rerooting(Generic[T]):\n\n    __slots__ = (\"adjList\", \"_n\", \"_decrement\")\n\n    def __init__(self, n: int, decrement: int = 0):\n        self.adjList = [[] for _ in range(n)]\n        self._n = n\n        self._decrement = decrement\n\n    def addEdge(self, u: int, v: int) -> None:\n        u -= self._decrement\n        v -= self._decrement\n        self.adjList[u].append(v)\n        self.adjList[v].append(u)\n\n    def rerooting(\n        self,\n        e: Callable[[int], T],\n        op: Callable[[T, T], T],\n        composition: Callable[[T, int, int, int], T],\n        root=0,\n    ) -> List[\"T\"]:\n        root -= self._decrement\n        assert 0 <= root < self._n\n        parents = [-1] * self._n\n        order = [root]\n        stack = [root]\n        while stack:\n            cur = stack.pop()\n            for next in self.adjList[cur]:\n                if next == parents[cur]:\n                    continue\n                parents[next] = cur\n                order.append(next)\n                stack.append(next)\n\n        dp1 = [e(i) for i in range(self._n)]\n        dp2 = [e(i) for i in range(self._n)]\n        for cur in order[::-1]:\n            res = e(cur)\n            for next in self.adjList[cur]:\n                if parents[cur] == next:\n                    continue\n                dp2[next] = res\n                res = op(res, composition(dp1[next], cur, next, 0))\n            res = e(cur)\n            for next in self.adjList[cur][::-1]:\n                if parents[cur] == next:\n                    continue\n                dp2[next] = op(res, dp2[next])\n                res = op(res, composition(dp1[next], cur, next, 0))\n            dp1[cur] = res\n\n        for newRoot in order[1:]:\n            parent = parents[newRoot]\n            dp2[newRoot] = composition(op(dp2[newRoot], dp2[parent]), parent, newRoot, 1)\n            dp1[newRoot] = op(dp1[newRoot], dp2[newRoot])\n        return dp1\n\n\nclass Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n        def e(root: int) -> int:\n            return 0\n\n        def op(childRes1: int, childRes2: int) -> int:\n            return childRes1 + childRes2\n\n        def composition(fromRes: int, parent: int, cur: int, direction: int) -> int:\n            if direction == 0:  # cur -> parent\n                return fromRes + int((parent, cur) in ok)\n            return fromRes + int((cur, parent) in ok)\n\n        ok = set(tuple(x) for x in guesses)\n        n = len(edges) + 1\n        R = Rerooting(n)\n        for u, v in edges:\n            R.addEdge(u, v)\n        res = R.rerooting(e, op, composition)\n        return sum(x >= k for x in res)\n"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4592", "label": "code_high", "messages": [{"role": "user", "content": "Write a Python 2 function for\n\nGiven a m\u00a0* n\u00a0matrix seats\u00a0\u00a0that represent seats distributions\u00a0in a classroom.\u00a0If a seat\u00a0is\u00a0broken, it is denoted by '#' character otherwise it is denoted by a '.' character.\nStudents can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting\u00a0directly in front or behind him. Return the maximum number of students that can take the exam together\u00a0without any cheating being possible..\nStudents must be placed in seats in good condition.\n\u00a0\nExample 1:\n\nInput: seats = [[\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n\u00a0               [\".\",\"#\",\"#\",\"#\",\"#\",\".\"],\n\u00a0               [\"#\",\".\",\"#\",\"#\",\".\",\"#\"]]\nOutput: 4\nExplanation: Teacher can place 4 students in available seats so they don't cheat on the exam. \n\nExample 2:\nInput: seats = [[\".\",\"#\"],\n\u00a0               [\"#\",\"#\"],\n\u00a0               [\"#\",\".\"],\n\u00a0               [\"#\",\"#\"],\n\u00a0               [\".\",\"#\"]]\nOutput: 3\nExplanation: Place all students in available seats. \n\n\nExample 3:\nInput: seats = [[\"#\",\".\",\".\",\".\",\"#\"],\n\u00a0               [\".\",\"#\",\".\",\"#\",\".\"],\n\u00a0               [\".\",\".\",\"#\",\".\",\".\"],\n\u00a0               [\".\",\"#\",\".\",\"#\",\".\"],\n\u00a0               [\"#\",\".\",\".\",\".\",\"#\"]]\nOutput: 10\nExplanation: Place students in available seats in column 1, 3 and 5.\n\n\u00a0\nConstraints:\n\nseats\u00a0contains only characters\u00a0'.'\u00a0and'#'.\nm ==\u00a0seats.length\nn ==\u00a0seats[i].length\n1 <= m <= 8\n1 <= n <= 8\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def maxStudents(self, A):\n        R, C = len(A), len(A[0])\n        for r, row in enumerate(A):\n            for c, val in enumerate(row):\n                if val == '.':\n                    A[r][c] = True\n                else:\n                    A[r][c] = False\n        \n        # dp on state transitions\n        legal = [[] for _ in xrange(R)]\n        for cand in itertools.product((0, 1), repeat=C):\n            if any(cand[i] and cand[i+1] for i in xrange(C-1)):\n                continue\n            for r in xrange(R):\n                if any(cand[i] and not A[r][i] for i in xrange(C)):\n                    continue\n                legal[r].append(cand)\n        \n        dp = {}\n        for cand in legal[0]:\n            dp[cand] = sum(cand)\n        \n        for r in xrange(1, R):\n            dp2 = {}\n            for cand, s in dp.items():\n                for cand2 in legal[r]:\n                    s2 = sum(cand2)\n                    v2 = dp2.get(cand2, -1)\n                    if v2 >= s+s2: continue\n                    for i in xrange(C):\n                        if cand[i]:\n                            if i-1>=0 and cand2[i-1] or i+1<C and cand2[i+1]:\n                                break\n                    else:\n                        dp2[cand2] = s2 + s\n                \n            dp = dp2\n        \n        return max(dp.values())"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4610", "label": "code_high", "messages": [{"role": "user", "content": "Can you implement a function in Python 3 that\n\nYou are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied).\nYou are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements:\n\nCover all the empty cells.\nDo not cover any of the occupied cells.\nWe can put as many stamps as we want.\nStamps can overlap with each other.\nStamps are not allowed to be rotated.\nStamps must stay completely inside the grid.\n\nReturn true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false.\n\u00a0\nExample 1:\n\nInput: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\nOutput: true\nExplanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.\n\nExample 2:\n\nInput: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \nOutput: false \nExplanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[r].length\n1 <= m, n <= 100000\n1 <= m * n <= 2 * 100000\ngrid[r][c] is either 0 or 1.\n1 <= stampHeight, stampWidth <= 100000\n\n"}, {"role": "assistant", "content": "class Solution:\n    def possibleToStamp(self, grid: List[List[int]], p: int, q: int) -> bool:\n        r, c = len(grid), len(grid[0])\n        psa = [[0]*(c+1) for i in range(r+1)]\n        for i in range(r):\n            for j in range(c):\n                psa[i+1][j+1] = psa[i][j+1]+psa[i+1][j]-psa[i][j]+grid[i][j]\n        dif = [[0]*(c+1) for i in range(r+1)]\n        for i in range(r-p+1):\n            for j in range(c-q+1):\n                rect = psa[i+p][j+q]-psa[i][j+q]-psa[i+p][j]+psa[i][j]\n                if rect == 0:\n                    #print('test', i, j)\n                    dif[i][j] += 1\n                    dif[i+p][j] -= 1\n                    dif[i][j+q] -= 1\n                    dif[i+p][j+q] +=1\n  \n        for i in range(r+1):\n            for j in range(c):\n                dif[i][j+1] += dif[i][j]\n        for j in range(c+1):\n            for i in range(r):\n                dif[i+1][j] += dif[i][j]\n        for i in range(r):\n            for j in range(c):\n                if grid[i][j]+dif[i][j]== 0:\n                    return False\n        return True"}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4612", "label": "code_high", "messages": [{"role": "user", "content": "Implement a function in Python 2 to\n\nYou are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied).\nYou are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements:\n\nCover all the empty cells.\nDo not cover any of the occupied cells.\nWe can put as many stamps as we want.\nStamps can overlap with each other.\nStamps are not allowed to be rotated.\nStamps must stay completely inside the grid.\n\nReturn true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false.\n\u00a0\nExample 1:\n\nInput: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\nOutput: true\nExplanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.\n\nExample 2:\n\nInput: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \nOutput: false \nExplanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.\n\n\u00a0\nConstraints:\n\nm == grid.length\nn == grid[r].length\n1 <= m, n <= 100000\n1 <= m * n <= 2 * 100000\ngrid[r][c] is either 0 or 1.\n1 <= stampHeight, stampWidth <= 100000\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def possibleToStamp(self, M, h, w):\n        m, n = len(M), len(M[0])\n        A = [[0] * (n + 1) for _ in range(m + 1)]\n        good = [[0] * n for _ in range(m)]\n        for i in xrange(m):\n            for j in xrange(n):\n                A[i+1][j+1] = A[i+1][j] + A[i][j+1] - A[i][j] + (1 - M[i][j])\n                if i + 1 >= h and j + 1 >= w:\n                    x, y = i+1-h, j+1-w\n                    if A[i+1][j+1] - A[x][j+1] - A[i+1][y] + A[x][y] == w*h:\n                        good[i][j] += 1\n        # for r in A: print r\n        # for r in good: print r\n        B = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in xrange(m):\n            for j in xrange(n):\n                B[i+1][j+1] = B[i+1][j] + B[i][j+1] - B[i][j] + good[i][j]\n        for i in xrange(m):\n            for j in xrange(n):\n                if M[i][j] == 1:\n                    continue\n                x,y = min(i+h,m),min(j+w,n)\n                if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n                    return False\n        return True\n                        \n        \n        \n        "}]}
{"dataset": "LeeTCode_submission", "id": "LeeTCode_submission_4637", "label": "code_high", "messages": [{"role": "user", "content": "How would you implement a function in Python 2 that\n\nYou are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.\nAn island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.\nReturn the number of islands in grid2 that are considered sub-islands.\n\u00a0\nExample 1:\n\nInput: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]\nOutput: 3\nExplanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\nThe 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.\n\nExample 2:\n\nInput: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\nOutput: 2 \nExplanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\nThe 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.\n\n\u00a0\nConstraints:\n\nm == grid1.length == grid2.length\nn == grid1[i].length == grid2[i].length\n1 <= m, n <= 500\ngrid1[i][j] and grid2[i][j] are either 0 or 1.\n\n"}, {"role": "assistant", "content": "class Solution(object):\n    def countSubIslands(self, grid1, grid2):\n        \"\"\"\n        :type grid1: List[List[int]]\n        :type grid2: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid1)\n        m = len(grid1[0])\n        \n        mx = [0, 1, 0, -1]\n        my = [1, 0, -1, 0]\n        idx = 2\n        for i in range(n):\n            for j in range(m):\n                if grid1[i][j] == 1:\n                    q = [[i, j]]\n                    grid1[i][j] = idx\n                    \n                    while len(q) > 0:\n                        x, y = q[0]\n                        q = q[1:]\n                        \n                        for k in range(4):\n                            nx = x + mx[k]\n                            ny = y + my[k]\n                            \n                            if nx >= 0 and nx < n and ny >= 0 and ny < m and grid1[nx][ny] == 1:\n                                q.append([nx, ny])\n                                grid1[nx][ny] = idx\n                    \n                    idx += 1\n        \n        for i in range(n):\n            for j in range(m):\n                if grid2[i][j] == 1:\n                    q = [[i, j]]\n                    grid2[i][j] = idx\n                    \n                    while len(q) > 0:\n                        x, y = q[0]\n                        q = q[1:]\n                        \n                        for k in range(4):\n                            nx = x + mx[k]\n                            ny = y + my[k]\n                            \n                            if nx >= 0 and nx < n and ny >= 0 and ny < m and grid2[nx][ny] == 1:\n                                q.append([nx, ny])\n                                grid2[nx][ny] = idx\n                    \n                    idx += 1\n        \n        fdict = dict()\n        \n        for i in range(n):\n            for j in range(m):\n                if grid2[i][j] != 0:\n                    x = grid2[i][j]\n                    if not x in fdict:\n                        fdict[x] = dict()\n                    fdict[x][grid1[i][j]] = 1\n        \n        ans = 0\n        for v in fdict:\n            if len(fdict[v].keys()) == 1 and fdict[v].keys()[0] != 0:\n                ans += 1\n        \n        return ans"}]}
